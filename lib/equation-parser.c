/* equation-parser.c generated by valac 0.30.0.14-c43a, the Vala compiler
 * generated from equation-parser.vala, do not modify */

/*
 * Copyright (C) 2012 Arth Patel
 * Copyright (C) 2012 Robert Ancell
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version. See http://www.gnu.org/copyleft/gpl.html the full text of the
 * license.
 */
/* Operator Associativity. */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_ASSOCIATIVITY (associativity_get_type ())

#define TYPE_PRECEDENCE (precedence_get_type ())

#define TYPE_PARSE_NODE (parse_node_get_type ())
#define PARSE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARSE_NODE, ParseNode))
#define PARSE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARSE_NODE, ParseNodeClass))
#define IS_PARSE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARSE_NODE))
#define IS_PARSE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARSE_NODE))
#define PARSE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARSE_NODE, ParseNodeClass))

typedef struct _ParseNode ParseNode;
typedef struct _ParseNodeClass ParseNodeClass;
typedef struct _ParseNodePrivate ParseNodePrivate;

#define TYPE_NUMBER (number_get_type ())
#define NUMBER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NUMBER, Number))
#define NUMBER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NUMBER, NumberClass))
#define IS_NUMBER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NUMBER))
#define IS_NUMBER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NUMBER))
#define NUMBER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NUMBER, NumberClass))

typedef struct _Number Number;
typedef struct _NumberClass NumberClass;

#define TYPE_PARSER (parser_get_type ())
#define PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARSER, Parser))
#define PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARSER, ParserClass))
#define IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARSER))
#define IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARSER))
#define PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARSER, ParserClass))

typedef struct _Parser Parser;
typedef struct _ParserClass ParserClass;

#define TYPE_LEXER_TOKEN (lexer_token_get_type ())
#define LEXER_TOKEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LEXER_TOKEN, LexerToken))
#define LEXER_TOKEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LEXER_TOKEN, LexerTokenClass))
#define IS_LEXER_TOKEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LEXER_TOKEN))
#define IS_LEXER_TOKEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LEXER_TOKEN))
#define LEXER_TOKEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LEXER_TOKEN, LexerTokenClass))

typedef struct _LexerToken LexerToken;
typedef struct _LexerTokenClass LexerTokenClass;
#define _parser_unref0(var) ((var == NULL) ? NULL : (var = (parser_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_RNODE (rnode_get_type ())
#define RNODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RNODE, RNode))
#define RNODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RNODE, RNodeClass))
#define IS_RNODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RNODE))
#define IS_RNODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RNODE))
#define RNODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RNODE, RNodeClass))

typedef struct _RNode RNode;
typedef struct _RNodeClass RNodeClass;
typedef struct _RNodePrivate RNodePrivate;

#define TYPE_ERROR_CODE (error_code_get_type ())
typedef struct _LexerTokenPrivate LexerTokenPrivate;

#define TYPE_LEXER_TOKEN_TYPE (lexer_token_type_get_type ())

#define TYPE_LR_NODE (lr_node_get_type ())
#define LR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LR_NODE, LRNode))
#define LR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LR_NODE, LRNodeClass))
#define IS_LR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LR_NODE))
#define IS_LR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LR_NODE))
#define LR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LR_NODE, LRNodeClass))

typedef struct _LRNode LRNode;
typedef struct _LRNodeClass LRNodeClass;
typedef struct _LRNodePrivate LRNodePrivate;

#define TYPE_CONSTANT_NODE (constant_node_get_type ())
#define CONSTANT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONSTANT_NODE, ConstantNode))
#define CONSTANT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONSTANT_NODE, ConstantNodeClass))
#define IS_CONSTANT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONSTANT_NODE))
#define IS_CONSTANT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONSTANT_NODE))
#define CONSTANT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONSTANT_NODE, ConstantNodeClass))

typedef struct _ConstantNode ConstantNode;
typedef struct _ConstantNodeClass ConstantNodeClass;
typedef struct _ConstantNodePrivate ConstantNodePrivate;
typedef struct _ParserPrivate ParserPrivate;

#define TYPE_ANGLE_UNIT (angle_unit_get_type ())

#define TYPE_ASSIGN_NODE (assign_node_get_type ())
#define ASSIGN_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASSIGN_NODE, AssignNode))
#define ASSIGN_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASSIGN_NODE, AssignNodeClass))
#define IS_ASSIGN_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASSIGN_NODE))
#define IS_ASSIGN_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASSIGN_NODE))
#define ASSIGN_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASSIGN_NODE, AssignNodeClass))

typedef struct _AssignNode AssignNode;
typedef struct _AssignNodeClass AssignNodeClass;
typedef struct _AssignNodePrivate AssignNodePrivate;

#define TYPE_ASSIGN_FUNCTION_NODE (assign_function_node_get_type ())
#define ASSIGN_FUNCTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASSIGN_FUNCTION_NODE, AssignFunctionNode))
#define ASSIGN_FUNCTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASSIGN_FUNCTION_NODE, AssignFunctionNodeClass))
#define IS_ASSIGN_FUNCTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASSIGN_FUNCTION_NODE))
#define IS_ASSIGN_FUNCTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASSIGN_FUNCTION_NODE))
#define ASSIGN_FUNCTION_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASSIGN_FUNCTION_NODE, AssignFunctionNodeClass))

typedef struct _AssignFunctionNode AssignFunctionNode;
typedef struct _AssignFunctionNodeClass AssignFunctionNodeClass;
typedef struct _AssignFunctionNodePrivate AssignFunctionNodePrivate;

#define TYPE_FUNCTION_MANAGER (function_manager_get_type ())
#define FUNCTION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_MANAGER, FunctionManager))
#define FUNCTION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_MANAGER, FunctionManagerClass))
#define IS_FUNCTION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_MANAGER))
#define IS_FUNCTION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_MANAGER))
#define FUNCTION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_MANAGER, FunctionManagerClass))

typedef struct _FunctionManager FunctionManager;
typedef struct _FunctionManagerClass FunctionManagerClass;

#define TYPE_NAME_NODE (name_node_get_type ())
#define NAME_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NAME_NODE, NameNode))
#define NAME_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NAME_NODE, NameNodeClass))
#define IS_NAME_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NAME_NODE))
#define IS_NAME_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NAME_NODE))
#define NAME_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NAME_NODE, NameNodeClass))

typedef struct _NameNode NameNode;
typedef struct _NameNodeClass NameNodeClass;
typedef struct _NameNodePrivate NameNodePrivate;

#define TYPE_VARIABLE_NODE (variable_node_get_type ())
#define VARIABLE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VARIABLE_NODE, VariableNode))
#define VARIABLE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VARIABLE_NODE, VariableNodeClass))
#define IS_VARIABLE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VARIABLE_NODE))
#define IS_VARIABLE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VARIABLE_NODE))
#define VARIABLE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VARIABLE_NODE, VariableNodeClass))

typedef struct _VariableNode VariableNode;
typedef struct _VariableNodeClass VariableNodeClass;
typedef struct _VariableNodePrivate VariableNodePrivate;

#define TYPE_VARIABLE_WITH_POWER_NODE (variable_with_power_node_get_type ())
#define VARIABLE_WITH_POWER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VARIABLE_WITH_POWER_NODE, VariableWithPowerNode))
#define VARIABLE_WITH_POWER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VARIABLE_WITH_POWER_NODE, VariableWithPowerNodeClass))
#define IS_VARIABLE_WITH_POWER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VARIABLE_WITH_POWER_NODE))
#define IS_VARIABLE_WITH_POWER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VARIABLE_WITH_POWER_NODE))
#define VARIABLE_WITH_POWER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VARIABLE_WITH_POWER_NODE, VariableWithPowerNodeClass))

typedef struct _VariableWithPowerNode VariableWithPowerNode;
typedef struct _VariableWithPowerNodeClass VariableWithPowerNodeClass;
typedef struct _VariableWithPowerNodePrivate VariableWithPowerNodePrivate;

#define TYPE_FUNCTION_NAME_NODE (function_name_node_get_type ())
#define FUNCTION_NAME_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_NAME_NODE, FunctionNameNode))
#define FUNCTION_NAME_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_NAME_NODE, FunctionNameNodeClass))
#define IS_FUNCTION_NAME_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_NAME_NODE))
#define IS_FUNCTION_NAME_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_NAME_NODE))
#define FUNCTION_NAME_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_NAME_NODE, FunctionNameNodeClass))

typedef struct _FunctionNameNode FunctionNameNode;
typedef struct _FunctionNameNodeClass FunctionNameNodeClass;
typedef struct _FunctionNameNodePrivate FunctionNameNodePrivate;

#define TYPE_FUNCTION_ARGUMENTS_NODE (function_arguments_node_get_type ())
#define FUNCTION_ARGUMENTS_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_ARGUMENTS_NODE, FunctionArgumentsNode))
#define FUNCTION_ARGUMENTS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_ARGUMENTS_NODE, FunctionArgumentsNodeClass))
#define IS_FUNCTION_ARGUMENTS_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_ARGUMENTS_NODE))
#define IS_FUNCTION_ARGUMENTS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_ARGUMENTS_NODE))
#define FUNCTION_ARGUMENTS_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_ARGUMENTS_NODE, FunctionArgumentsNodeClass))

typedef struct _FunctionArgumentsNode FunctionArgumentsNode;
typedef struct _FunctionArgumentsNodeClass FunctionArgumentsNodeClass;
typedef struct _FunctionArgumentsNodePrivate FunctionArgumentsNodePrivate;

#define TYPE_FUNCTION_DESCRIPTION_NODE (function_description_node_get_type ())
#define FUNCTION_DESCRIPTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_DESCRIPTION_NODE, FunctionDescriptionNode))
#define FUNCTION_DESCRIPTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_DESCRIPTION_NODE, FunctionDescriptionNodeClass))
#define IS_FUNCTION_DESCRIPTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_DESCRIPTION_NODE))
#define IS_FUNCTION_DESCRIPTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_DESCRIPTION_NODE))
#define FUNCTION_DESCRIPTION_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_DESCRIPTION_NODE, FunctionDescriptionNodeClass))

typedef struct _FunctionDescriptionNode FunctionDescriptionNode;
typedef struct _FunctionDescriptionNodeClass FunctionDescriptionNodeClass;
typedef struct _FunctionDescriptionNodePrivate FunctionDescriptionNodePrivate;

#define TYPE_FUNCTION_NODE (function_node_get_type ())
#define FUNCTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_NODE, FunctionNode))
#define FUNCTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_NODE, FunctionNodeClass))
#define IS_FUNCTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_NODE))
#define IS_FUNCTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_NODE))
#define FUNCTION_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_NODE, FunctionNodeClass))

typedef struct _FunctionNode FunctionNode;
typedef struct _FunctionNodeClass FunctionNodeClass;
typedef struct _FunctionNodePrivate FunctionNodePrivate;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_EXPRESSION_PARSER (expression_parser_get_type ())
#define EXPRESSION_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_EXPRESSION_PARSER, ExpressionParser))
#define EXPRESSION_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_EXPRESSION_PARSER, ExpressionParserClass))
#define IS_EXPRESSION_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_EXPRESSION_PARSER))
#define IS_EXPRESSION_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_EXPRESSION_PARSER))
#define EXPRESSION_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_EXPRESSION_PARSER, ExpressionParserClass))

typedef struct _ExpressionParser ExpressionParser;
typedef struct _ExpressionParserClass ExpressionParserClass;

#define TYPE_UNARY_MINUS_NODE (unary_minus_node_get_type ())
#define UNARY_MINUS_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UNARY_MINUS_NODE, UnaryMinusNode))
#define UNARY_MINUS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UNARY_MINUS_NODE, UnaryMinusNodeClass))
#define IS_UNARY_MINUS_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UNARY_MINUS_NODE))
#define IS_UNARY_MINUS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UNARY_MINUS_NODE))
#define UNARY_MINUS_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UNARY_MINUS_NODE, UnaryMinusNodeClass))

typedef struct _UnaryMinusNode UnaryMinusNode;
typedef struct _UnaryMinusNodeClass UnaryMinusNodeClass;
typedef struct _UnaryMinusNodePrivate UnaryMinusNodePrivate;

#define TYPE_ABSOLUTE_VALUE_NODE (absolute_value_node_get_type ())
#define ABSOLUTE_VALUE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSOLUTE_VALUE_NODE, AbsoluteValueNode))
#define ABSOLUTE_VALUE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSOLUTE_VALUE_NODE, AbsoluteValueNodeClass))
#define IS_ABSOLUTE_VALUE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSOLUTE_VALUE_NODE))
#define IS_ABSOLUTE_VALUE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSOLUTE_VALUE_NODE))
#define ABSOLUTE_VALUE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSOLUTE_VALUE_NODE, AbsoluteValueNodeClass))

typedef struct _AbsoluteValueNode AbsoluteValueNode;
typedef struct _AbsoluteValueNodeClass AbsoluteValueNodeClass;
typedef struct _AbsoluteValueNodePrivate AbsoluteValueNodePrivate;

#define TYPE_FLOOR_NODE (floor_node_get_type ())
#define FLOOR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FLOOR_NODE, FloorNode))
#define FLOOR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FLOOR_NODE, FloorNodeClass))
#define IS_FLOOR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FLOOR_NODE))
#define IS_FLOOR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FLOOR_NODE))
#define FLOOR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FLOOR_NODE, FloorNodeClass))

typedef struct _FloorNode FloorNode;
typedef struct _FloorNodeClass FloorNodeClass;
typedef struct _FloorNodePrivate FloorNodePrivate;

#define TYPE_CEILING_NODE (ceiling_node_get_type ())
#define CEILING_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CEILING_NODE, CeilingNode))
#define CEILING_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CEILING_NODE, CeilingNodeClass))
#define IS_CEILING_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CEILING_NODE))
#define IS_CEILING_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CEILING_NODE))
#define CEILING_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CEILING_NODE, CeilingNodeClass))

typedef struct _CeilingNode CeilingNode;
typedef struct _CeilingNodeClass CeilingNodeClass;
typedef struct _CeilingNodePrivate CeilingNodePrivate;

#define TYPE_FRACTIONAL_COMPONENT_NODE (fractional_component_node_get_type ())
#define FRACTIONAL_COMPONENT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FRACTIONAL_COMPONENT_NODE, FractionalComponentNode))
#define FRACTIONAL_COMPONENT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FRACTIONAL_COMPONENT_NODE, FractionalComponentNodeClass))
#define IS_FRACTIONAL_COMPONENT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FRACTIONAL_COMPONENT_NODE))
#define IS_FRACTIONAL_COMPONENT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FRACTIONAL_COMPONENT_NODE))
#define FRACTIONAL_COMPONENT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FRACTIONAL_COMPONENT_NODE, FractionalComponentNodeClass))

typedef struct _FractionalComponentNode FractionalComponentNode;
typedef struct _FractionalComponentNodeClass FractionalComponentNodeClass;
typedef struct _FractionalComponentNodePrivate FractionalComponentNodePrivate;

#define TYPE_ROUND_NODE (round_node_get_type ())
#define ROUND_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ROUND_NODE, RoundNode))
#define ROUND_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ROUND_NODE, RoundNodeClass))
#define IS_ROUND_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ROUND_NODE))
#define IS_ROUND_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ROUND_NODE))
#define ROUND_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ROUND_NODE, RoundNodeClass))

typedef struct _RoundNode RoundNode;
typedef struct _RoundNodeClass RoundNodeClass;
typedef struct _RoundNodePrivate RoundNodePrivate;

#define TYPE_PERCENT_NODE (percent_node_get_type ())
#define PERCENT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PERCENT_NODE, PercentNode))
#define PERCENT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PERCENT_NODE, PercentNodeClass))
#define IS_PERCENT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PERCENT_NODE))
#define IS_PERCENT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PERCENT_NODE))
#define PERCENT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PERCENT_NODE, PercentNodeClass))

typedef struct _PercentNode PercentNode;
typedef struct _PercentNodeClass PercentNodeClass;
typedef struct _PercentNodePrivate PercentNodePrivate;

#define TYPE_FACTORIAL_NODE (factorial_node_get_type ())
#define FACTORIAL_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FACTORIAL_NODE, FactorialNode))
#define FACTORIAL_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FACTORIAL_NODE, FactorialNodeClass))
#define IS_FACTORIAL_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FACTORIAL_NODE))
#define IS_FACTORIAL_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FACTORIAL_NODE))
#define FACTORIAL_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FACTORIAL_NODE, FactorialNodeClass))

typedef struct _FactorialNode FactorialNode;
typedef struct _FactorialNodeClass FactorialNodeClass;
typedef struct _FactorialNodePrivate FactorialNodePrivate;

#define TYPE_ADD_NODE (add_node_get_type ())
#define ADD_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD_NODE, AddNode))
#define ADD_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD_NODE, AddNodeClass))
#define IS_ADD_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD_NODE))
#define IS_ADD_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD_NODE))
#define ADD_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD_NODE, AddNodeClass))

typedef struct _AddNode AddNode;
typedef struct _AddNodeClass AddNodeClass;
typedef struct _AddNodePrivate AddNodePrivate;

#define TYPE_SUBTRACT_NODE (subtract_node_get_type ())
#define SUBTRACT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SUBTRACT_NODE, SubtractNode))
#define SUBTRACT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SUBTRACT_NODE, SubtractNodeClass))
#define IS_SUBTRACT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SUBTRACT_NODE))
#define IS_SUBTRACT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SUBTRACT_NODE))
#define SUBTRACT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SUBTRACT_NODE, SubtractNodeClass))

typedef struct _SubtractNode SubtractNode;
typedef struct _SubtractNodeClass SubtractNodeClass;
typedef struct _SubtractNodePrivate SubtractNodePrivate;

#define TYPE_MULTIPLY_NODE (multiply_node_get_type ())
#define MULTIPLY_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MULTIPLY_NODE, MultiplyNode))
#define MULTIPLY_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MULTIPLY_NODE, MultiplyNodeClass))
#define IS_MULTIPLY_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MULTIPLY_NODE))
#define IS_MULTIPLY_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MULTIPLY_NODE))
#define MULTIPLY_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MULTIPLY_NODE, MultiplyNodeClass))

typedef struct _MultiplyNode MultiplyNode;
typedef struct _MultiplyNodeClass MultiplyNodeClass;
typedef struct _MultiplyNodePrivate MultiplyNodePrivate;

#define TYPE_DIVIDE_NODE (divide_node_get_type ())
#define DIVIDE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DIVIDE_NODE, DivideNode))
#define DIVIDE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DIVIDE_NODE, DivideNodeClass))
#define IS_DIVIDE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DIVIDE_NODE))
#define IS_DIVIDE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DIVIDE_NODE))
#define DIVIDE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DIVIDE_NODE, DivideNodeClass))

typedef struct _DivideNode DivideNode;
typedef struct _DivideNodeClass DivideNodeClass;
typedef struct _DivideNodePrivate DivideNodePrivate;

#define TYPE_MODULUS_DIVIDE_NODE (modulus_divide_node_get_type ())
#define MODULUS_DIVIDE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MODULUS_DIVIDE_NODE, ModulusDivideNode))
#define MODULUS_DIVIDE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MODULUS_DIVIDE_NODE, ModulusDivideNodeClass))
#define IS_MODULUS_DIVIDE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MODULUS_DIVIDE_NODE))
#define IS_MODULUS_DIVIDE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MODULUS_DIVIDE_NODE))
#define MODULUS_DIVIDE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MODULUS_DIVIDE_NODE, ModulusDivideNodeClass))

typedef struct _ModulusDivideNode ModulusDivideNode;
typedef struct _ModulusDivideNodeClass ModulusDivideNodeClass;
typedef struct _ModulusDivideNodePrivate ModulusDivideNodePrivate;

#define TYPE_XPOW_YNODE (xpow_ynode_get_type ())
#define XPOW_YNODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XPOW_YNODE, XPowYNode))
#define XPOW_YNODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XPOW_YNODE, XPowYNodeClass))
#define IS_XPOW_YNODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XPOW_YNODE))
#define IS_XPOW_YNODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XPOW_YNODE))
#define XPOW_YNODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XPOW_YNODE, XPowYNodeClass))

typedef struct _XPowYNode XPowYNode;
typedef struct _XPowYNodeClass XPowYNodeClass;

#define TYPE_ROOT_NODE (root_node_get_type ())
#define ROOT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ROOT_NODE, RootNode))
#define ROOT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ROOT_NODE, RootNodeClass))
#define IS_ROOT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ROOT_NODE))
#define IS_ROOT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ROOT_NODE))
#define ROOT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ROOT_NODE, RootNodeClass))

typedef struct _RootNode RootNode;
typedef struct _RootNodeClass RootNodeClass;
typedef struct _RootNodePrivate RootNodePrivate;
typedef struct _XPowYNodePrivate XPowYNodePrivate;

#define TYPE_XPOW_YINTEGER_NODE (xpow_yinteger_node_get_type ())
#define XPOW_YINTEGER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XPOW_YINTEGER_NODE, XPowYIntegerNode))
#define XPOW_YINTEGER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XPOW_YINTEGER_NODE, XPowYIntegerNodeClass))
#define IS_XPOW_YINTEGER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XPOW_YINTEGER_NODE))
#define IS_XPOW_YINTEGER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XPOW_YINTEGER_NODE))
#define XPOW_YINTEGER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XPOW_YINTEGER_NODE, XPowYIntegerNodeClass))

typedef struct _XPowYIntegerNode XPowYIntegerNode;
typedef struct _XPowYIntegerNodeClass XPowYIntegerNodeClass;
typedef struct _XPowYIntegerNodePrivate XPowYIntegerNodePrivate;

#define TYPE_NOT_NODE (not_node_get_type ())
#define NOT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NOT_NODE, NotNode))
#define NOT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NOT_NODE, NotNodeClass))
#define IS_NOT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NOT_NODE))
#define IS_NOT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NOT_NODE))
#define NOT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NOT_NODE, NotNodeClass))

typedef struct _NotNode NotNode;
typedef struct _NotNodeClass NotNodeClass;
typedef struct _NotNodePrivate NotNodePrivate;

#define TYPE_AND_NODE (and_node_get_type ())
#define AND_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AND_NODE, AndNode))
#define AND_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AND_NODE, AndNodeClass))
#define IS_AND_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AND_NODE))
#define IS_AND_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AND_NODE))
#define AND_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AND_NODE, AndNodeClass))

typedef struct _AndNode AndNode;
typedef struct _AndNodeClass AndNodeClass;
typedef struct _AndNodePrivate AndNodePrivate;

#define TYPE_OR_NODE (or_node_get_type ())
#define OR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OR_NODE, OrNode))
#define OR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OR_NODE, OrNodeClass))
#define IS_OR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OR_NODE))
#define IS_OR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OR_NODE))
#define OR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OR_NODE, OrNodeClass))

typedef struct _OrNode OrNode;
typedef struct _OrNodeClass OrNodeClass;
typedef struct _OrNodePrivate OrNodePrivate;

#define TYPE_XOR_NODE (xor_node_get_type ())
#define XOR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XOR_NODE, XorNode))
#define XOR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XOR_NODE, XorNodeClass))
#define IS_XOR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XOR_NODE))
#define IS_XOR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XOR_NODE))
#define XOR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XOR_NODE, XorNodeClass))

typedef struct _XorNode XorNode;
typedef struct _XorNodeClass XorNodeClass;
typedef struct _XorNodePrivate XorNodePrivate;

#define TYPE_CONVERT_NODE (convert_node_get_type ())
#define CONVERT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONVERT_NODE, ConvertNode))
#define CONVERT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONVERT_NODE, ConvertNodeClass))
#define IS_CONVERT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONVERT_NODE))
#define IS_CONVERT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONVERT_NODE))
#define CONVERT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONVERT_NODE, ConvertNodeClass))

typedef struct _ConvertNode ConvertNode;
typedef struct _ConvertNodeClass ConvertNodeClass;
typedef struct _ConvertNodePrivate ConvertNodePrivate;

#define TYPE_CONVERT_BASE_NODE (convert_base_node_get_type ())
#define CONVERT_BASE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONVERT_BASE_NODE, ConvertBaseNode))
#define CONVERT_BASE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONVERT_BASE_NODE, ConvertBaseNodeClass))
#define IS_CONVERT_BASE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONVERT_BASE_NODE))
#define IS_CONVERT_BASE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONVERT_BASE_NODE))
#define CONVERT_BASE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONVERT_BASE_NODE, ConvertBaseNodeClass))

typedef struct _ConvertBaseNode ConvertBaseNode;
typedef struct _ConvertBaseNodeClass ConvertBaseNodeClass;
typedef struct _ConvertBaseNodePrivate ConvertBaseNodePrivate;

#define TYPE_CONVERT_NUMBER_NODE (convert_number_node_get_type ())
#define CONVERT_NUMBER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONVERT_NUMBER_NODE, ConvertNumberNode))
#define CONVERT_NUMBER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONVERT_NUMBER_NODE, ConvertNumberNodeClass))
#define IS_CONVERT_NUMBER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONVERT_NUMBER_NODE))
#define IS_CONVERT_NUMBER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONVERT_NUMBER_NODE))
#define CONVERT_NUMBER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONVERT_NUMBER_NODE, ConvertNumberNodeClass))

typedef struct _ConvertNumberNode ConvertNumberNode;
typedef struct _ConvertNumberNodeClass ConvertNumberNodeClass;
typedef struct _ConvertNumberNodePrivate ConvertNumberNodePrivate;

#define TYPE_LEXER (lexer_get_type ())
#define LEXER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LEXER, Lexer))
#define LEXER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LEXER, LexerClass))
#define IS_LEXER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LEXER))
#define IS_LEXER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LEXER))
#define LEXER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LEXER, LexerClass))

typedef struct _Lexer Lexer;
typedef struct _LexerClass LexerClass;
typedef struct _ParamSpecParser ParamSpecParser;

typedef enum  {
	ASSOCIATIVITY_LEFT,
	ASSOCIATIVITY_RIGHT
} Associativity;

typedef enum  {
	PRECEDENCE_UNKNOWN = 0,
	PRECEDENCE_ADD_SUBTRACT = 1,
	PRECEDENCE_MULTIPLY = 2,
	PRECEDENCE_MOD = 3,
	PRECEDENCE_DIVIDE = 3,
	PRECEDENCE_NOT = 4,
	PRECEDENCE_ROOT = 5,
	PRECEDENCE_FUNCTION = 6,
	PRECEDENCE_BOOLEAN = 7,
	PRECEDENCE_PERCENTAGE = 8,
	PRECEDENCE_UNARY_MINUS = 9,
	PRECEDENCE_POWER = 9,
	PRECEDENCE_FACTORIAL = 10,
	PRECEDENCE_NUMBER_VARIABLE = 11,
	PRECEDENCE_DEPTH
} Precedence;

struct _ParseNode {
	GObject parent_instance;
	ParseNodePrivate * priv;
	Parser* parser;
	ParseNode* parent;
	ParseNode* left;
	ParseNode* right;
	LexerToken* token;
	guint precedence;
	Associativity associativity;
	gchar* value;
};

struct _ParseNodeClass {
	GObjectClass parent_class;
	Number* (*solve) (ParseNode* self);
};

struct _RNode {
	ParseNode parent_instance;
	RNodePrivate * priv;
};

struct _RNodeClass {
	ParseNodeClass parent_class;
	Number* (*solve_r) (RNode* self, Number* r);
};

typedef enum  {
	ERROR_CODE_NONE,
	ERROR_CODE_INVALID,
	ERROR_CODE_OVERFLOW,
	ERROR_CODE_UNKNOWN_VARIABLE,
	ERROR_CODE_UNKNOWN_FUNCTION,
	ERROR_CODE_UNKNOWN_CONVERSION,
	ERROR_CODE_MP
} ErrorCode;

typedef enum  {
	LEXER_TOKEN_TYPE_UNKNOWN,
	LEXER_TOKEN_TYPE_PL_DECIMAL,
	LEXER_TOKEN_TYPE_PL_DIGIT,
	LEXER_TOKEN_TYPE_PL_HEX,
	LEXER_TOKEN_TYPE_PL_SUPER_DIGIT,
	LEXER_TOKEN_TYPE_PL_SUPER_MINUS,
	LEXER_TOKEN_TYPE_PL_SUB_DIGIT,
	LEXER_TOKEN_TYPE_PL_FRACTION,
	LEXER_TOKEN_TYPE_PL_DEGREE,
	LEXER_TOKEN_TYPE_PL_MINUTE,
	LEXER_TOKEN_TYPE_PL_SECOND,
	LEXER_TOKEN_TYPE_PL_LETTER,
	LEXER_TOKEN_TYPE_PL_EOS,
	LEXER_TOKEN_TYPE_PL_SKIP,
	LEXER_TOKEN_TYPE_ADD,
	LEXER_TOKEN_TYPE_SUBTRACT,
	LEXER_TOKEN_TYPE_MULTIPLY,
	LEXER_TOKEN_TYPE_DIVIDE,
	LEXER_TOKEN_TYPE_MOD,
	LEXER_TOKEN_TYPE_L_FLOOR,
	LEXER_TOKEN_TYPE_R_FLOOR,
	LEXER_TOKEN_TYPE_L_CEILING,
	LEXER_TOKEN_TYPE_R_CEILING,
	LEXER_TOKEN_TYPE_ROOT,
	LEXER_TOKEN_TYPE_ROOT_3,
	LEXER_TOKEN_TYPE_ROOT_4,
	LEXER_TOKEN_TYPE_NOT,
	LEXER_TOKEN_TYPE_AND,
	LEXER_TOKEN_TYPE_OR,
	LEXER_TOKEN_TYPE_XOR,
	LEXER_TOKEN_TYPE_IN,
	LEXER_TOKEN_TYPE_NUMBER,
	LEXER_TOKEN_TYPE_SUP_NUMBER,
	LEXER_TOKEN_TYPE_NSUP_NUMBER,
	LEXER_TOKEN_TYPE_SUB_NUMBER,
	LEXER_TOKEN_TYPE_FUNCTION,
	LEXER_TOKEN_TYPE_VARIABLE,
	LEXER_TOKEN_TYPE_ASSIGN,
	LEXER_TOKEN_TYPE_L_R_BRACKET,
	LEXER_TOKEN_TYPE_R_R_BRACKET,
	LEXER_TOKEN_TYPE_L_S_BRACKET,
	LEXER_TOKEN_TYPE_R_S_BRACKET,
	LEXER_TOKEN_TYPE_L_C_BRACKET,
	LEXER_TOKEN_TYPE_R_C_BRACKET,
	LEXER_TOKEN_TYPE_ABS,
	LEXER_TOKEN_TYPE_POWER,
	LEXER_TOKEN_TYPE_FACTORIAL,
	LEXER_TOKEN_TYPE_PERCENTAGE,
	LEXER_TOKEN_TYPE_ARGUMENT_SEPARATOR
} LexerTokenType;

struct _LexerToken {
	GObject parent_instance;
	LexerTokenPrivate * priv;
	gchar* text;
	guint start_index;
	guint end_index;
	LexerTokenType type;
};

struct _LexerTokenClass {
	GObjectClass parent_class;
};

struct _LRNode {
	ParseNode parent_instance;
	LRNodePrivate * priv;
};

struct _LRNodeClass {
	ParseNodeClass parent_class;
	Number* (*solve_lr) (LRNode* self, Number* left, Number* r);
};

struct _ConstantNode {
	ParseNode parent_instance;
	ConstantNodePrivate * priv;
};

struct _ConstantNodeClass {
	ParseNodeClass parent_class;
};

typedef enum  {
	ANGLE_UNIT_RADIANS,
	ANGLE_UNIT_DEGREES,
	ANGLE_UNIT_GRADIANS
} AngleUnit;

struct _Parser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ParserPrivate * priv;
	gint number_base;
	gint wordlen;
	AngleUnit angle_units;
};

struct _ParserClass {
	GTypeClass parent_class;
	void (*finalize) (Parser *self);
	gboolean (*variable_is_defined) (Parser* self, const gchar* name);
	Number* (*get_variable) (Parser* self, const gchar* name);
	void (*set_variable) (Parser* self, const gchar* name, Number* x);
	gboolean (*function_is_defined) (Parser* self, const gchar* name);
	Number* (*convert) (Parser* self, Number* x, const gchar* x_units, const gchar* z_units);
};

struct _AssignNode {
	RNode parent_instance;
	AssignNodePrivate * priv;
};

struct _AssignNodeClass {
	RNodeClass parent_class;
};

struct _AssignFunctionNode {
	ParseNode parent_instance;
	AssignFunctionNodePrivate * priv;
};

struct _AssignFunctionNodeClass {
	ParseNodeClass parent_class;
};

struct _NameNode {
	ParseNode parent_instance;
	NameNodePrivate * priv;
};

struct _NameNodeClass {
	ParseNodeClass parent_class;
};

struct _VariableNode {
	ParseNode parent_instance;
	VariableNodePrivate * priv;
};

struct _VariableNodeClass {
	ParseNodeClass parent_class;
};

struct _VariableWithPowerNode {
	ParseNode parent_instance;
	VariableWithPowerNodePrivate * priv;
};

struct _VariableWithPowerNodeClass {
	ParseNodeClass parent_class;
};

struct _FunctionNameNode {
	NameNode parent_instance;
	FunctionNameNodePrivate * priv;
};

struct _FunctionNameNodeClass {
	NameNodeClass parent_class;
};

struct _FunctionArgumentsNode {
	NameNode parent_instance;
	FunctionArgumentsNodePrivate * priv;
};

struct _FunctionArgumentsNodeClass {
	NameNodeClass parent_class;
};

struct _FunctionDescriptionNode {
	NameNode parent_instance;
	FunctionDescriptionNodePrivate * priv;
};

struct _FunctionDescriptionNodeClass {
	NameNodeClass parent_class;
};

struct _FunctionNode {
	ParseNode parent_instance;
	FunctionNodePrivate * priv;
};

struct _FunctionNodeClass {
	ParseNodeClass parent_class;
};

struct _UnaryMinusNode {
	RNode parent_instance;
	UnaryMinusNodePrivate * priv;
};

struct _UnaryMinusNodeClass {
	RNodeClass parent_class;
};

struct _AbsoluteValueNode {
	RNode parent_instance;
	AbsoluteValueNodePrivate * priv;
};

struct _AbsoluteValueNodeClass {
	RNodeClass parent_class;
};

struct _FloorNode {
	RNode parent_instance;
	FloorNodePrivate * priv;
};

struct _FloorNodeClass {
	RNodeClass parent_class;
};

struct _CeilingNode {
	RNode parent_instance;
	CeilingNodePrivate * priv;
};

struct _CeilingNodeClass {
	RNodeClass parent_class;
};

struct _FractionalComponentNode {
	RNode parent_instance;
	FractionalComponentNodePrivate * priv;
};

struct _FractionalComponentNodeClass {
	RNodeClass parent_class;
};

struct _RoundNode {
	RNode parent_instance;
	RoundNodePrivate * priv;
};

struct _RoundNodeClass {
	RNodeClass parent_class;
};

struct _PercentNode {
	RNode parent_instance;
	PercentNodePrivate * priv;
};

struct _PercentNodeClass {
	RNodeClass parent_class;
};

struct _FactorialNode {
	RNode parent_instance;
	FactorialNodePrivate * priv;
};

struct _FactorialNodeClass {
	RNodeClass parent_class;
};

struct _AddNode {
	LRNode parent_instance;
	AddNodePrivate * priv;
	gboolean do_percentage;
};

struct _AddNodeClass {
	LRNodeClass parent_class;
};

struct _SubtractNode {
	LRNode parent_instance;
	SubtractNodePrivate * priv;
	gboolean do_percentage;
};

struct _SubtractNodeClass {
	LRNodeClass parent_class;
};

struct _MultiplyNode {
	LRNode parent_instance;
	MultiplyNodePrivate * priv;
};

struct _MultiplyNodeClass {
	LRNodeClass parent_class;
};

struct _DivideNode {
	LRNode parent_instance;
	DivideNodePrivate * priv;
};

struct _DivideNodeClass {
	LRNodeClass parent_class;
};

struct _ModulusDivideNode {
	LRNode parent_instance;
	ModulusDivideNodePrivate * priv;
};

struct _ModulusDivideNodeClass {
	LRNodeClass parent_class;
};

struct _RootNode {
	RNode parent_instance;
	RootNodePrivate * priv;
};

struct _RootNodeClass {
	RNodeClass parent_class;
};

struct _RootNodePrivate {
	gint n;
};

struct _XPowYNode {
	LRNode parent_instance;
	XPowYNodePrivate * priv;
};

struct _XPowYNodeClass {
	LRNodeClass parent_class;
};

struct _XPowYIntegerNode {
	ParseNode parent_instance;
	XPowYIntegerNodePrivate * priv;
};

struct _XPowYIntegerNodeClass {
	ParseNodeClass parent_class;
};

struct _NotNode {
	RNode parent_instance;
	NotNodePrivate * priv;
};

struct _NotNodeClass {
	RNodeClass parent_class;
};

struct _AndNode {
	LRNode parent_instance;
	AndNodePrivate * priv;
};

struct _AndNodeClass {
	LRNodeClass parent_class;
};

struct _OrNode {
	LRNode parent_instance;
	OrNodePrivate * priv;
};

struct _OrNodeClass {
	LRNodeClass parent_class;
};

struct _XorNode {
	LRNode parent_instance;
	XorNodePrivate * priv;
};

struct _XorNodeClass {
	LRNodeClass parent_class;
};

struct _ConvertNode {
	LRNode parent_instance;
	ConvertNodePrivate * priv;
};

struct _ConvertNodeClass {
	LRNodeClass parent_class;
};

struct _ConvertBaseNode {
	ParseNode parent_instance;
	ConvertBaseNodePrivate * priv;
};

struct _ConvertBaseNodeClass {
	ParseNodeClass parent_class;
};

struct _ConvertNumberNode {
	ParseNode parent_instance;
	ConvertNumberNodePrivate * priv;
};

struct _ConvertNumberNodeClass {
	ParseNodeClass parent_class;
};

struct _ParserPrivate {
	gchar* input;
	ParseNode* root;
	ParseNode* right_most;
	Lexer* lexer;
	guint depth_level;
	ErrorCode error;
	gchar* error_token;
	gint error_token_start;
	gint error_token_end;
	guint representation_base;
};

struct _ParamSpecParser {
	GParamSpec parent_instance;
};


static gpointer parse_node_parent_class = NULL;
static gpointer rnode_parent_class = NULL;
static gpointer lr_node_parent_class = NULL;
static gpointer constant_node_parent_class = NULL;
static gpointer assign_node_parent_class = NULL;
static gpointer assign_function_node_parent_class = NULL;
static gpointer name_node_parent_class = NULL;
static gpointer variable_node_parent_class = NULL;
static gpointer variable_with_power_node_parent_class = NULL;
static gpointer function_name_node_parent_class = NULL;
static gpointer function_arguments_node_parent_class = NULL;
static gpointer function_description_node_parent_class = NULL;
static gpointer function_node_parent_class = NULL;
static gpointer unary_minus_node_parent_class = NULL;
static gpointer absolute_value_node_parent_class = NULL;
static gpointer floor_node_parent_class = NULL;
static gpointer ceiling_node_parent_class = NULL;
static gpointer fractional_component_node_parent_class = NULL;
static gpointer round_node_parent_class = NULL;
static gpointer percent_node_parent_class = NULL;
static gpointer factorial_node_parent_class = NULL;
static gpointer add_node_parent_class = NULL;
static gpointer subtract_node_parent_class = NULL;
static gpointer multiply_node_parent_class = NULL;
static gpointer divide_node_parent_class = NULL;
static gpointer modulus_divide_node_parent_class = NULL;
static gpointer root_node_parent_class = NULL;
static gpointer xpow_ynode_parent_class = NULL;
static gpointer xpow_yinteger_node_parent_class = NULL;
static gpointer not_node_parent_class = NULL;
static gpointer and_node_parent_class = NULL;
static gpointer or_node_parent_class = NULL;
static gpointer xor_node_parent_class = NULL;
static gpointer convert_node_parent_class = NULL;
static gpointer convert_base_node_parent_class = NULL;
static gpointer convert_number_node_parent_class = NULL;
static gpointer parser_parent_class = NULL;

GType associativity_get_type (void) G_GNUC_CONST;
GType precedence_get_type (void) G_GNUC_CONST;
GType parse_node_get_type (void) G_GNUC_CONST;
GType number_get_type (void) G_GNUC_CONST;
gpointer parser_ref (gpointer instance);
void parser_unref (gpointer instance);
GParamSpec* param_spec_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_parser (GValue* value, gpointer v_object);
void value_take_parser (GValue* value, gpointer v_object);
gpointer value_get_parser (const GValue* value);
GType parser_get_type (void) G_GNUC_CONST;
GType lexer_token_get_type (void) G_GNUC_CONST;
enum  {
	PARSE_NODE_DUMMY_PROPERTY
};
ParseNode* parse_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value);
ParseNode* parse_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value);
Number* parse_node_solve (ParseNode* self);
static Number* parse_node_real_solve (ParseNode* self);
static void parse_node_finalize (GObject* obj);
GType rnode_get_type (void) G_GNUC_CONST;
enum  {
	RNODE_DUMMY_PROPERTY
};
RNode* rnode_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* rnode_real_solve (ParseNode* base);
Number* rnode_solve_r (RNode* self, Number* r);
void number_check_flags (void);
const gchar* number_get_error (void);
GType error_code_get_type (void) G_GNUC_CONST;
void parser_set_error (Parser* self, ErrorCode errorno, const gchar* token, guint token_start, guint token_end);
GType lexer_token_type_get_type (void) G_GNUC_CONST;
void number_set_error (const gchar* value);
static Number* rnode_real_solve_r (RNode* self, Number* r);
GType lr_node_get_type (void) G_GNUC_CONST;
enum  {
	LR_NODE_DUMMY_PROPERTY
};
LRNode* lr_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* lr_node_real_solve (ParseNode* base);
Number* lr_node_solve_lr (LRNode* self, Number* left, Number* r);
static Number* lr_node_real_solve_lr (LRNode* self, Number* left, Number* r);
GType constant_node_get_type (void) G_GNUC_CONST;
enum  {
	CONSTANT_NODE_DUMMY_PROPERTY
};
ConstantNode* constant_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
ConstantNode* constant_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* constant_node_real_solve (ParseNode* base);
Number* mp_set_from_string (const gchar* str, gint default_base);
GType angle_unit_get_type (void) G_GNUC_CONST;
GType assign_node_get_type (void) G_GNUC_CONST;
enum  {
	ASSIGN_NODE_DUMMY_PROPERTY
};
AssignNode* assign_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AssignNode* assign_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* assign_node_real_solve_r (RNode* base, Number* r);
void parser_set_variable (Parser* self, const gchar* name, Number* x);
GType assign_function_node_get_type (void) G_GNUC_CONST;
enum  {
	ASSIGN_FUNCTION_NODE_DUMMY_PROPERTY
};
AssignFunctionNode* assign_function_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AssignFunctionNode* assign_function_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* assign_function_node_real_solve (ParseNode* base);
GType function_manager_get_type (void) G_GNUC_CONST;
FunctionManager* function_manager_get_default_function_manager (void);
gboolean function_manager_add_function_with_properties (FunctionManager* self, const gchar* name, const gchar* arguments, const gchar* description, Parser* root_parser);
Number* number_new_integer (gint64 value);
Number* number_construct_integer (GType object_type, gint64 value);
GType name_node_get_type (void) G_GNUC_CONST;
enum  {
	NAME_NODE_DUMMY_PROPERTY
};
NameNode* name_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
NameNode* name_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
GType variable_node_get_type (void) G_GNUC_CONST;
enum  {
	VARIABLE_NODE_DUMMY_PROPERTY
};
VariableNode* variable_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
VariableNode* variable_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* variable_node_real_solve (ParseNode* base);
Number* parser_get_variable (Parser* self, const gchar* name);
Number* number_multiply (Number* self, Number* y);
GType variable_with_power_node_get_type (void) G_GNUC_CONST;
enum  {
	VARIABLE_WITH_POWER_NODE_DUMMY_PROPERTY
};
VariableWithPowerNode* variable_with_power_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
VariableWithPowerNode* variable_with_power_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
static Number* variable_with_power_node_real_solve (ParseNode* base);
gint super_atoi (const gchar* data);
Number* number_xpowy_integer (Number* self, gint64 n);
GType function_name_node_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTION_NAME_NODE_DUMMY_PROPERTY
};
FunctionNameNode* function_name_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* name);
FunctionNameNode* function_name_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* name);
GType function_arguments_node_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTION_ARGUMENTS_NODE_DUMMY_PROPERTY
};
FunctionArgumentsNode* function_arguments_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* arguments);
FunctionArgumentsNode* function_arguments_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* arguments);
GType function_description_node_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTION_DESCRIPTION_NODE_DUMMY_PROPERTY
};
FunctionDescriptionNode* function_description_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* description);
FunctionDescriptionNode* function_description_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* description);
GType function_node_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTION_NODE_DUMMY_PROPERTY
};
FunctionNode* function_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
FunctionNode* function_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
static Number* function_node_real_solve (ParseNode* base);
GType expression_parser_get_type (void) G_GNUC_CONST;
ExpressionParser* expression_parser_new (const gchar* expression, Parser* root_parser);
ExpressionParser* expression_parser_construct (GType object_type, const gchar* expression, Parser* root_parser);
Number* parser_parse (Parser* self, guint* representation_base, ErrorCode* error_code, gchar** error_token, guint* error_start, guint* error_end);
static void _vala_array_add1 (Number*** array, int* length, int* size, Number* value);
static void _vala_array_add2 (Number*** array, int* length, int* size, Number* value);
Number* function_manager_evaluate_function (FunctionManager* self, const gchar* name, Number** arguments, int arguments_length1, Parser* parser);
GType unary_minus_node_get_type (void) G_GNUC_CONST;
enum  {
	UNARY_MINUS_NODE_DUMMY_PROPERTY
};
UnaryMinusNode* unary_minus_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
UnaryMinusNode* unary_minus_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* unary_minus_node_real_solve_r (RNode* base, Number* r);
Number* number_invert_sign (Number* self);
GType absolute_value_node_get_type (void) G_GNUC_CONST;
enum  {
	ABSOLUTE_VALUE_NODE_DUMMY_PROPERTY
};
AbsoluteValueNode* absolute_value_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AbsoluteValueNode* absolute_value_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* absolute_value_node_real_solve_r (RNode* base, Number* r);
Number* number_abs (Number* self);
GType floor_node_get_type (void) G_GNUC_CONST;
enum  {
	FLOOR_NODE_DUMMY_PROPERTY
};
FloorNode* floor_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
FloorNode* floor_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* floor_node_real_solve_r (RNode* base, Number* r);
Number* number_floor (Number* self);
GType ceiling_node_get_type (void) G_GNUC_CONST;
enum  {
	CEILING_NODE_DUMMY_PROPERTY
};
CeilingNode* ceiling_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
CeilingNode* ceiling_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* ceiling_node_real_solve_r (RNode* base, Number* r);
Number* number_ceiling (Number* self);
GType fractional_component_node_get_type (void) G_GNUC_CONST;
enum  {
	FRACTIONAL_COMPONENT_NODE_DUMMY_PROPERTY
};
FractionalComponentNode* fractional_component_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
FractionalComponentNode* fractional_component_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* fractional_component_node_real_solve_r (RNode* base, Number* r);
Number* number_fractional_part (Number* self);
GType round_node_get_type (void) G_GNUC_CONST;
enum  {
	ROUND_NODE_DUMMY_PROPERTY
};
RoundNode* round_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
RoundNode* round_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* round_node_real_solve_r (RNode* base, Number* r);
Number* number_round (Number* self);
GType percent_node_get_type (void) G_GNUC_CONST;
enum  {
	PERCENT_NODE_DUMMY_PROPERTY
};
PercentNode* percent_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
PercentNode* percent_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* percent_node_real_solve_r (RNode* base, Number* r);
Number* number_divide_integer (Number* self, gint64 y);
GType factorial_node_get_type (void) G_GNUC_CONST;
enum  {
	FACTORIAL_NODE_DUMMY_PROPERTY
};
FactorialNode* factorial_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
FactorialNode* factorial_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* factorial_node_real_solve_r (RNode* base, Number* r);
Number* number_factorial (Number* self);
GType add_node_get_type (void) G_GNUC_CONST;
enum  {
	ADD_NODE_DUMMY_PROPERTY
};
AddNode* add_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AddNode* add_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* add_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_add (Number* self, Number* y);
static void add_node_finalize (GObject* obj);
GType subtract_node_get_type (void) G_GNUC_CONST;
enum  {
	SUBTRACT_NODE_DUMMY_PROPERTY
};
SubtractNode* subtract_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
SubtractNode* subtract_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* subtract_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_subtract (Number* self, Number* y);
static void subtract_node_finalize (GObject* obj);
GType multiply_node_get_type (void) G_GNUC_CONST;
enum  {
	MULTIPLY_NODE_DUMMY_PROPERTY
};
MultiplyNode* multiply_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
MultiplyNode* multiply_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* multiply_node_real_solve_lr (LRNode* base, Number* l, Number* r);
GType divide_node_get_type (void) G_GNUC_CONST;
enum  {
	DIVIDE_NODE_DUMMY_PROPERTY
};
DivideNode* divide_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
DivideNode* divide_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* divide_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_divide (Number* self, Number* y);
GType modulus_divide_node_get_type (void) G_GNUC_CONST;
enum  {
	MODULUS_DIVIDE_NODE_DUMMY_PROPERTY
};
ModulusDivideNode* modulus_divide_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
ModulusDivideNode* modulus_divide_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* modulus_divide_node_real_solve (ParseNode* base);
GType xpow_ynode_get_type (void) G_GNUC_CONST;
Number* number_modular_exponentiation (Number* self, Number* exp, Number* mod);
static Number* modulus_divide_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_modulus_divide (Number* self, Number* y);
GType root_node_get_type (void) G_GNUC_CONST;
#define ROOT_NODE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_ROOT_NODE, RootNodePrivate))
enum  {
	ROOT_NODE_DUMMY_PROPERTY
};
RootNode* root_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, gint n);
RootNode* root_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, gint n);
static Number* root_node_real_solve_r (RNode* base, Number* r);
Number* number_root (Number* self, gint64 n);
static void root_node_finalize (GObject* obj);
enum  {
	XPOW_YNODE_DUMMY_PROPERTY
};
XPowYNode* xpow_ynode_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
XPowYNode* xpow_ynode_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* xpow_ynode_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_xpowy (Number* self, Number* y);
GType xpow_yinteger_node_get_type (void) G_GNUC_CONST;
enum  {
	XPOW_YINTEGER_NODE_DUMMY_PROPERTY
};
XPowYIntegerNode* xpow_yinteger_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
XPowYIntegerNode* xpow_yinteger_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* xpow_yinteger_node_real_solve (ParseNode* base);
gint64 number_to_integer (Number* self);
GType not_node_get_type (void) G_GNUC_CONST;
enum  {
	NOT_NODE_DUMMY_PROPERTY
};
NotNode* not_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
NotNode* not_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* not_node_real_solve_r (RNode* base, Number* r);
gboolean mp_is_overflow (Number* x, gint wordlen);
Number* number_not (Number* self, gint wordlen);
GType and_node_get_type (void) G_GNUC_CONST;
enum  {
	AND_NODE_DUMMY_PROPERTY
};
AndNode* and_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AndNode* and_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* and_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_and (Number* self, Number* y);
GType or_node_get_type (void) G_GNUC_CONST;
enum  {
	OR_NODE_DUMMY_PROPERTY
};
OrNode* or_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
OrNode* or_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* or_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_or (Number* self, Number* y);
GType xor_node_get_type (void) G_GNUC_CONST;
enum  {
	XOR_NODE_DUMMY_PROPERTY
};
XorNode* xor_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
XorNode* xor_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* xor_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_xor (Number* self, Number* y);
GType convert_node_get_type (void) G_GNUC_CONST;
enum  {
	CONVERT_NODE_DUMMY_PROPERTY
};
ConvertNode* convert_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
ConvertNode* convert_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* convert_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* parser_convert (Parser* self, Number* x, const gchar* x_units, const gchar* z_units);
GType convert_base_node_get_type (void) G_GNUC_CONST;
enum  {
	CONVERT_BASE_NODE_DUMMY_PROPERTY
};
ConvertBaseNode* convert_base_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value);
ConvertBaseNode* convert_base_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value);
static Number* convert_base_node_real_solve (ParseNode* base);
void parser_set_representation_base (Parser* self, guint new_base);
GType convert_number_node_get_type (void) G_GNUC_CONST;
enum  {
	CONVERT_NUMBER_NODE_DUMMY_PROPERTY
};
ConvertNumberNode* convert_number_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
ConvertNumberNode* convert_number_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* convert_number_node_real_solve (ParseNode* base);
GType lexer_get_type (void) G_GNUC_CONST;
#define PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PARSER, ParserPrivate))
enum  {
	PARSER_DUMMY_PROPERTY
};
Parser* parser_new (const gchar* input, gint number_base, gint wordlen, AngleUnit angle_units);
Parser* parser_construct (GType object_type, const gchar* input, gint number_base, gint wordlen, AngleUnit angle_units);
Lexer* lexer_new (const gchar* input, Parser* parser, gint number_base);
Lexer* lexer_construct (GType object_type, const gchar* input, Parser* parser, gint number_base);
gboolean parser_create_parse_tree (Parser* self, guint* representation_base, ErrorCode* error_code, gchar** error_token, guint* error_start, guint* error_end);
void lexer_scan (Lexer* self);
static gboolean parser_statement (Parser* self);
LexerToken* lexer_get_next_token (Lexer* self);
gboolean parser_variable_is_defined (Parser* self, const gchar* name);
static gboolean parser_real_variable_is_defined (Parser* self, const gchar* name);
static Number* parser_real_get_variable (Parser* self, const gchar* name);
static void parser_real_set_variable (Parser* self, const gchar* name, Number* x);
gboolean parser_function_is_defined (Parser* self, const gchar* name);
static gboolean parser_real_function_is_defined (Parser* self, const gchar* name);
static Number* parser_real_convert (Parser* self, Number* x, const gchar* x_units, const gchar* z_units);
static Precedence parser_get_precedence (Parser* self, LexerTokenType type);
static Associativity parser_get_associativity_p (Parser* self, Precedence type);
static Associativity parser_get_associativity (Parser* self, LexerToken* token);
static guint parser_make_precedence_p (Parser* self, Precedence p);
static guint parser_make_precedence_t (Parser* self, LexerTokenType type);
static gboolean parser_cmp_nodes (Parser* self, ParseNode* left, ParseNode* right);
static void parser_insert_into_tree_all (Parser* self, ParseNode* node, gboolean unary_function);
static void parser_insert_into_tree (Parser* self, ParseNode* node);
static void parser_insert_into_tree_unary (Parser* self, ParseNode* node);
static void parser_destroy_all_nodes (Parser* self, ParseNode* node);
static gboolean parser_check_variable (Parser* self, const gchar* name);
static gboolean parser_expression (Parser* self);
static gboolean parser_check_base (Parser* self);
void lexer_roll_back (Lexer* self);
static gboolean parser_unit (Parser* self);
static gboolean parser_function_definition (Parser* self);
static gboolean parser_expression_1 (Parser* self);
static gboolean parser_expression_2 (Parser* self);
static gboolean parser_variable (Parser* self);
static gboolean parser_function_invocation (Parser* self);
gint sub_atoi (const gchar* data);
static gboolean parser_term (Parser* self);
static gboolean parser_term_2 (Parser* self);
static void parser_finalize (Parser* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GType associativity_get_type (void) {
	static volatile gsize associativity_type_id__volatile = 0;
	if (g_once_init_enter (&associativity_type_id__volatile)) {
		static const GEnumValue values[] = {{ASSOCIATIVITY_LEFT, "ASSOCIATIVITY_LEFT", "left"}, {ASSOCIATIVITY_RIGHT, "ASSOCIATIVITY_RIGHT", "right"}, {0, NULL, NULL}};
		GType associativity_type_id;
		associativity_type_id = g_enum_register_static ("Associativity", values);
		g_once_init_leave (&associativity_type_id__volatile, associativity_type_id);
	}
	return associativity_type_id__volatile;
}


GType precedence_get_type (void) {
	static volatile gsize precedence_type_id__volatile = 0;
	if (g_once_init_enter (&precedence_type_id__volatile)) {
		static const GEnumValue values[] = {{PRECEDENCE_UNKNOWN, "PRECEDENCE_UNKNOWN", "unknown"}, {PRECEDENCE_ADD_SUBTRACT, "PRECEDENCE_ADD_SUBTRACT", "add-subtract"}, {PRECEDENCE_MULTIPLY, "PRECEDENCE_MULTIPLY", "multiply"}, {PRECEDENCE_MOD, "PRECEDENCE_MOD", "mod"}, {PRECEDENCE_DIVIDE, "PRECEDENCE_DIVIDE", "divide"}, {PRECEDENCE_NOT, "PRECEDENCE_NOT", "not"}, {PRECEDENCE_ROOT, "PRECEDENCE_ROOT", "root"}, {PRECEDENCE_FUNCTION, "PRECEDENCE_FUNCTION", "function"}, {PRECEDENCE_BOOLEAN, "PRECEDENCE_BOOLEAN", "boolean"}, {PRECEDENCE_PERCENTAGE, "PRECEDENCE_PERCENTAGE", "percentage"}, {PRECEDENCE_UNARY_MINUS, "PRECEDENCE_UNARY_MINUS", "unary-minus"}, {PRECEDENCE_POWER, "PRECEDENCE_POWER", "power"}, {PRECEDENCE_FACTORIAL, "PRECEDENCE_FACTORIAL", "factorial"}, {PRECEDENCE_NUMBER_VARIABLE, "PRECEDENCE_NUMBER_VARIABLE", "number-variable"}, {PRECEDENCE_DEPTH, "PRECEDENCE_DEPTH", "depth"}, {0, NULL, NULL}};
		GType precedence_type_id;
		precedence_type_id = g_enum_register_static ("Precedence", values);
		g_once_init_leave (&precedence_type_id__volatile, precedence_type_id);
	}
	return precedence_type_id__volatile;
}


static gpointer _parser_ref0 (gpointer self) {
	return self ? parser_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


ParseNode* parse_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value) {
	ParseNode * self = NULL;
	Parser* _tmp0_ = NULL;
	Parser* _tmp1_ = NULL;
	LexerToken* _tmp2_ = NULL;
	LexerToken* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	Associativity _tmp5_ = 0;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	g_return_val_if_fail (parser != NULL, NULL);
	self = (ParseNode*) g_object_new (object_type, NULL);
	_tmp0_ = parser;
	_tmp1_ = _parser_ref0 (_tmp0_);
	_parser_unref0 (self->parser);
	self->parser = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->token);
	self->token = _tmp3_;
	_tmp4_ = precedence;
	self->precedence = _tmp4_;
	_tmp5_ = associativity;
	self->associativity = _tmp5_;
	_tmp6_ = value;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (self->value);
	self->value = _tmp7_;
	return self;
}


ParseNode* parse_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value) {
	return parse_node_construct (TYPE_PARSE_NODE, parser, token, precedence, associativity, value);
}


static Number* parse_node_real_solve (ParseNode* self) {
	Number* result = NULL;
	result = NULL;
	return result;
}


Number* parse_node_solve (ParseNode* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return PARSE_NODE_GET_CLASS (self)->solve (self);
}


static void parse_node_class_init (ParseNodeClass * klass) {
	parse_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = parse_node_real_solve;
	G_OBJECT_CLASS (klass)->finalize = parse_node_finalize;
}


static void parse_node_instance_init (ParseNode * self) {
	self->parent = NULL;
	self->left = NULL;
	self->right = NULL;
}


static void parse_node_finalize (GObject* obj) {
	ParseNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PARSE_NODE, ParseNode);
	_parser_unref0 (self->parser);
	_g_object_unref0 (self->parent);
	_g_object_unref0 (self->left);
	_g_object_unref0 (self->right);
	_g_object_unref0 (self->token);
	_g_free0 (self->value);
	G_OBJECT_CLASS (parse_node_parent_class)->finalize (obj);
}


GType parse_node_get_type (void) {
	static volatile gsize parse_node_type_id__volatile = 0;
	if (g_once_init_enter (&parse_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ParseNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) parse_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ParseNode), 0, (GInstanceInitFunc) parse_node_instance_init, NULL };
		GType parse_node_type_id;
		parse_node_type_id = g_type_register_static (G_TYPE_OBJECT, "ParseNode", &g_define_type_info, 0);
		g_once_init_leave (&parse_node_type_id__volatile, parse_node_type_id);
	}
	return parse_node_type_id__volatile;
}


RNode* rnode_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	RNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (RNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


static Number* rnode_real_solve (ParseNode* base) {
	RNode * self;
	Number* result = NULL;
	Number* r = NULL;
	ParseNode* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	Number* z = NULL;
	Number* _tmp3_ = NULL;
	Number* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	self = (RNode*) base;
	_tmp0_ = ((ParseNode*) self)->right;
	_tmp1_ = parse_node_solve (_tmp0_);
	r = _tmp1_;
	_tmp2_ = r;
	if (_tmp2_ == NULL) {
		result = NULL;
		_g_object_unref0 (r);
		return result;
	}
	_tmp3_ = r;
	_tmp4_ = rnode_solve_r (self, _tmp3_);
	z = _tmp4_;
	number_check_flags ();
	_tmp5_ = number_get_error ();
	_tmp6_ = _tmp5_;
	if (_tmp6_ != NULL) {
		ParseNode* tmpleft = NULL;
		ParseNode* _tmp7_ = NULL;
		ParseNode* _tmp8_ = NULL;
		ParseNode* tmpright = NULL;
		ParseNode* _tmp9_ = NULL;
		ParseNode* _tmp10_ = NULL;
		Parser* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		ParseNode* _tmp24_ = NULL;
		LexerToken* _tmp25_ = NULL;
		guint _tmp26_ = 0U;
		ParseNode* _tmp27_ = NULL;
		LexerToken* _tmp28_ = NULL;
		guint _tmp29_ = 0U;
		const gchar* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		_tmp7_ = ((ParseNode*) self)->right;
		_tmp8_ = _g_object_ref0 (_tmp7_);
		tmpleft = _tmp8_;
		_tmp9_ = ((ParseNode*) self)->right;
		_tmp10_ = _g_object_ref0 (_tmp9_);
		tmpright = _tmp10_;
		while (TRUE) {
			ParseNode* _tmp11_ = NULL;
			ParseNode* _tmp12_ = NULL;
			ParseNode* _tmp13_ = NULL;
			ParseNode* _tmp14_ = NULL;
			ParseNode* _tmp15_ = NULL;
			_tmp11_ = tmpleft;
			_tmp12_ = _tmp11_->left;
			if (!(_tmp12_ != NULL)) {
				break;
			}
			_tmp13_ = tmpleft;
			_tmp14_ = _tmp13_->left;
			_tmp15_ = _g_object_ref0 (_tmp14_);
			_g_object_unref0 (tmpleft);
			tmpleft = _tmp15_;
		}
		while (TRUE) {
			ParseNode* _tmp16_ = NULL;
			ParseNode* _tmp17_ = NULL;
			ParseNode* _tmp18_ = NULL;
			ParseNode* _tmp19_ = NULL;
			ParseNode* _tmp20_ = NULL;
			_tmp16_ = tmpright;
			_tmp17_ = _tmp16_->right;
			if (!(_tmp17_ != NULL)) {
				break;
			}
			_tmp18_ = tmpright;
			_tmp19_ = _tmp18_->right;
			_tmp20_ = _g_object_ref0 (_tmp19_);
			_g_object_unref0 (tmpright);
			tmpright = _tmp20_;
		}
		_tmp21_ = ((ParseNode*) self)->parser;
		_tmp22_ = number_get_error ();
		_tmp23_ = _tmp22_;
		_tmp24_ = tmpleft;
		_tmp25_ = _tmp24_->token;
		_tmp26_ = _tmp25_->start_index;
		_tmp27_ = tmpright;
		_tmp28_ = _tmp27_->token;
		_tmp29_ = _tmp28_->end_index;
		parser_set_error (_tmp21_, ERROR_CODE_MP, _tmp23_, _tmp26_, _tmp29_);
		_tmp30_ = number_get_error ();
		_tmp31_ = _tmp30_;
		number_set_error (NULL);
		_g_object_unref0 (tmpright);
		_g_object_unref0 (tmpleft);
	}
	result = z;
	_g_object_unref0 (r);
	return result;
}


static Number* rnode_real_solve_r (RNode* self, Number* r) {
	g_critical ("Type `%s' does not implement abstract method `rnode_solve_r'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


Number* rnode_solve_r (RNode* self, Number* r) {
	g_return_val_if_fail (self != NULL, NULL);
	return RNODE_GET_CLASS (self)->solve_r (self, r);
}


static void rnode_class_init (RNodeClass * klass) {
	rnode_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = rnode_real_solve;
	((RNodeClass *) klass)->solve_r = rnode_real_solve_r;
}


static void rnode_instance_init (RNode * self) {
}


GType rnode_get_type (void) {
	static volatile gsize rnode_type_id__volatile = 0;
	if (g_once_init_enter (&rnode_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rnode_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RNode), 0, (GInstanceInitFunc) rnode_instance_init, NULL };
		GType rnode_type_id;
		rnode_type_id = g_type_register_static (TYPE_PARSE_NODE, "RNode", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&rnode_type_id__volatile, rnode_type_id);
	}
	return rnode_type_id__volatile;
}


LRNode* lr_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	LRNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (LRNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


static Number* lr_node_real_solve (ParseNode* base) {
	LRNode * self;
	Number* result = NULL;
	Number* l = NULL;
	ParseNode* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* r = NULL;
	ParseNode* _tmp2_ = NULL;
	Number* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	Number* _tmp5_ = NULL;
	Number* z = NULL;
	Number* _tmp7_ = NULL;
	Number* _tmp8_ = NULL;
	Number* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	self = (LRNode*) base;
	_tmp0_ = ((ParseNode*) self)->left;
	_tmp1_ = parse_node_solve (_tmp0_);
	l = _tmp1_;
	_tmp2_ = ((ParseNode*) self)->right;
	_tmp3_ = parse_node_solve (_tmp2_);
	r = _tmp3_;
	_tmp5_ = l;
	if (_tmp5_ == NULL) {
		_tmp4_ = TRUE;
	} else {
		Number* _tmp6_ = NULL;
		_tmp6_ = r;
		_tmp4_ = _tmp6_ == NULL;
	}
	if (_tmp4_) {
		result = NULL;
		_g_object_unref0 (r);
		_g_object_unref0 (l);
		return result;
	}
	_tmp7_ = l;
	_tmp8_ = r;
	_tmp9_ = lr_node_solve_lr (self, _tmp7_, _tmp8_);
	z = _tmp9_;
	number_check_flags ();
	_tmp10_ = number_get_error ();
	_tmp11_ = _tmp10_;
	if (_tmp11_ != NULL) {
		ParseNode* tmpleft = NULL;
		ParseNode* _tmp12_ = NULL;
		ParseNode* _tmp13_ = NULL;
		ParseNode* tmpright = NULL;
		ParseNode* _tmp14_ = NULL;
		ParseNode* _tmp15_ = NULL;
		Parser* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		ParseNode* _tmp29_ = NULL;
		LexerToken* _tmp30_ = NULL;
		guint _tmp31_ = 0U;
		ParseNode* _tmp32_ = NULL;
		LexerToken* _tmp33_ = NULL;
		guint _tmp34_ = 0U;
		const gchar* _tmp35_ = NULL;
		const gchar* _tmp36_ = NULL;
		_tmp12_ = ((ParseNode*) self)->left;
		_tmp13_ = _g_object_ref0 (_tmp12_);
		tmpleft = _tmp13_;
		_tmp14_ = ((ParseNode*) self)->right;
		_tmp15_ = _g_object_ref0 (_tmp14_);
		tmpright = _tmp15_;
		while (TRUE) {
			ParseNode* _tmp16_ = NULL;
			ParseNode* _tmp17_ = NULL;
			ParseNode* _tmp18_ = NULL;
			ParseNode* _tmp19_ = NULL;
			ParseNode* _tmp20_ = NULL;
			_tmp16_ = tmpleft;
			_tmp17_ = _tmp16_->left;
			if (!(_tmp17_ != NULL)) {
				break;
			}
			_tmp18_ = tmpleft;
			_tmp19_ = _tmp18_->left;
			_tmp20_ = _g_object_ref0 (_tmp19_);
			_g_object_unref0 (tmpleft);
			tmpleft = _tmp20_;
		}
		while (TRUE) {
			ParseNode* _tmp21_ = NULL;
			ParseNode* _tmp22_ = NULL;
			ParseNode* _tmp23_ = NULL;
			ParseNode* _tmp24_ = NULL;
			ParseNode* _tmp25_ = NULL;
			_tmp21_ = tmpright;
			_tmp22_ = _tmp21_->right;
			if (!(_tmp22_ != NULL)) {
				break;
			}
			_tmp23_ = tmpright;
			_tmp24_ = _tmp23_->right;
			_tmp25_ = _g_object_ref0 (_tmp24_);
			_g_object_unref0 (tmpright);
			tmpright = _tmp25_;
		}
		_tmp26_ = ((ParseNode*) self)->parser;
		_tmp27_ = number_get_error ();
		_tmp28_ = _tmp27_;
		_tmp29_ = tmpleft;
		_tmp30_ = _tmp29_->token;
		_tmp31_ = _tmp30_->start_index;
		_tmp32_ = tmpright;
		_tmp33_ = _tmp32_->token;
		_tmp34_ = _tmp33_->end_index;
		parser_set_error (_tmp26_, ERROR_CODE_MP, _tmp28_, _tmp31_, _tmp34_);
		_tmp35_ = number_get_error ();
		_tmp36_ = _tmp35_;
		number_set_error (NULL);
		_g_object_unref0 (tmpright);
		_g_object_unref0 (tmpleft);
	}
	result = z;
	_g_object_unref0 (r);
	_g_object_unref0 (l);
	return result;
}


static Number* lr_node_real_solve_lr (LRNode* self, Number* left, Number* r) {
	g_critical ("Type `%s' does not implement abstract method `lr_node_solve_lr'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


Number* lr_node_solve_lr (LRNode* self, Number* left, Number* r) {
	g_return_val_if_fail (self != NULL, NULL);
	return LR_NODE_GET_CLASS (self)->solve_lr (self, left, r);
}


static void lr_node_class_init (LRNodeClass * klass) {
	lr_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = lr_node_real_solve;
	((LRNodeClass *) klass)->solve_lr = lr_node_real_solve_lr;
}


static void lr_node_instance_init (LRNode * self) {
}


GType lr_node_get_type (void) {
	static volatile gsize lr_node_type_id__volatile = 0;
	if (g_once_init_enter (&lr_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LRNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) lr_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LRNode), 0, (GInstanceInitFunc) lr_node_instance_init, NULL };
		GType lr_node_type_id;
		lr_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "LRNode", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&lr_node_type_id__volatile, lr_node_type_id);
	}
	return lr_node_type_id__volatile;
}


ConstantNode* constant_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	ConstantNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (ConstantNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


ConstantNode* constant_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return constant_node_construct (TYPE_CONSTANT_NODE, parser, token, precedence, associativity);
}


static Number* constant_node_real_solve (ParseNode* base) {
	ConstantNode * self;
	Number* result = NULL;
	LexerToken* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	Parser* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	Number* _tmp4_ = NULL;
	self = (ConstantNode*) base;
	_tmp0_ = ((ParseNode*) self)->token;
	_tmp1_ = _tmp0_->text;
	_tmp2_ = ((ParseNode*) self)->parser;
	_tmp3_ = _tmp2_->number_base;
	_tmp4_ = mp_set_from_string (_tmp1_, _tmp3_);
	result = _tmp4_;
	return result;
}


static void constant_node_class_init (ConstantNodeClass * klass) {
	constant_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = constant_node_real_solve;
}


static void constant_node_instance_init (ConstantNode * self) {
}


GType constant_node_get_type (void) {
	static volatile gsize constant_node_type_id__volatile = 0;
	if (g_once_init_enter (&constant_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConstantNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) constant_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConstantNode), 0, (GInstanceInitFunc) constant_node_instance_init, NULL };
		GType constant_node_type_id;
		constant_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "ConstantNode", &g_define_type_info, 0);
		g_once_init_leave (&constant_node_type_id__volatile, constant_node_type_id);
	}
	return constant_node_type_id__volatile;
}


AssignNode* assign_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AssignNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AssignNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


AssignNode* assign_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return assign_node_construct (TYPE_ASSIGN_NODE, parser, token, precedence, associativity);
}


static Number* assign_node_real_solve_r (RNode* base, Number* r) {
	AssignNode * self;
	Number* result = NULL;
	Parser* _tmp0_ = NULL;
	ParseNode* _tmp1_ = NULL;
	LexerToken* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	Number* _tmp4_ = NULL;
	Number* _tmp5_ = NULL;
	Number* _tmp6_ = NULL;
	self = (AssignNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = ((ParseNode*) self)->parser;
	_tmp1_ = ((ParseNode*) self)->left;
	_tmp2_ = _tmp1_->token;
	_tmp3_ = _tmp2_->text;
	_tmp4_ = r;
	parser_set_variable (_tmp0_, _tmp3_, _tmp4_);
	_tmp5_ = r;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	result = _tmp6_;
	return result;
}


static void assign_node_class_init (AssignNodeClass * klass) {
	assign_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = assign_node_real_solve_r;
}


static void assign_node_instance_init (AssignNode * self) {
}


GType assign_node_get_type (void) {
	static volatile gsize assign_node_type_id__volatile = 0;
	if (g_once_init_enter (&assign_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AssignNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) assign_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AssignNode), 0, (GInstanceInitFunc) assign_node_instance_init, NULL };
		GType assign_node_type_id;
		assign_node_type_id = g_type_register_static (TYPE_RNODE, "AssignNode", &g_define_type_info, 0);
		g_once_init_leave (&assign_node_type_id__volatile, assign_node_type_id);
	}
	return assign_node_type_id__volatile;
}


AssignFunctionNode* assign_function_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AssignFunctionNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AssignFunctionNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


AssignFunctionNode* assign_function_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return assign_function_node_construct (TYPE_ASSIGN_FUNCTION_NODE, parser, token, precedence, associativity);
}


static Number* assign_function_node_real_solve (ParseNode* base) {
	AssignFunctionNode * self;
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	ParseNode* _tmp3_ = NULL;
	gchar* function_name = NULL;
	ParseNode* _tmp9_ = NULL;
	ParseNode* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* arguments = NULL;
	ParseNode* _tmp13_ = NULL;
	ParseNode* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* description = NULL;
	ParseNode* _tmp17_ = NULL;
	const gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	FunctionManager* function_manager = NULL;
	FunctionManager* _tmp20_ = NULL;
	FunctionManager* _tmp21_ = NULL;
	const gchar* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	Parser* _tmp25_ = NULL;
	gboolean _tmp26_ = FALSE;
	self = (AssignFunctionNode*) base;
	_tmp3_ = ((ParseNode*) self)->left;
	if (_tmp3_ == NULL) {
		_tmp2_ = TRUE;
	} else {
		ParseNode* _tmp4_ = NULL;
		_tmp4_ = ((ParseNode*) self)->right;
		_tmp2_ = _tmp4_ == NULL;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		ParseNode* _tmp5_ = NULL;
		ParseNode* _tmp6_ = NULL;
		_tmp5_ = ((ParseNode*) self)->left;
		_tmp6_ = _tmp5_->left;
		_tmp1_ = _tmp6_ == NULL;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		ParseNode* _tmp7_ = NULL;
		ParseNode* _tmp8_ = NULL;
		_tmp7_ = ((ParseNode*) self)->left;
		_tmp8_ = _tmp7_->right;
		_tmp0_ = _tmp8_ == NULL;
	}
	if (_tmp0_) {
		result = NULL;
		return result;
	}
	_tmp9_ = ((ParseNode*) self)->left;
	_tmp10_ = _tmp9_->left;
	_tmp11_ = _tmp10_->value;
	_tmp12_ = g_strdup (_tmp11_);
	function_name = _tmp12_;
	_tmp13_ = ((ParseNode*) self)->left;
	_tmp14_ = _tmp13_->right;
	_tmp15_ = _tmp14_->value;
	_tmp16_ = g_strdup (_tmp15_);
	arguments = _tmp16_;
	_tmp17_ = ((ParseNode*) self)->right;
	_tmp18_ = _tmp17_->value;
	_tmp19_ = g_strdup (_tmp18_);
	description = _tmp19_;
	_tmp20_ = function_manager_get_default_function_manager ();
	function_manager = _tmp20_;
	_tmp21_ = function_manager;
	_tmp22_ = function_name;
	_tmp23_ = arguments;
	_tmp24_ = description;
	_tmp25_ = ((ParseNode*) self)->parser;
	_tmp26_ = function_manager_add_function_with_properties (_tmp21_, _tmp22_, _tmp23_, _tmp24_, _tmp25_);
	if (_tmp26_) {
		Number* _tmp27_ = NULL;
		_tmp27_ = number_new_integer ((gint64) 0);
		result = _tmp27_;
		_g_object_unref0 (function_manager);
		_g_free0 (description);
		_g_free0 (arguments);
		_g_free0 (function_name);
		return result;
	}
	result = NULL;
	_g_object_unref0 (function_manager);
	_g_free0 (description);
	_g_free0 (arguments);
	_g_free0 (function_name);
	return result;
}


static void assign_function_node_class_init (AssignFunctionNodeClass * klass) {
	assign_function_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = assign_function_node_real_solve;
}


static void assign_function_node_instance_init (AssignFunctionNode * self) {
}


GType assign_function_node_get_type (void) {
	static volatile gsize assign_function_node_type_id__volatile = 0;
	if (g_once_init_enter (&assign_function_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AssignFunctionNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) assign_function_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AssignFunctionNode), 0, (GInstanceInitFunc) assign_function_node_instance_init, NULL };
		GType assign_function_node_type_id;
		assign_function_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "AssignFunctionNode", &g_define_type_info, 0);
		g_once_init_leave (&assign_function_node_type_id__volatile, assign_function_node_type_id);
	}
	return assign_function_node_type_id__volatile;
}


NameNode* name_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	NameNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = text;
	self = (NameNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


NameNode* name_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	return name_node_construct (TYPE_NAME_NODE, parser, token, precedence, associativity, text);
}


static void name_node_class_init (NameNodeClass * klass) {
	name_node_parent_class = g_type_class_peek_parent (klass);
}


static void name_node_instance_init (NameNode * self) {
}


GType name_node_get_type (void) {
	static volatile gsize name_node_type_id__volatile = 0;
	if (g_once_init_enter (&name_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NameNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) name_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NameNode), 0, (GInstanceInitFunc) name_node_instance_init, NULL };
		GType name_node_type_id;
		name_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "NameNode", &g_define_type_info, 0);
		g_once_init_leave (&name_node_type_id__volatile, name_node_type_id);
	}
	return name_node_type_id__volatile;
}


VariableNode* variable_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	VariableNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (VariableNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


VariableNode* variable_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return variable_node_construct (TYPE_VARIABLE_NODE, parser, token, precedence, associativity);
}


static gboolean string_get_next_char (const gchar* self, gint* index, gunichar* c) {
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	gunichar _tmp1_ = 0U;
	gunichar _tmp2_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = *index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	_vala_c = _tmp1_;
	_tmp2_ = _vala_c;
	if (_tmp2_ != ((gunichar) 0)) {
		gint _tmp3_ = 0;
		gchar* _tmp4_ = NULL;
		_tmp3_ = *index;
		_tmp4_ = g_utf8_next_char (((gchar*) self) + _tmp3_);
		*index = (gint) (_tmp4_ - ((gchar*) self));
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


static gchar* g_unichar_to_string (gunichar self) {
	gchar* result = NULL;
	gchar* str = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	_tmp0_ = g_new0 (gchar, 7);
	str = (gchar*) _tmp0_;
	_tmp1_ = str;
	g_unichar_to_utf8 (self, _tmp1_);
	result = str;
	return result;
}


static Number* variable_node_real_solve (ParseNode* base) {
	VariableNode * self;
	Number* result = NULL;
	Number* ans = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	Number* _tmp3_ = NULL;
	Number* _tmp4_ = NULL;
	Number* value = NULL;
	Number* _tmp5_ = NULL;
	gint index = 0;
	gunichar c = 0U;
	self = (VariableNode*) base;
	_tmp0_ = ((ParseNode*) self)->parser;
	_tmp1_ = ((ParseNode*) self)->token;
	_tmp2_ = _tmp1_->text;
	_tmp3_ = parser_get_variable (_tmp0_, _tmp2_);
	ans = _tmp3_;
	_tmp4_ = ans;
	if (_tmp4_ != NULL) {
		result = ans;
		return result;
	}
	_tmp5_ = number_new_integer ((gint64) 1);
	value = _tmp5_;
	index = 0;
	while (TRUE) {
		LexerToken* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gunichar _tmp8_ = 0U;
		gboolean _tmp9_ = FALSE;
		Number* t = NULL;
		Parser* _tmp10_ = NULL;
		gunichar _tmp11_ = 0U;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		Number* _tmp14_ = NULL;
		Number* _tmp15_ = NULL;
		Number* _tmp16_ = NULL;
		Number* _tmp24_ = NULL;
		Number* _tmp25_ = NULL;
		Number* _tmp26_ = NULL;
		_tmp6_ = ((ParseNode*) self)->token;
		_tmp7_ = _tmp6_->text;
		_tmp9_ = string_get_next_char (_tmp7_, &index, &_tmp8_);
		c = _tmp8_;
		if (!_tmp9_) {
			break;
		}
		_tmp10_ = ((ParseNode*) self)->parser;
		_tmp11_ = c;
		_tmp12_ = g_unichar_to_string (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = parser_get_variable (_tmp10_, _tmp13_);
		_tmp15_ = _tmp14_;
		_g_free0 (_tmp13_);
		t = _tmp15_;
		_tmp16_ = t;
		if (_tmp16_ == NULL) {
			Parser* _tmp17_ = NULL;
			LexerToken* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			LexerToken* _tmp20_ = NULL;
			guint _tmp21_ = 0U;
			LexerToken* _tmp22_ = NULL;
			guint _tmp23_ = 0U;
			_tmp17_ = ((ParseNode*) self)->parser;
			_tmp18_ = ((ParseNode*) self)->token;
			_tmp19_ = _tmp18_->text;
			_tmp20_ = ((ParseNode*) self)->token;
			_tmp21_ = _tmp20_->start_index;
			_tmp22_ = ((ParseNode*) self)->token;
			_tmp23_ = _tmp22_->end_index;
			parser_set_error (_tmp17_, ERROR_CODE_UNKNOWN_VARIABLE, _tmp19_, _tmp21_, _tmp23_);
			result = NULL;
			_g_object_unref0 (t);
			_g_object_unref0 (value);
			_g_object_unref0 (ans);
			return result;
		}
		_tmp24_ = value;
		_tmp25_ = t;
		_tmp26_ = number_multiply (_tmp24_, _tmp25_);
		_g_object_unref0 (value);
		value = _tmp26_;
		_g_object_unref0 (t);
	}
	result = value;
	_g_object_unref0 (ans);
	return result;
}


static void variable_node_class_init (VariableNodeClass * klass) {
	variable_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = variable_node_real_solve;
}


static void variable_node_instance_init (VariableNode * self) {
}


GType variable_node_get_type (void) {
	static volatile gsize variable_node_type_id__volatile = 0;
	if (g_once_init_enter (&variable_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (VariableNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) variable_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (VariableNode), 0, (GInstanceInitFunc) variable_node_instance_init, NULL };
		GType variable_node_type_id;
		variable_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "VariableNode", &g_define_type_info, 0);
		g_once_init_leave (&variable_node_type_id__volatile, variable_node_type_id);
	}
	return variable_node_type_id__volatile;
}


VariableWithPowerNode* variable_with_power_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	VariableWithPowerNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (parser != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = text;
	self = (VariableWithPowerNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


VariableWithPowerNode* variable_with_power_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	return variable_with_power_node_construct (TYPE_VARIABLE_WITH_POWER_NODE, parser, token, precedence, associativity, text);
}


static Number* variable_with_power_node_real_solve (ParseNode* base) {
	VariableWithPowerNode * self;
	Number* result = NULL;
	gint pow = 0;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	Number* ans = NULL;
	Parser* _tmp2_ = NULL;
	LexerToken* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	Number* _tmp5_ = NULL;
	Number* _tmp6_ = NULL;
	Number* value = NULL;
	Number* _tmp10_ = NULL;
	gint index = 0;
	gunichar c = 0U;
	const gchar* _tmp40_ = NULL;
	const gchar* _tmp41_ = NULL;
	self = (VariableWithPowerNode*) base;
	_tmp0_ = ((ParseNode*) self)->value;
	_tmp1_ = super_atoi (_tmp0_);
	pow = _tmp1_;
	_g_free0 (((ParseNode*) self)->value);
	((ParseNode*) self)->value = NULL;
	_tmp2_ = ((ParseNode*) self)->parser;
	_tmp3_ = ((ParseNode*) self)->token;
	_tmp4_ = _tmp3_->text;
	_tmp5_ = parser_get_variable (_tmp2_, _tmp4_);
	ans = _tmp5_;
	_tmp6_ = ans;
	if (_tmp6_ != NULL) {
		Number* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		Number* _tmp9_ = NULL;
		_tmp7_ = ans;
		_tmp8_ = pow;
		_tmp9_ = number_xpowy_integer (_tmp7_, (gint64) _tmp8_);
		result = _tmp9_;
		_g_object_unref0 (ans);
		return result;
	}
	_tmp10_ = number_new_integer ((gint64) 1);
	value = _tmp10_;
	index = 0;
	while (TRUE) {
		LexerToken* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gunichar _tmp13_ = 0U;
		gboolean _tmp14_ = FALSE;
		Number* t = NULL;
		Parser* _tmp15_ = NULL;
		gunichar _tmp16_ = 0U;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		Number* _tmp19_ = NULL;
		Number* _tmp20_ = NULL;
		Number* _tmp21_ = NULL;
		gint i = 0;
		gint _tmp29_ = 0;
		gunichar next = 0U;
		LexerToken* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		gunichar _tmp32_ = 0U;
		gboolean _tmp33_ = FALSE;
		Number* _tmp37_ = NULL;
		Number* _tmp38_ = NULL;
		Number* _tmp39_ = NULL;
		_tmp11_ = ((ParseNode*) self)->token;
		_tmp12_ = _tmp11_->text;
		_tmp14_ = string_get_next_char (_tmp12_, &index, &_tmp13_);
		c = _tmp13_;
		if (!_tmp14_) {
			break;
		}
		_tmp15_ = ((ParseNode*) self)->parser;
		_tmp16_ = c;
		_tmp17_ = g_unichar_to_string (_tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = parser_get_variable (_tmp15_, _tmp18_);
		_tmp20_ = _tmp19_;
		_g_free0 (_tmp18_);
		t = _tmp20_;
		_tmp21_ = t;
		if (_tmp21_ == NULL) {
			Parser* _tmp22_ = NULL;
			LexerToken* _tmp23_ = NULL;
			const gchar* _tmp24_ = NULL;
			LexerToken* _tmp25_ = NULL;
			guint _tmp26_ = 0U;
			LexerToken* _tmp27_ = NULL;
			guint _tmp28_ = 0U;
			_tmp22_ = ((ParseNode*) self)->parser;
			_tmp23_ = ((ParseNode*) self)->token;
			_tmp24_ = _tmp23_->text;
			_tmp25_ = ((ParseNode*) self)->token;
			_tmp26_ = _tmp25_->start_index;
			_tmp27_ = ((ParseNode*) self)->token;
			_tmp28_ = _tmp27_->end_index;
			parser_set_error (_tmp22_, ERROR_CODE_UNKNOWN_VARIABLE, _tmp24_, _tmp26_, _tmp28_);
			result = NULL;
			_g_object_unref0 (t);
			_g_object_unref0 (value);
			_g_object_unref0 (ans);
			return result;
		}
		_tmp29_ = index;
		i = _tmp29_;
		_tmp30_ = ((ParseNode*) self)->token;
		_tmp31_ = _tmp30_->text;
		_tmp33_ = string_get_next_char (_tmp31_, &i, &_tmp32_);
		next = _tmp32_;
		if (!_tmp33_) {
			Number* _tmp34_ = NULL;
			gint _tmp35_ = 0;
			Number* _tmp36_ = NULL;
			_tmp34_ = t;
			_tmp35_ = pow;
			_tmp36_ = number_xpowy_integer (_tmp34_, (gint64) _tmp35_);
			_g_object_unref0 (t);
			t = _tmp36_;
		}
		_tmp37_ = value;
		_tmp38_ = t;
		_tmp39_ = number_multiply (_tmp37_, _tmp38_);
		_g_object_unref0 (value);
		value = _tmp39_;
		_g_object_unref0 (t);
	}
	number_check_flags ();
	_tmp40_ = number_get_error ();
	_tmp41_ = _tmp40_;
	if (_tmp41_ != NULL) {
		ParseNode* tmpleft = NULL;
		ParseNode* _tmp42_ = NULL;
		ParseNode* _tmp43_ = NULL;
		ParseNode* tmpright = NULL;
		ParseNode* _tmp44_ = NULL;
		ParseNode* _tmp45_ = NULL;
		Parser* _tmp56_ = NULL;
		const gchar* _tmp57_ = NULL;
		const gchar* _tmp58_ = NULL;
		ParseNode* _tmp59_ = NULL;
		LexerToken* _tmp60_ = NULL;
		guint _tmp61_ = 0U;
		ParseNode* _tmp62_ = NULL;
		LexerToken* _tmp63_ = NULL;
		guint _tmp64_ = 0U;
		const gchar* _tmp65_ = NULL;
		const gchar* _tmp66_ = NULL;
		_tmp42_ = ((ParseNode*) self)->left;
		_tmp43_ = _g_object_ref0 (_tmp42_);
		tmpleft = _tmp43_;
		_tmp44_ = ((ParseNode*) self)->right;
		_tmp45_ = _g_object_ref0 (_tmp44_);
		tmpright = _tmp45_;
		while (TRUE) {
			ParseNode* _tmp46_ = NULL;
			ParseNode* _tmp47_ = NULL;
			ParseNode* _tmp48_ = NULL;
			ParseNode* _tmp49_ = NULL;
			ParseNode* _tmp50_ = NULL;
			_tmp46_ = tmpleft;
			_tmp47_ = _tmp46_->left;
			if (!(_tmp47_ != NULL)) {
				break;
			}
			_tmp48_ = tmpleft;
			_tmp49_ = _tmp48_->left;
			_tmp50_ = _g_object_ref0 (_tmp49_);
			_g_object_unref0 (tmpleft);
			tmpleft = _tmp50_;
		}
		while (TRUE) {
			ParseNode* _tmp51_ = NULL;
			ParseNode* _tmp52_ = NULL;
			ParseNode* _tmp53_ = NULL;
			ParseNode* _tmp54_ = NULL;
			ParseNode* _tmp55_ = NULL;
			_tmp51_ = tmpright;
			_tmp52_ = _tmp51_->right;
			if (!(_tmp52_ != NULL)) {
				break;
			}
			_tmp53_ = tmpright;
			_tmp54_ = _tmp53_->right;
			_tmp55_ = _g_object_ref0 (_tmp54_);
			_g_object_unref0 (tmpright);
			tmpright = _tmp55_;
		}
		_tmp56_ = ((ParseNode*) self)->parser;
		_tmp57_ = number_get_error ();
		_tmp58_ = _tmp57_;
		_tmp59_ = tmpleft;
		_tmp60_ = _tmp59_->token;
		_tmp61_ = _tmp60_->start_index;
		_tmp62_ = tmpright;
		_tmp63_ = _tmp62_->token;
		_tmp64_ = _tmp63_->end_index;
		parser_set_error (_tmp56_, ERROR_CODE_MP, _tmp58_, _tmp61_, _tmp64_);
		_tmp65_ = number_get_error ();
		_tmp66_ = _tmp65_;
		number_set_error (NULL);
		_g_object_unref0 (tmpright);
		_g_object_unref0 (tmpleft);
	}
	result = value;
	_g_object_unref0 (ans);
	return result;
}


static void variable_with_power_node_class_init (VariableWithPowerNodeClass * klass) {
	variable_with_power_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = variable_with_power_node_real_solve;
}


static void variable_with_power_node_instance_init (VariableWithPowerNode * self) {
}


GType variable_with_power_node_get_type (void) {
	static volatile gsize variable_with_power_node_type_id__volatile = 0;
	if (g_once_init_enter (&variable_with_power_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (VariableWithPowerNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) variable_with_power_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (VariableWithPowerNode), 0, (GInstanceInitFunc) variable_with_power_node_instance_init, NULL };
		GType variable_with_power_node_type_id;
		variable_with_power_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "VariableWithPowerNode", &g_define_type_info, 0);
		g_once_init_leave (&variable_with_power_node_type_id__volatile, variable_with_power_node_type_id);
	}
	return variable_with_power_node_type_id__volatile;
}


FunctionNameNode* function_name_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* name) {
	FunctionNameNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (parser != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = name;
	self = (FunctionNameNode*) name_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


FunctionNameNode* function_name_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* name) {
	return function_name_node_construct (TYPE_FUNCTION_NAME_NODE, parser, token, precedence, associativity, name);
}


static void function_name_node_class_init (FunctionNameNodeClass * klass) {
	function_name_node_parent_class = g_type_class_peek_parent (klass);
}


static void function_name_node_instance_init (FunctionNameNode * self) {
}


GType function_name_node_get_type (void) {
	static volatile gsize function_name_node_type_id__volatile = 0;
	if (g_once_init_enter (&function_name_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionNameNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) function_name_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionNameNode), 0, (GInstanceInitFunc) function_name_node_instance_init, NULL };
		GType function_name_node_type_id;
		function_name_node_type_id = g_type_register_static (TYPE_NAME_NODE, "FunctionNameNode", &g_define_type_info, 0);
		g_once_init_leave (&function_name_node_type_id__volatile, function_name_node_type_id);
	}
	return function_name_node_type_id__volatile;
}


FunctionArgumentsNode* function_arguments_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* arguments) {
	FunctionArgumentsNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (parser != NULL, NULL);
	g_return_val_if_fail (arguments != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = arguments;
	self = (FunctionArgumentsNode*) name_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


FunctionArgumentsNode* function_arguments_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* arguments) {
	return function_arguments_node_construct (TYPE_FUNCTION_ARGUMENTS_NODE, parser, token, precedence, associativity, arguments);
}


static void function_arguments_node_class_init (FunctionArgumentsNodeClass * klass) {
	function_arguments_node_parent_class = g_type_class_peek_parent (klass);
}


static void function_arguments_node_instance_init (FunctionArgumentsNode * self) {
}


GType function_arguments_node_get_type (void) {
	static volatile gsize function_arguments_node_type_id__volatile = 0;
	if (g_once_init_enter (&function_arguments_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionArgumentsNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) function_arguments_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionArgumentsNode), 0, (GInstanceInitFunc) function_arguments_node_instance_init, NULL };
		GType function_arguments_node_type_id;
		function_arguments_node_type_id = g_type_register_static (TYPE_NAME_NODE, "FunctionArgumentsNode", &g_define_type_info, 0);
		g_once_init_leave (&function_arguments_node_type_id__volatile, function_arguments_node_type_id);
	}
	return function_arguments_node_type_id__volatile;
}


FunctionDescriptionNode* function_description_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* description) {
	FunctionDescriptionNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (parser != NULL, NULL);
	g_return_val_if_fail (description != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = description;
	self = (FunctionDescriptionNode*) name_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


FunctionDescriptionNode* function_description_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* description) {
	return function_description_node_construct (TYPE_FUNCTION_DESCRIPTION_NODE, parser, token, precedence, associativity, description);
}


static void function_description_node_class_init (FunctionDescriptionNodeClass * klass) {
	function_description_node_parent_class = g_type_class_peek_parent (klass);
}


static void function_description_node_instance_init (FunctionDescriptionNode * self) {
}


GType function_description_node_get_type (void) {
	static volatile gsize function_description_node_type_id__volatile = 0;
	if (g_once_init_enter (&function_description_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionDescriptionNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) function_description_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionDescriptionNode), 0, (GInstanceInitFunc) function_description_node_instance_init, NULL };
		GType function_description_node_type_id;
		function_description_node_type_id = g_type_register_static (TYPE_NAME_NODE, "FunctionDescriptionNode", &g_define_type_info, 0);
		g_once_init_leave (&function_description_node_type_id__volatile, function_description_node_type_id);
	}
	return function_description_node_type_id__volatile;
}


FunctionNode* function_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	FunctionNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = text;
	self = (FunctionNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


FunctionNode* function_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	return function_node_construct (TYPE_FUNCTION_NODE, parser, token, precedence, associativity, text);
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch3_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) -1, 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch3_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally3;
	__catch3_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static void _vala_array_add1 (Number*** array, int* length, int* size, Number* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (Number*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add2 (Number*** array, int* length, int* size, Number* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (Number*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static Number* function_node_real_solve (ParseNode* base) {
	FunctionNode * self;
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	ParseNode* _tmp1_ = NULL;
	gchar* name = NULL;
	ParseNode* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gint pow = 0;
	const gchar* _tmp9_ = NULL;
	gint _tmp12_ = 0;
	Number** args = NULL;
	Number** _tmp16_ = NULL;
	gint args_length1 = 0;
	gint _args_size_ = 0;
	ParseNode* _tmp17_ = NULL;
	FunctionManager* function_manager = NULL;
	FunctionManager* _tmp78_ = NULL;
	Number* tmp = NULL;
	FunctionManager* _tmp79_ = NULL;
	const gchar* _tmp80_ = NULL;
	Number** _tmp81_ = NULL;
	gint _tmp81__length1 = 0;
	Parser* _tmp82_ = NULL;
	Number* _tmp83_ = NULL;
	Number* _tmp84_ = NULL;
	const gchar* _tmp88_ = NULL;
	const gchar* _tmp89_ = NULL;
	self = (FunctionNode*) base;
	_tmp1_ = ((ParseNode*) self)->right;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		ParseNode* _tmp2_ = NULL;
		_tmp2_ = ((ParseNode*) self)->left;
		_tmp0_ = _tmp2_ == NULL;
	}
	if (_tmp0_) {
		Parser* _tmp3_ = NULL;
		_tmp3_ = ((ParseNode*) self)->parser;
		parser_set_error (_tmp3_, ERROR_CODE_UNKNOWN_FUNCTION, NULL, (guint) 0, (guint) 0);
		result = NULL;
		return result;
	}
	_tmp4_ = ((ParseNode*) self)->left;
	_tmp5_ = _tmp4_->value;
	_tmp6_ = g_strdup (_tmp5_);
	name = _tmp6_;
	_tmp7_ = name;
	if (_tmp7_ == NULL) {
		Parser* _tmp8_ = NULL;
		_tmp8_ = ((ParseNode*) self)->parser;
		parser_set_error (_tmp8_, ERROR_CODE_UNKNOWN_FUNCTION, NULL, (guint) 0, (guint) 0);
		result = NULL;
		_g_free0 (name);
		return result;
	}
	pow = 1;
	_tmp9_ = ((ParseNode*) self)->value;
	if (_tmp9_ != NULL) {
		const gchar* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		_tmp10_ = ((ParseNode*) self)->value;
		_tmp11_ = super_atoi (_tmp10_);
		pow = _tmp11_;
	}
	_tmp12_ = pow;
	if (_tmp12_ < 0) {
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		gint _tmp15_ = 0;
		_tmp13_ = name;
		_tmp14_ = g_strconcat (_tmp13_, "", NULL);
		_g_free0 (name);
		name = _tmp14_;
		_tmp15_ = pow;
		pow = -_tmp15_;
	}
	_tmp16_ = g_new0 (Number*, 0 + 1);
	args = _tmp16_;
	args_length1 = 0;
	_args_size_ = args_length1;
	_tmp17_ = ((ParseNode*) self)->right;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp17_, TYPE_FUNCTION_ARGUMENTS_NODE)) {
		gchar* argument_list = NULL;
		ParseNode* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		gchar* temp = NULL;
		gchar* _tmp21_ = NULL;
		gint depth = 0;
		gchar** arguments = NULL;
		const gchar* _tmp42_ = NULL;
		gchar** _tmp43_ = NULL;
		gchar** _tmp44_ = NULL;
		gint arguments_length1 = 0;
		gint _arguments_size_ = 0;
		gchar** _tmp45_ = NULL;
		gint _tmp45__length1 = 0;
		_tmp18_ = ((ParseNode*) self)->right;
		_tmp19_ = _tmp18_->value;
		_tmp20_ = g_strdup (_tmp19_);
		argument_list = _tmp20_;
		_tmp21_ = g_strdup ("");
		temp = _tmp21_;
		depth = 0;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp22_ = FALSE;
				_tmp22_ = TRUE;
				while (TRUE) {
					gint _tmp24_ = 0;
					const gchar* _tmp25_ = NULL;
					gint _tmp26_ = 0;
					gint _tmp27_ = 0;
					gchar* ss = NULL;
					const gchar* _tmp28_ = NULL;
					gint _tmp29_ = 0;
					gchar* _tmp30_ = NULL;
					const gchar* _tmp31_ = NULL;
					const gchar* _tmp39_ = NULL;
					const gchar* _tmp40_ = NULL;
					gchar* _tmp41_ = NULL;
					if (!_tmp22_) {
						gint _tmp23_ = 0;
						_tmp23_ = i;
						i = _tmp23_ + 1;
					}
					_tmp22_ = FALSE;
					_tmp24_ = i;
					_tmp25_ = argument_list;
					_tmp26_ = strlen (_tmp25_);
					_tmp27_ = _tmp26_;
					if (!(_tmp24_ < _tmp27_)) {
						break;
					}
					_tmp28_ = argument_list;
					_tmp29_ = i;
					_tmp30_ = string_substring (_tmp28_, (glong) _tmp29_, (glong) 1);
					ss = _tmp30_;
					_tmp31_ = ss;
					if (g_strcmp0 (_tmp31_, "(") == 0) {
						gint _tmp32_ = 0;
						_tmp32_ = depth;
						depth = _tmp32_ + 1;
					} else {
						const gchar* _tmp33_ = NULL;
						_tmp33_ = ss;
						if (g_strcmp0 (_tmp33_, ")") == 0) {
							gint _tmp34_ = 0;
							_tmp34_ = depth;
							depth = _tmp34_ - 1;
						} else {
							gboolean _tmp35_ = FALSE;
							const gchar* _tmp36_ = NULL;
							_tmp36_ = ss;
							if (g_strcmp0 (_tmp36_, ";") == 0) {
								gint _tmp37_ = 0;
								_tmp37_ = depth;
								_tmp35_ = _tmp37_ != 0;
							} else {
								_tmp35_ = FALSE;
							}
							if (_tmp35_) {
								gchar* _tmp38_ = NULL;
								_tmp38_ = g_strdup ("$");
								_g_free0 (ss);
								ss = _tmp38_;
							}
						}
					}
					_tmp39_ = temp;
					_tmp40_ = ss;
					_tmp41_ = g_strconcat (_tmp39_, _tmp40_, NULL);
					_g_free0 (temp);
					temp = _tmp41_;
					_g_free0 (ss);
				}
			}
		}
		_tmp42_ = temp;
		_tmp44_ = _tmp43_ = g_strsplit_set (_tmp42_, ";", 0);
		arguments = _tmp44_;
		arguments_length1 = _vala_array_length (_tmp43_);
		_arguments_size_ = arguments_length1;
		_tmp45_ = arguments;
		_tmp45__length1 = arguments_length1;
		{
			gchar** argument_collection = NULL;
			gint argument_collection_length1 = 0;
			gint _argument_collection_size_ = 0;
			gint argument_it = 0;
			argument_collection = _tmp45_;
			argument_collection_length1 = _tmp45__length1;
			for (argument_it = 0; argument_it < _tmp45__length1; argument_it = argument_it + 1) {
				gchar* _tmp46_ = NULL;
				gchar* argument = NULL;
				_tmp46_ = g_strdup (argument_collection[argument_it]);
				argument = _tmp46_;
				{
					const gchar* _tmp47_ = NULL;
					gchar* _tmp48_ = NULL;
					gchar* _tmp49_ = NULL;
					gchar* _tmp50_ = NULL;
					ExpressionParser* argument_parser = NULL;
					const gchar* _tmp51_ = NULL;
					Parser* _tmp52_ = NULL;
					ExpressionParser* _tmp53_ = NULL;
					guint representation_base = 0U;
					ErrorCode error_code = 0;
					gchar* error_token = NULL;
					guint error_start = 0U;
					guint error_end = 0U;
					Number* ans = NULL;
					ExpressionParser* _tmp54_ = NULL;
					guint _tmp55_ = 0U;
					ErrorCode _tmp56_ = 0;
					gchar* _tmp57_ = NULL;
					guint _tmp58_ = 0U;
					guint _tmp59_ = 0U;
					Number* _tmp60_ = NULL;
					gboolean _tmp61_ = FALSE;
					ErrorCode _tmp62_ = 0;
					_tmp47_ = argument;
					_tmp48_ = string_replace (_tmp47_, "$", ";");
					_tmp49_ = _tmp48_;
					_tmp50_ = string_strip (_tmp49_);
					_g_free0 (argument);
					argument = _tmp50_;
					_g_free0 (_tmp49_);
					_tmp51_ = argument;
					_tmp52_ = ((ParseNode*) self)->parser;
					_tmp53_ = expression_parser_new (_tmp51_, _tmp52_);
					argument_parser = _tmp53_;
					_tmp54_ = argument_parser;
					_tmp60_ = parser_parse ((Parser*) _tmp54_, &_tmp55_, &_tmp56_, &_tmp57_, &_tmp58_, &_tmp59_);
					representation_base = _tmp55_;
					error_code = _tmp56_;
					_g_free0 (error_token);
					error_token = _tmp57_;
					error_start = _tmp58_;
					error_end = _tmp59_;
					ans = _tmp60_;
					_tmp62_ = error_code;
					if (_tmp62_ == ERROR_CODE_NONE) {
						Number* _tmp63_ = NULL;
						_tmp63_ = ans;
						_tmp61_ = _tmp63_ != NULL;
					} else {
						_tmp61_ = FALSE;
					}
					if (_tmp61_) {
						Number** _tmp64_ = NULL;
						gint _tmp64__length1 = 0;
						Number* _tmp65_ = NULL;
						Number* _tmp66_ = NULL;
						_tmp64_ = args;
						_tmp64__length1 = args_length1;
						_tmp65_ = ans;
						_tmp66_ = _g_object_ref0 (_tmp65_);
						_vala_array_add1 (&args, &args_length1, &_args_size_, _tmp66_);
					} else {
						Parser* _tmp67_ = NULL;
						const gchar* _tmp68_ = NULL;
						guint _tmp69_ = 0U;
						guint _tmp70_ = 0U;
						_tmp67_ = ((ParseNode*) self)->parser;
						_tmp68_ = error_token;
						_tmp69_ = error_start;
						_tmp70_ = error_end;
						parser_set_error (_tmp67_, ERROR_CODE_UNKNOWN_VARIABLE, _tmp68_, _tmp69_, _tmp70_);
						result = NULL;
						_g_object_unref0 (ans);
						_g_free0 (error_token);
						_parser_unref0 (argument_parser);
						_g_free0 (argument);
						arguments = (_vala_array_free (arguments, arguments_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (temp);
						_g_free0 (argument_list);
						args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_object_unref), NULL);
						_g_free0 (name);
						return result;
					}
					_g_object_unref0 (ans);
					_g_free0 (error_token);
					_parser_unref0 (argument_parser);
					_g_free0 (argument);
				}
			}
		}
		arguments = (_vala_array_free (arguments, arguments_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (temp);
		_g_free0 (argument_list);
	} else {
		Number* ans = NULL;
		ParseNode* _tmp71_ = NULL;
		Number* _tmp72_ = NULL;
		Number* _tmp73_ = NULL;
		_tmp71_ = ((ParseNode*) self)->right;
		_tmp72_ = parse_node_solve (_tmp71_);
		ans = _tmp72_;
		_tmp73_ = ans;
		if (_tmp73_ != NULL) {
			Number** _tmp74_ = NULL;
			gint _tmp74__length1 = 0;
			Number* _tmp75_ = NULL;
			Number* _tmp76_ = NULL;
			_tmp74_ = args;
			_tmp74__length1 = args_length1;
			_tmp75_ = ans;
			_tmp76_ = _g_object_ref0 (_tmp75_);
			_vala_array_add2 (&args, &args_length1, &_args_size_, _tmp76_);
		} else {
			Parser* _tmp77_ = NULL;
			_tmp77_ = ((ParseNode*) self)->parser;
			parser_set_error (_tmp77_, ERROR_CODE_UNKNOWN_FUNCTION, NULL, (guint) 0, (guint) 0);
			result = NULL;
			_g_object_unref0 (ans);
			args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_object_unref), NULL);
			_g_free0 (name);
			return result;
		}
		_g_object_unref0 (ans);
	}
	_tmp78_ = function_manager_get_default_function_manager ();
	function_manager = _tmp78_;
	_tmp79_ = function_manager;
	_tmp80_ = name;
	_tmp81_ = args;
	_tmp81__length1 = args_length1;
	_tmp82_ = ((ParseNode*) self)->parser;
	_tmp83_ = function_manager_evaluate_function (_tmp79_, _tmp80_, _tmp81_, _tmp81__length1, _tmp82_);
	tmp = _tmp83_;
	_tmp84_ = tmp;
	if (_tmp84_ != NULL) {
		Number* _tmp85_ = NULL;
		gint _tmp86_ = 0;
		Number* _tmp87_ = NULL;
		_tmp85_ = tmp;
		_tmp86_ = pow;
		_tmp87_ = number_xpowy_integer (_tmp85_, (gint64) _tmp86_);
		_g_object_unref0 (tmp);
		tmp = _tmp87_;
	}
	number_check_flags ();
	_tmp88_ = number_get_error ();
	_tmp89_ = _tmp88_;
	if (_tmp89_ != NULL) {
		Parser* _tmp90_ = NULL;
		const gchar* _tmp91_ = NULL;
		const gchar* _tmp92_ = NULL;
		const gchar* _tmp93_ = NULL;
		const gchar* _tmp94_ = NULL;
		_tmp90_ = ((ParseNode*) self)->parser;
		_tmp91_ = number_get_error ();
		_tmp92_ = _tmp91_;
		parser_set_error (_tmp90_, ERROR_CODE_MP, _tmp92_, (guint) 0, (guint) 0);
		_tmp93_ = number_get_error ();
		_tmp94_ = _tmp93_;
		number_set_error (NULL);
	}
	result = tmp;
	_g_object_unref0 (function_manager);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_free0 (name);
	return result;
}


static void function_node_class_init (FunctionNodeClass * klass) {
	function_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = function_node_real_solve;
}


static void function_node_instance_init (FunctionNode * self) {
}


GType function_node_get_type (void) {
	static volatile gsize function_node_type_id__volatile = 0;
	if (g_once_init_enter (&function_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) function_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionNode), 0, (GInstanceInitFunc) function_node_instance_init, NULL };
		GType function_node_type_id;
		function_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "FunctionNode", &g_define_type_info, 0);
		g_once_init_leave (&function_node_type_id__volatile, function_node_type_id);
	}
	return function_node_type_id__volatile;
}


UnaryMinusNode* unary_minus_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	UnaryMinusNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (UnaryMinusNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


UnaryMinusNode* unary_minus_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return unary_minus_node_construct (TYPE_UNARY_MINUS_NODE, parser, token, precedence, associativity);
}


static Number* unary_minus_node_real_solve_r (RNode* base, Number* r) {
	UnaryMinusNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	self = (UnaryMinusNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_invert_sign (_tmp0_);
	result = _tmp1_;
	return result;
}


static void unary_minus_node_class_init (UnaryMinusNodeClass * klass) {
	unary_minus_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = unary_minus_node_real_solve_r;
}


static void unary_minus_node_instance_init (UnaryMinusNode * self) {
}


GType unary_minus_node_get_type (void) {
	static volatile gsize unary_minus_node_type_id__volatile = 0;
	if (g_once_init_enter (&unary_minus_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnaryMinusNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unary_minus_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnaryMinusNode), 0, (GInstanceInitFunc) unary_minus_node_instance_init, NULL };
		GType unary_minus_node_type_id;
		unary_minus_node_type_id = g_type_register_static (TYPE_RNODE, "UnaryMinusNode", &g_define_type_info, 0);
		g_once_init_leave (&unary_minus_node_type_id__volatile, unary_minus_node_type_id);
	}
	return unary_minus_node_type_id__volatile;
}


AbsoluteValueNode* absolute_value_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AbsoluteValueNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AbsoluteValueNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


AbsoluteValueNode* absolute_value_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return absolute_value_node_construct (TYPE_ABSOLUTE_VALUE_NODE, parser, token, precedence, associativity);
}


static Number* absolute_value_node_real_solve_r (RNode* base, Number* r) {
	AbsoluteValueNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	self = (AbsoluteValueNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_abs (_tmp0_);
	result = _tmp1_;
	return result;
}


static void absolute_value_node_class_init (AbsoluteValueNodeClass * klass) {
	absolute_value_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = absolute_value_node_real_solve_r;
}


static void absolute_value_node_instance_init (AbsoluteValueNode * self) {
}


GType absolute_value_node_get_type (void) {
	static volatile gsize absolute_value_node_type_id__volatile = 0;
	if (g_once_init_enter (&absolute_value_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AbsoluteValueNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) absolute_value_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AbsoluteValueNode), 0, (GInstanceInitFunc) absolute_value_node_instance_init, NULL };
		GType absolute_value_node_type_id;
		absolute_value_node_type_id = g_type_register_static (TYPE_RNODE, "AbsoluteValueNode", &g_define_type_info, 0);
		g_once_init_leave (&absolute_value_node_type_id__volatile, absolute_value_node_type_id);
	}
	return absolute_value_node_type_id__volatile;
}


FloorNode* floor_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	FloorNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (FloorNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


FloorNode* floor_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return floor_node_construct (TYPE_FLOOR_NODE, parser, token, precedence, associativity);
}


static Number* floor_node_real_solve_r (RNode* base, Number* r) {
	FloorNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	self = (FloorNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_floor (_tmp0_);
	result = _tmp1_;
	return result;
}


static void floor_node_class_init (FloorNodeClass * klass) {
	floor_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = floor_node_real_solve_r;
}


static void floor_node_instance_init (FloorNode * self) {
}


GType floor_node_get_type (void) {
	static volatile gsize floor_node_type_id__volatile = 0;
	if (g_once_init_enter (&floor_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FloorNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) floor_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FloorNode), 0, (GInstanceInitFunc) floor_node_instance_init, NULL };
		GType floor_node_type_id;
		floor_node_type_id = g_type_register_static (TYPE_RNODE, "FloorNode", &g_define_type_info, 0);
		g_once_init_leave (&floor_node_type_id__volatile, floor_node_type_id);
	}
	return floor_node_type_id__volatile;
}


CeilingNode* ceiling_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	CeilingNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (CeilingNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


CeilingNode* ceiling_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return ceiling_node_construct (TYPE_CEILING_NODE, parser, token, precedence, associativity);
}


static Number* ceiling_node_real_solve_r (RNode* base, Number* r) {
	CeilingNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	self = (CeilingNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_ceiling (_tmp0_);
	result = _tmp1_;
	return result;
}


static void ceiling_node_class_init (CeilingNodeClass * klass) {
	ceiling_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = ceiling_node_real_solve_r;
}


static void ceiling_node_instance_init (CeilingNode * self) {
}


GType ceiling_node_get_type (void) {
	static volatile gsize ceiling_node_type_id__volatile = 0;
	if (g_once_init_enter (&ceiling_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CeilingNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ceiling_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CeilingNode), 0, (GInstanceInitFunc) ceiling_node_instance_init, NULL };
		GType ceiling_node_type_id;
		ceiling_node_type_id = g_type_register_static (TYPE_RNODE, "CeilingNode", &g_define_type_info, 0);
		g_once_init_leave (&ceiling_node_type_id__volatile, ceiling_node_type_id);
	}
	return ceiling_node_type_id__volatile;
}


FractionalComponentNode* fractional_component_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	FractionalComponentNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (FractionalComponentNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


FractionalComponentNode* fractional_component_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return fractional_component_node_construct (TYPE_FRACTIONAL_COMPONENT_NODE, parser, token, precedence, associativity);
}


static Number* fractional_component_node_real_solve_r (RNode* base, Number* r) {
	FractionalComponentNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	self = (FractionalComponentNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_fractional_part (_tmp0_);
	result = _tmp1_;
	return result;
}


static void fractional_component_node_class_init (FractionalComponentNodeClass * klass) {
	fractional_component_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = fractional_component_node_real_solve_r;
}


static void fractional_component_node_instance_init (FractionalComponentNode * self) {
}


GType fractional_component_node_get_type (void) {
	static volatile gsize fractional_component_node_type_id__volatile = 0;
	if (g_once_init_enter (&fractional_component_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FractionalComponentNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fractional_component_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FractionalComponentNode), 0, (GInstanceInitFunc) fractional_component_node_instance_init, NULL };
		GType fractional_component_node_type_id;
		fractional_component_node_type_id = g_type_register_static (TYPE_RNODE, "FractionalComponentNode", &g_define_type_info, 0);
		g_once_init_leave (&fractional_component_node_type_id__volatile, fractional_component_node_type_id);
	}
	return fractional_component_node_type_id__volatile;
}


RoundNode* round_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	RoundNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (RoundNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


RoundNode* round_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return round_node_construct (TYPE_ROUND_NODE, parser, token, precedence, associativity);
}


static Number* round_node_real_solve_r (RNode* base, Number* r) {
	RoundNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	self = (RoundNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_round (_tmp0_);
	result = _tmp1_;
	return result;
}


static void round_node_class_init (RoundNodeClass * klass) {
	round_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = round_node_real_solve_r;
}


static void round_node_instance_init (RoundNode * self) {
}


GType round_node_get_type (void) {
	static volatile gsize round_node_type_id__volatile = 0;
	if (g_once_init_enter (&round_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RoundNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) round_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RoundNode), 0, (GInstanceInitFunc) round_node_instance_init, NULL };
		GType round_node_type_id;
		round_node_type_id = g_type_register_static (TYPE_RNODE, "RoundNode", &g_define_type_info, 0);
		g_once_init_leave (&round_node_type_id__volatile, round_node_type_id);
	}
	return round_node_type_id__volatile;
}


PercentNode* percent_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	PercentNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (PercentNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


PercentNode* percent_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return percent_node_construct (TYPE_PERCENT_NODE, parser, token, precedence, associativity);
}


static Number* percent_node_real_solve_r (RNode* base, Number* r) {
	PercentNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	self = (PercentNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_divide_integer (_tmp0_, (gint64) 100);
	result = _tmp1_;
	return result;
}


static void percent_node_class_init (PercentNodeClass * klass) {
	percent_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = percent_node_real_solve_r;
}


static void percent_node_instance_init (PercentNode * self) {
}


GType percent_node_get_type (void) {
	static volatile gsize percent_node_type_id__volatile = 0;
	if (g_once_init_enter (&percent_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PercentNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) percent_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PercentNode), 0, (GInstanceInitFunc) percent_node_instance_init, NULL };
		GType percent_node_type_id;
		percent_node_type_id = g_type_register_static (TYPE_RNODE, "PercentNode", &g_define_type_info, 0);
		g_once_init_leave (&percent_node_type_id__volatile, percent_node_type_id);
	}
	return percent_node_type_id__volatile;
}


FactorialNode* factorial_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	FactorialNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (FactorialNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


FactorialNode* factorial_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return factorial_node_construct (TYPE_FACTORIAL_NODE, parser, token, precedence, associativity);
}


static Number* factorial_node_real_solve_r (RNode* base, Number* r) {
	FactorialNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	self = (FactorialNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_factorial (_tmp0_);
	result = _tmp1_;
	return result;
}


static void factorial_node_class_init (FactorialNodeClass * klass) {
	factorial_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = factorial_node_real_solve_r;
}


static void factorial_node_instance_init (FactorialNode * self) {
}


GType factorial_node_get_type (void) {
	static volatile gsize factorial_node_type_id__volatile = 0;
	if (g_once_init_enter (&factorial_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FactorialNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) factorial_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FactorialNode), 0, (GInstanceInitFunc) factorial_node_instance_init, NULL };
		GType factorial_node_type_id;
		factorial_node_type_id = g_type_register_static (TYPE_RNODE, "FactorialNode", &g_define_type_info, 0);
		g_once_init_leave (&factorial_node_type_id__volatile, factorial_node_type_id);
	}
	return factorial_node_type_id__volatile;
}


AddNode* add_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AddNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AddNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


AddNode* add_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return add_node_construct (TYPE_ADD_NODE, parser, token, precedence, associativity);
}


static Number* add_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	AddNode * self;
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	self = (AddNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = self->do_percentage;
	if (_tmp0_) {
		Number* per = NULL;
		Number* _tmp1_ = NULL;
		Number* _tmp2_ = NULL;
		Number* _tmp3_ = NULL;
		Number* _tmp4_ = NULL;
		Number* _tmp5_ = NULL;
		Number* _tmp6_ = NULL;
		Number* _tmp7_ = NULL;
		Number* _tmp8_ = NULL;
		Number* _tmp9_ = NULL;
		Number* _tmp10_ = NULL;
		_tmp1_ = r;
		_tmp2_ = number_new_integer ((gint64) 100);
		_tmp3_ = _tmp2_;
		_tmp4_ = number_add (_tmp1_, _tmp3_);
		_tmp5_ = _tmp4_;
		_g_object_unref0 (_tmp3_);
		per = _tmp5_;
		_tmp6_ = per;
		_tmp7_ = number_divide_integer (_tmp6_, (gint64) 100);
		_g_object_unref0 (per);
		per = _tmp7_;
		_tmp8_ = l;
		_tmp9_ = per;
		_tmp10_ = number_multiply (_tmp8_, _tmp9_);
		result = _tmp10_;
		_g_object_unref0 (per);
		return result;
	} else {
		Number* _tmp11_ = NULL;
		Number* _tmp12_ = NULL;
		Number* _tmp13_ = NULL;
		_tmp11_ = l;
		_tmp12_ = r;
		_tmp13_ = number_add (_tmp11_, _tmp12_);
		result = _tmp13_;
		return result;
	}
}


static void add_node_class_init (AddNodeClass * klass) {
	add_node_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = add_node_real_solve_lr;
	G_OBJECT_CLASS (klass)->finalize = add_node_finalize;
}


static void add_node_instance_init (AddNode * self) {
	self->do_percentage = FALSE;
}


static void add_node_finalize (GObject* obj) {
	AddNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_ADD_NODE, AddNode);
	G_OBJECT_CLASS (add_node_parent_class)->finalize (obj);
}


GType add_node_get_type (void) {
	static volatile gsize add_node_type_id__volatile = 0;
	if (g_once_init_enter (&add_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AddNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) add_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AddNode), 0, (GInstanceInitFunc) add_node_instance_init, NULL };
		GType add_node_type_id;
		add_node_type_id = g_type_register_static (TYPE_LR_NODE, "AddNode", &g_define_type_info, 0);
		g_once_init_leave (&add_node_type_id__volatile, add_node_type_id);
	}
	return add_node_type_id__volatile;
}


SubtractNode* subtract_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	SubtractNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (SubtractNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


SubtractNode* subtract_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return subtract_node_construct (TYPE_SUBTRACT_NODE, parser, token, precedence, associativity);
}


static Number* subtract_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	SubtractNode * self;
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	self = (SubtractNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = self->do_percentage;
	if (_tmp0_) {
		Number* per = NULL;
		Number* _tmp1_ = NULL;
		Number* _tmp2_ = NULL;
		Number* _tmp3_ = NULL;
		Number* _tmp4_ = NULL;
		Number* _tmp5_ = NULL;
		Number* _tmp6_ = NULL;
		Number* _tmp7_ = NULL;
		Number* _tmp8_ = NULL;
		Number* _tmp9_ = NULL;
		Number* _tmp10_ = NULL;
		_tmp1_ = r;
		_tmp2_ = number_new_integer ((gint64) -100);
		_tmp3_ = _tmp2_;
		_tmp4_ = number_add (_tmp1_, _tmp3_);
		_tmp5_ = _tmp4_;
		_g_object_unref0 (_tmp3_);
		per = _tmp5_;
		_tmp6_ = per;
		_tmp7_ = number_divide_integer (_tmp6_, (gint64) -100);
		_g_object_unref0 (per);
		per = _tmp7_;
		_tmp8_ = l;
		_tmp9_ = per;
		_tmp10_ = number_multiply (_tmp8_, _tmp9_);
		result = _tmp10_;
		_g_object_unref0 (per);
		return result;
	} else {
		Number* _tmp11_ = NULL;
		Number* _tmp12_ = NULL;
		Number* _tmp13_ = NULL;
		_tmp11_ = l;
		_tmp12_ = r;
		_tmp13_ = number_subtract (_tmp11_, _tmp12_);
		result = _tmp13_;
		return result;
	}
}


static void subtract_node_class_init (SubtractNodeClass * klass) {
	subtract_node_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = subtract_node_real_solve_lr;
	G_OBJECT_CLASS (klass)->finalize = subtract_node_finalize;
}


static void subtract_node_instance_init (SubtractNode * self) {
	self->do_percentage = FALSE;
}


static void subtract_node_finalize (GObject* obj) {
	SubtractNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SUBTRACT_NODE, SubtractNode);
	G_OBJECT_CLASS (subtract_node_parent_class)->finalize (obj);
}


GType subtract_node_get_type (void) {
	static volatile gsize subtract_node_type_id__volatile = 0;
	if (g_once_init_enter (&subtract_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubtractNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) subtract_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubtractNode), 0, (GInstanceInitFunc) subtract_node_instance_init, NULL };
		GType subtract_node_type_id;
		subtract_node_type_id = g_type_register_static (TYPE_LR_NODE, "SubtractNode", &g_define_type_info, 0);
		g_once_init_leave (&subtract_node_type_id__volatile, subtract_node_type_id);
	}
	return subtract_node_type_id__volatile;
}


MultiplyNode* multiply_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	MultiplyNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (MultiplyNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


MultiplyNode* multiply_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return multiply_node_construct (TYPE_MULTIPLY_NODE, parser, token, precedence, associativity);
}


static Number* multiply_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	MultiplyNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	self = (MultiplyNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_multiply (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void multiply_node_class_init (MultiplyNodeClass * klass) {
	multiply_node_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = multiply_node_real_solve_lr;
}


static void multiply_node_instance_init (MultiplyNode * self) {
}


GType multiply_node_get_type (void) {
	static volatile gsize multiply_node_type_id__volatile = 0;
	if (g_once_init_enter (&multiply_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MultiplyNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) multiply_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MultiplyNode), 0, (GInstanceInitFunc) multiply_node_instance_init, NULL };
		GType multiply_node_type_id;
		multiply_node_type_id = g_type_register_static (TYPE_LR_NODE, "MultiplyNode", &g_define_type_info, 0);
		g_once_init_leave (&multiply_node_type_id__volatile, multiply_node_type_id);
	}
	return multiply_node_type_id__volatile;
}


DivideNode* divide_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	DivideNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (DivideNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


DivideNode* divide_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return divide_node_construct (TYPE_DIVIDE_NODE, parser, token, precedence, associativity);
}


static Number* divide_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	DivideNode * self;
	Number* result = NULL;
	Number* z = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	self = (DivideNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_divide (_tmp0_, _tmp1_);
	z = _tmp2_;
	_tmp3_ = number_get_error ();
	_tmp4_ = _tmp3_;
	if (_tmp4_ != NULL) {
		ParseNode* tmpleft = NULL;
		ParseNode* _tmp5_ = NULL;
		ParseNode* _tmp6_ = NULL;
		ParseNode* tmpright = NULL;
		ParseNode* _tmp7_ = NULL;
		ParseNode* _tmp8_ = NULL;
		Parser* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		ParseNode* _tmp22_ = NULL;
		LexerToken* _tmp23_ = NULL;
		guint _tmp24_ = 0U;
		ParseNode* _tmp25_ = NULL;
		LexerToken* _tmp26_ = NULL;
		guint _tmp27_ = 0U;
		const gchar* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		_tmp5_ = ((ParseNode*) self)->right;
		_tmp6_ = _g_object_ref0 (_tmp5_);
		tmpleft = _tmp6_;
		_tmp7_ = ((ParseNode*) self)->right;
		_tmp8_ = _g_object_ref0 (_tmp7_);
		tmpright = _tmp8_;
		while (TRUE) {
			ParseNode* _tmp9_ = NULL;
			ParseNode* _tmp10_ = NULL;
			ParseNode* _tmp11_ = NULL;
			ParseNode* _tmp12_ = NULL;
			ParseNode* _tmp13_ = NULL;
			_tmp9_ = tmpleft;
			_tmp10_ = _tmp9_->left;
			if (!(_tmp10_ != NULL)) {
				break;
			}
			_tmp11_ = tmpleft;
			_tmp12_ = _tmp11_->left;
			_tmp13_ = _g_object_ref0 (_tmp12_);
			_g_object_unref0 (tmpleft);
			tmpleft = _tmp13_;
		}
		while (TRUE) {
			ParseNode* _tmp14_ = NULL;
			ParseNode* _tmp15_ = NULL;
			ParseNode* _tmp16_ = NULL;
			ParseNode* _tmp17_ = NULL;
			ParseNode* _tmp18_ = NULL;
			_tmp14_ = tmpright;
			_tmp15_ = _tmp14_->right;
			if (!(_tmp15_ != NULL)) {
				break;
			}
			_tmp16_ = tmpright;
			_tmp17_ = _tmp16_->right;
			_tmp18_ = _g_object_ref0 (_tmp17_);
			_g_object_unref0 (tmpright);
			tmpright = _tmp18_;
		}
		_tmp19_ = ((ParseNode*) self)->parser;
		_tmp20_ = number_get_error ();
		_tmp21_ = _tmp20_;
		_tmp22_ = tmpleft;
		_tmp23_ = _tmp22_->token;
		_tmp24_ = _tmp23_->start_index;
		_tmp25_ = tmpright;
		_tmp26_ = _tmp25_->token;
		_tmp27_ = _tmp26_->end_index;
		parser_set_error (_tmp19_, ERROR_CODE_MP, _tmp21_, _tmp24_, _tmp27_);
		_tmp28_ = number_get_error ();
		_tmp29_ = _tmp28_;
		number_set_error (NULL);
		_g_object_unref0 (tmpright);
		_g_object_unref0 (tmpleft);
	}
	result = z;
	return result;
}


static void divide_node_class_init (DivideNodeClass * klass) {
	divide_node_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = divide_node_real_solve_lr;
}


static void divide_node_instance_init (DivideNode * self) {
}


GType divide_node_get_type (void) {
	static volatile gsize divide_node_type_id__volatile = 0;
	if (g_once_init_enter (&divide_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DivideNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) divide_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DivideNode), 0, (GInstanceInitFunc) divide_node_instance_init, NULL };
		GType divide_node_type_id;
		divide_node_type_id = g_type_register_static (TYPE_LR_NODE, "DivideNode", &g_define_type_info, 0);
		g_once_init_leave (&divide_node_type_id__volatile, divide_node_type_id);
	}
	return divide_node_type_id__volatile;
}


ModulusDivideNode* modulus_divide_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	ModulusDivideNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (ModulusDivideNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


ModulusDivideNode* modulus_divide_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return modulus_divide_node_construct (TYPE_MODULUS_DIVIDE_NODE, parser, token, precedence, associativity);
}


static Number* modulus_divide_node_real_solve (ParseNode* base) {
	ModulusDivideNode * self;
	Number* result = NULL;
	ParseNode* _tmp0_ = NULL;
	self = (ModulusDivideNode*) base;
	_tmp0_ = ((ParseNode*) self)->left;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, TYPE_XPOW_YNODE)) {
		Number* base_value = NULL;
		ParseNode* _tmp1_ = NULL;
		ParseNode* _tmp2_ = NULL;
		Number* _tmp3_ = NULL;
		Number* exponent = NULL;
		ParseNode* _tmp4_ = NULL;
		ParseNode* _tmp5_ = NULL;
		Number* _tmp6_ = NULL;
		Number* mod = NULL;
		ParseNode* _tmp7_ = NULL;
		Number* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		gboolean _tmp10_ = FALSE;
		Number* _tmp11_ = NULL;
		Number* z = NULL;
		Number* _tmp14_ = NULL;
		Number* _tmp15_ = NULL;
		Number* _tmp16_ = NULL;
		Number* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		_tmp1_ = ((ParseNode*) self)->left;
		_tmp2_ = _tmp1_->left;
		_tmp3_ = parse_node_solve (_tmp2_);
		base_value = _tmp3_;
		_tmp4_ = ((ParseNode*) self)->left;
		_tmp5_ = _tmp4_->right;
		_tmp6_ = parse_node_solve (_tmp5_);
		exponent = _tmp6_;
		_tmp7_ = ((ParseNode*) self)->right;
		_tmp8_ = parse_node_solve (_tmp7_);
		mod = _tmp8_;
		_tmp11_ = base_value;
		if (_tmp11_ == NULL) {
			_tmp10_ = TRUE;
		} else {
			Number* _tmp12_ = NULL;
			_tmp12_ = exponent;
			_tmp10_ = _tmp12_ == NULL;
		}
		if (_tmp10_) {
			_tmp9_ = TRUE;
		} else {
			Number* _tmp13_ = NULL;
			_tmp13_ = mod;
			_tmp9_ = _tmp13_ == NULL;
		}
		if (_tmp9_) {
			result = NULL;
			_g_object_unref0 (mod);
			_g_object_unref0 (exponent);
			_g_object_unref0 (base_value);
			return result;
		}
		_tmp14_ = base_value;
		_tmp15_ = exponent;
		_tmp16_ = mod;
		_tmp17_ = number_modular_exponentiation (_tmp14_, _tmp15_, _tmp16_);
		z = _tmp17_;
		number_check_flags ();
		_tmp18_ = number_get_error ();
		_tmp19_ = _tmp18_;
		if (_tmp19_ != NULL) {
			ParseNode* tmpleft = NULL;
			ParseNode* _tmp20_ = NULL;
			ParseNode* _tmp21_ = NULL;
			ParseNode* tmpright = NULL;
			ParseNode* _tmp22_ = NULL;
			ParseNode* _tmp23_ = NULL;
			Parser* _tmp34_ = NULL;
			const gchar* _tmp35_ = NULL;
			const gchar* _tmp36_ = NULL;
			ParseNode* _tmp37_ = NULL;
			LexerToken* _tmp38_ = NULL;
			guint _tmp39_ = 0U;
			ParseNode* _tmp40_ = NULL;
			LexerToken* _tmp41_ = NULL;
			guint _tmp42_ = 0U;
			const gchar* _tmp43_ = NULL;
			const gchar* _tmp44_ = NULL;
			_tmp20_ = ((ParseNode*) self)->left;
			_tmp21_ = _g_object_ref0 (_tmp20_);
			tmpleft = _tmp21_;
			_tmp22_ = ((ParseNode*) self)->right;
			_tmp23_ = _g_object_ref0 (_tmp22_);
			tmpright = _tmp23_;
			while (TRUE) {
				ParseNode* _tmp24_ = NULL;
				ParseNode* _tmp25_ = NULL;
				ParseNode* _tmp26_ = NULL;
				ParseNode* _tmp27_ = NULL;
				ParseNode* _tmp28_ = NULL;
				_tmp24_ = tmpleft;
				_tmp25_ = _tmp24_->left;
				if (!(_tmp25_ != NULL)) {
					break;
				}
				_tmp26_ = tmpleft;
				_tmp27_ = _tmp26_->left;
				_tmp28_ = _g_object_ref0 (_tmp27_);
				_g_object_unref0 (tmpleft);
				tmpleft = _tmp28_;
			}
			while (TRUE) {
				ParseNode* _tmp29_ = NULL;
				ParseNode* _tmp30_ = NULL;
				ParseNode* _tmp31_ = NULL;
				ParseNode* _tmp32_ = NULL;
				ParseNode* _tmp33_ = NULL;
				_tmp29_ = tmpright;
				_tmp30_ = _tmp29_->right;
				if (!(_tmp30_ != NULL)) {
					break;
				}
				_tmp31_ = tmpright;
				_tmp32_ = _tmp31_->right;
				_tmp33_ = _g_object_ref0 (_tmp32_);
				_g_object_unref0 (tmpright);
				tmpright = _tmp33_;
			}
			_tmp34_ = ((ParseNode*) self)->parser;
			_tmp35_ = number_get_error ();
			_tmp36_ = _tmp35_;
			_tmp37_ = tmpleft;
			_tmp38_ = _tmp37_->token;
			_tmp39_ = _tmp38_->start_index;
			_tmp40_ = tmpright;
			_tmp41_ = _tmp40_->token;
			_tmp42_ = _tmp41_->end_index;
			parser_set_error (_tmp34_, ERROR_CODE_MP, _tmp36_, _tmp39_, _tmp42_);
			_tmp43_ = number_get_error ();
			_tmp44_ = _tmp43_;
			number_set_error (NULL);
			_g_object_unref0 (tmpright);
			_g_object_unref0 (tmpleft);
		}
		result = z;
		_g_object_unref0 (mod);
		_g_object_unref0 (exponent);
		_g_object_unref0 (base_value);
		return result;
	} else {
		Number* l = NULL;
		ParseNode* _tmp45_ = NULL;
		Number* _tmp46_ = NULL;
		Number* r = NULL;
		ParseNode* _tmp47_ = NULL;
		Number* _tmp48_ = NULL;
		gboolean _tmp49_ = FALSE;
		Number* _tmp50_ = NULL;
		Number* z = NULL;
		Number* _tmp52_ = NULL;
		Number* _tmp53_ = NULL;
		Number* _tmp54_ = NULL;
		const gchar* _tmp55_ = NULL;
		const gchar* _tmp56_ = NULL;
		_tmp45_ = ((ParseNode*) self)->left;
		_tmp46_ = parse_node_solve (_tmp45_);
		l = _tmp46_;
		_tmp47_ = ((ParseNode*) self)->right;
		_tmp48_ = parse_node_solve (_tmp47_);
		r = _tmp48_;
		_tmp50_ = l;
		if (_tmp50_ == NULL) {
			_tmp49_ = TRUE;
		} else {
			Number* _tmp51_ = NULL;
			_tmp51_ = r;
			_tmp49_ = _tmp51_ == NULL;
		}
		if (_tmp49_) {
			result = NULL;
			_g_object_unref0 (r);
			_g_object_unref0 (l);
			return result;
		}
		_tmp52_ = l;
		_tmp53_ = r;
		_tmp54_ = lr_node_solve_lr ((LRNode*) self, _tmp52_, _tmp53_);
		z = _tmp54_;
		number_check_flags ();
		_tmp55_ = number_get_error ();
		_tmp56_ = _tmp55_;
		if (_tmp56_ != NULL) {
			ParseNode* tmpleft = NULL;
			ParseNode* _tmp57_ = NULL;
			ParseNode* _tmp58_ = NULL;
			ParseNode* tmpright = NULL;
			ParseNode* _tmp59_ = NULL;
			ParseNode* _tmp60_ = NULL;
			Parser* _tmp71_ = NULL;
			const gchar* _tmp72_ = NULL;
			const gchar* _tmp73_ = NULL;
			ParseNode* _tmp74_ = NULL;
			LexerToken* _tmp75_ = NULL;
			guint _tmp76_ = 0U;
			ParseNode* _tmp77_ = NULL;
			LexerToken* _tmp78_ = NULL;
			guint _tmp79_ = 0U;
			const gchar* _tmp80_ = NULL;
			const gchar* _tmp81_ = NULL;
			_tmp57_ = ((ParseNode*) self)->left;
			_tmp58_ = _g_object_ref0 (_tmp57_);
			tmpleft = _tmp58_;
			_tmp59_ = ((ParseNode*) self)->right;
			_tmp60_ = _g_object_ref0 (_tmp59_);
			tmpright = _tmp60_;
			while (TRUE) {
				ParseNode* _tmp61_ = NULL;
				ParseNode* _tmp62_ = NULL;
				ParseNode* _tmp63_ = NULL;
				ParseNode* _tmp64_ = NULL;
				ParseNode* _tmp65_ = NULL;
				_tmp61_ = tmpleft;
				_tmp62_ = _tmp61_->left;
				if (!(_tmp62_ != NULL)) {
					break;
				}
				_tmp63_ = tmpleft;
				_tmp64_ = _tmp63_->left;
				_tmp65_ = _g_object_ref0 (_tmp64_);
				_g_object_unref0 (tmpleft);
				tmpleft = _tmp65_;
			}
			while (TRUE) {
				ParseNode* _tmp66_ = NULL;
				ParseNode* _tmp67_ = NULL;
				ParseNode* _tmp68_ = NULL;
				ParseNode* _tmp69_ = NULL;
				ParseNode* _tmp70_ = NULL;
				_tmp66_ = tmpright;
				_tmp67_ = _tmp66_->right;
				if (!(_tmp67_ != NULL)) {
					break;
				}
				_tmp68_ = tmpright;
				_tmp69_ = _tmp68_->right;
				_tmp70_ = _g_object_ref0 (_tmp69_);
				_g_object_unref0 (tmpright);
				tmpright = _tmp70_;
			}
			_tmp71_ = ((ParseNode*) self)->parser;
			_tmp72_ = number_get_error ();
			_tmp73_ = _tmp72_;
			_tmp74_ = tmpleft;
			_tmp75_ = _tmp74_->token;
			_tmp76_ = _tmp75_->start_index;
			_tmp77_ = tmpright;
			_tmp78_ = _tmp77_->token;
			_tmp79_ = _tmp78_->end_index;
			parser_set_error (_tmp71_, ERROR_CODE_MP, _tmp73_, _tmp76_, _tmp79_);
			_tmp80_ = number_get_error ();
			_tmp81_ = _tmp80_;
			number_set_error (NULL);
			_g_object_unref0 (tmpright);
			_g_object_unref0 (tmpleft);
		}
		result = z;
		_g_object_unref0 (r);
		_g_object_unref0 (l);
		return result;
	}
}


static Number* modulus_divide_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	ModulusDivideNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	self = (ModulusDivideNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_modulus_divide (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void modulus_divide_node_class_init (ModulusDivideNodeClass * klass) {
	modulus_divide_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = modulus_divide_node_real_solve;
	((LRNodeClass *) klass)->solve_lr = modulus_divide_node_real_solve_lr;
}


static void modulus_divide_node_instance_init (ModulusDivideNode * self) {
}


GType modulus_divide_node_get_type (void) {
	static volatile gsize modulus_divide_node_type_id__volatile = 0;
	if (g_once_init_enter (&modulus_divide_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ModulusDivideNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) modulus_divide_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ModulusDivideNode), 0, (GInstanceInitFunc) modulus_divide_node_instance_init, NULL };
		GType modulus_divide_node_type_id;
		modulus_divide_node_type_id = g_type_register_static (TYPE_LR_NODE, "ModulusDivideNode", &g_define_type_info, 0);
		g_once_init_leave (&modulus_divide_node_type_id__volatile, modulus_divide_node_type_id);
	}
	return modulus_divide_node_type_id__volatile;
}


RootNode* root_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, gint n) {
	RootNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	gint _tmp4_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (RootNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	_tmp4_ = n;
	self->priv->n = _tmp4_;
	return self;
}


RootNode* root_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, gint n) {
	return root_node_construct (TYPE_ROOT_NODE, parser, token, precedence, associativity, n);
}


static Number* root_node_real_solve_r (RNode* base, Number* r) {
	RootNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	Number* _tmp2_ = NULL;
	self = (RootNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = self->priv->n;
	_tmp2_ = number_root (_tmp0_, (gint64) _tmp1_);
	result = _tmp2_;
	return result;
}


static void root_node_class_init (RootNodeClass * klass) {
	root_node_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RootNodePrivate));
	((RNodeClass *) klass)->solve_r = root_node_real_solve_r;
	G_OBJECT_CLASS (klass)->finalize = root_node_finalize;
}


static void root_node_instance_init (RootNode * self) {
	self->priv = ROOT_NODE_GET_PRIVATE (self);
}


static void root_node_finalize (GObject* obj) {
	RootNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_ROOT_NODE, RootNode);
	G_OBJECT_CLASS (root_node_parent_class)->finalize (obj);
}


GType root_node_get_type (void) {
	static volatile gsize root_node_type_id__volatile = 0;
	if (g_once_init_enter (&root_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RootNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) root_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RootNode), 0, (GInstanceInitFunc) root_node_instance_init, NULL };
		GType root_node_type_id;
		root_node_type_id = g_type_register_static (TYPE_RNODE, "RootNode", &g_define_type_info, 0);
		g_once_init_leave (&root_node_type_id__volatile, root_node_type_id);
	}
	return root_node_type_id__volatile;
}


XPowYNode* xpow_ynode_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	XPowYNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (XPowYNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


XPowYNode* xpow_ynode_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return xpow_ynode_construct (TYPE_XPOW_YNODE, parser, token, precedence, associativity);
}


static Number* xpow_ynode_real_solve_lr (LRNode* base, Number* l, Number* r) {
	XPowYNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	self = (XPowYNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_xpowy (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void xpow_ynode_class_init (XPowYNodeClass * klass) {
	xpow_ynode_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = xpow_ynode_real_solve_lr;
}


static void xpow_ynode_instance_init (XPowYNode * self) {
}


GType xpow_ynode_get_type (void) {
	static volatile gsize xpow_ynode_type_id__volatile = 0;
	if (g_once_init_enter (&xpow_ynode_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (XPowYNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xpow_ynode_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (XPowYNode), 0, (GInstanceInitFunc) xpow_ynode_instance_init, NULL };
		GType xpow_ynode_type_id;
		xpow_ynode_type_id = g_type_register_static (TYPE_LR_NODE, "XPowYNode", &g_define_type_info, 0);
		g_once_init_leave (&xpow_ynode_type_id__volatile, xpow_ynode_type_id);
	}
	return xpow_ynode_type_id__volatile;
}


XPowYIntegerNode* xpow_yinteger_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	XPowYIntegerNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (XPowYIntegerNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


XPowYIntegerNode* xpow_yinteger_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return xpow_yinteger_node_construct (TYPE_XPOW_YINTEGER_NODE, parser, token, precedence, associativity);
}


static Number* xpow_yinteger_node_real_solve (ParseNode* base) {
	XPowYIntegerNode * self;
	Number* result = NULL;
	Number* val = NULL;
	ParseNode* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	gint64 pow = 0LL;
	ParseNode* _tmp8_ = NULL;
	LexerToken* _tmp9_ = NULL;
	Number* _tmp18_ = NULL;
	Number* z = NULL;
	Number* _tmp19_ = NULL;
	gint64 _tmp20_ = 0LL;
	Number* _tmp21_ = NULL;
	const gchar* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	self = (XPowYIntegerNode*) base;
	_tmp0_ = ((ParseNode*) self)->left;
	_tmp1_ = parse_node_solve (_tmp0_);
	val = _tmp1_;
	_tmp2_ = val;
	if (_tmp2_ == NULL) {
		ParseNode* _tmp3_ = NULL;
		LexerToken* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		Number* _tmp7_ = NULL;
		_tmp3_ = ((ParseNode*) self)->left;
		_tmp4_ = _tmp3_->token;
		_tmp5_ = _tmp4_->text;
		_tmp6_ = super_atoi (_tmp5_);
		_tmp7_ = number_new_integer ((gint64) _tmp6_);
		_g_object_unref0 (val);
		val = _tmp7_;
	}
	_tmp8_ = ((ParseNode*) self)->right;
	_tmp9_ = _tmp8_->token;
	if (_tmp9_ != NULL) {
		ParseNode* _tmp10_ = NULL;
		LexerToken* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gint _tmp13_ = 0;
		_tmp10_ = ((ParseNode*) self)->right;
		_tmp11_ = _tmp10_->token;
		_tmp12_ = _tmp11_->text;
		_tmp13_ = super_atoi (_tmp12_);
		pow = (gint64) _tmp13_;
	} else {
		ParseNode* _tmp14_ = NULL;
		Number* _tmp15_ = NULL;
		Number* _tmp16_ = NULL;
		gint64 _tmp17_ = 0LL;
		_tmp14_ = ((ParseNode*) self)->right;
		_tmp15_ = parse_node_solve (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = number_to_integer (_tmp16_);
		pow = _tmp17_;
		_g_object_unref0 (_tmp16_);
	}
	_tmp18_ = val;
	if (_tmp18_ == NULL) {
		result = NULL;
		_g_object_unref0 (val);
		return result;
	}
	_tmp19_ = val;
	_tmp20_ = pow;
	_tmp21_ = number_xpowy_integer (_tmp19_, _tmp20_);
	z = _tmp21_;
	number_check_flags ();
	_tmp22_ = number_get_error ();
	_tmp23_ = _tmp22_;
	if (_tmp23_ != NULL) {
		ParseNode* tmpleft = NULL;
		ParseNode* _tmp24_ = NULL;
		ParseNode* _tmp25_ = NULL;
		ParseNode* tmpright = NULL;
		ParseNode* _tmp26_ = NULL;
		ParseNode* _tmp27_ = NULL;
		Parser* _tmp38_ = NULL;
		const gchar* _tmp39_ = NULL;
		const gchar* _tmp40_ = NULL;
		ParseNode* _tmp41_ = NULL;
		LexerToken* _tmp42_ = NULL;
		guint _tmp43_ = 0U;
		ParseNode* _tmp44_ = NULL;
		LexerToken* _tmp45_ = NULL;
		guint _tmp46_ = 0U;
		const gchar* _tmp47_ = NULL;
		const gchar* _tmp48_ = NULL;
		_tmp24_ = ((ParseNode*) self)->left;
		_tmp25_ = _g_object_ref0 (_tmp24_);
		tmpleft = _tmp25_;
		_tmp26_ = ((ParseNode*) self)->right;
		_tmp27_ = _g_object_ref0 (_tmp26_);
		tmpright = _tmp27_;
		while (TRUE) {
			ParseNode* _tmp28_ = NULL;
			ParseNode* _tmp29_ = NULL;
			ParseNode* _tmp30_ = NULL;
			ParseNode* _tmp31_ = NULL;
			ParseNode* _tmp32_ = NULL;
			_tmp28_ = tmpleft;
			_tmp29_ = _tmp28_->left;
			if (!(_tmp29_ != NULL)) {
				break;
			}
			_tmp30_ = tmpleft;
			_tmp31_ = _tmp30_->left;
			_tmp32_ = _g_object_ref0 (_tmp31_);
			_g_object_unref0 (tmpleft);
			tmpleft = _tmp32_;
		}
		while (TRUE) {
			ParseNode* _tmp33_ = NULL;
			ParseNode* _tmp34_ = NULL;
			ParseNode* _tmp35_ = NULL;
			ParseNode* _tmp36_ = NULL;
			ParseNode* _tmp37_ = NULL;
			_tmp33_ = tmpright;
			_tmp34_ = _tmp33_->right;
			if (!(_tmp34_ != NULL)) {
				break;
			}
			_tmp35_ = tmpright;
			_tmp36_ = _tmp35_->right;
			_tmp37_ = _g_object_ref0 (_tmp36_);
			_g_object_unref0 (tmpright);
			tmpright = _tmp37_;
		}
		_tmp38_ = ((ParseNode*) self)->parser;
		_tmp39_ = number_get_error ();
		_tmp40_ = _tmp39_;
		_tmp41_ = tmpleft;
		_tmp42_ = _tmp41_->token;
		_tmp43_ = _tmp42_->start_index;
		_tmp44_ = tmpright;
		_tmp45_ = _tmp44_->token;
		_tmp46_ = _tmp45_->end_index;
		parser_set_error (_tmp38_, ERROR_CODE_MP, _tmp40_, _tmp43_, _tmp46_);
		_tmp47_ = number_get_error ();
		_tmp48_ = _tmp47_;
		number_set_error (NULL);
		_g_object_unref0 (tmpright);
		_g_object_unref0 (tmpleft);
	}
	result = z;
	_g_object_unref0 (val);
	return result;
}


static void xpow_yinteger_node_class_init (XPowYIntegerNodeClass * klass) {
	xpow_yinteger_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = xpow_yinteger_node_real_solve;
}


static void xpow_yinteger_node_instance_init (XPowYIntegerNode * self) {
}


/**
 * This class is a XPowY in which the right token is an nsup number.
 */
GType xpow_yinteger_node_get_type (void) {
	static volatile gsize xpow_yinteger_node_type_id__volatile = 0;
	if (g_once_init_enter (&xpow_yinteger_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (XPowYIntegerNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xpow_yinteger_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (XPowYIntegerNode), 0, (GInstanceInitFunc) xpow_yinteger_node_instance_init, NULL };
		GType xpow_yinteger_node_type_id;
		xpow_yinteger_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "XPowYIntegerNode", &g_define_type_info, 0);
		g_once_init_leave (&xpow_yinteger_node_type_id__volatile, xpow_yinteger_node_type_id);
	}
	return xpow_yinteger_node_type_id__volatile;
}


NotNode* not_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	NotNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (NotNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


NotNode* not_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return not_node_construct (TYPE_NOT_NODE, parser, token, precedence, associativity);
}


static Number* not_node_real_solve_r (RNode* base, Number* r) {
	NotNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Parser* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gboolean _tmp3_ = FALSE;
	Number* _tmp6_ = NULL;
	Parser* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	Number* _tmp9_ = NULL;
	self = (NotNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = ((ParseNode*) self)->parser;
	_tmp2_ = _tmp1_->wordlen;
	_tmp3_ = mp_is_overflow (_tmp0_, _tmp2_);
	if (!_tmp3_) {
		Parser* _tmp4_ = NULL;
		Number* _tmp5_ = NULL;
		_tmp4_ = ((ParseNode*) self)->parser;
		parser_set_error (_tmp4_, ERROR_CODE_OVERFLOW, NULL, (guint) 0, (guint) 0);
		_tmp5_ = number_new_integer ((gint64) 0);
		result = _tmp5_;
		return result;
	}
	_tmp6_ = r;
	_tmp7_ = ((ParseNode*) self)->parser;
	_tmp8_ = _tmp7_->wordlen;
	_tmp9_ = number_not (_tmp6_, _tmp8_);
	result = _tmp9_;
	return result;
}


static void not_node_class_init (NotNodeClass * klass) {
	not_node_parent_class = g_type_class_peek_parent (klass);
	((RNodeClass *) klass)->solve_r = not_node_real_solve_r;
}


static void not_node_instance_init (NotNode * self) {
}


GType not_node_get_type (void) {
	static volatile gsize not_node_type_id__volatile = 0;
	if (g_once_init_enter (&not_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NotNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) not_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NotNode), 0, (GInstanceInitFunc) not_node_instance_init, NULL };
		GType not_node_type_id;
		not_node_type_id = g_type_register_static (TYPE_RNODE, "NotNode", &g_define_type_info, 0);
		g_once_init_leave (&not_node_type_id__volatile, not_node_type_id);
	}
	return not_node_type_id__volatile;
}


AndNode* and_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AndNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AndNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


AndNode* and_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return and_node_construct (TYPE_AND_NODE, parser, token, precedence, associativity);
}


static Number* and_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	AndNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	self = (AndNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_and (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void and_node_class_init (AndNodeClass * klass) {
	and_node_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = and_node_real_solve_lr;
}


static void and_node_instance_init (AndNode * self) {
}


GType and_node_get_type (void) {
	static volatile gsize and_node_type_id__volatile = 0;
	if (g_once_init_enter (&and_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AndNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) and_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AndNode), 0, (GInstanceInitFunc) and_node_instance_init, NULL };
		GType and_node_type_id;
		and_node_type_id = g_type_register_static (TYPE_LR_NODE, "AndNode", &g_define_type_info, 0);
		g_once_init_leave (&and_node_type_id__volatile, and_node_type_id);
	}
	return and_node_type_id__volatile;
}


OrNode* or_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	OrNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (OrNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


OrNode* or_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return or_node_construct (TYPE_OR_NODE, parser, token, precedence, associativity);
}


static Number* or_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	OrNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	self = (OrNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_or (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void or_node_class_init (OrNodeClass * klass) {
	or_node_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = or_node_real_solve_lr;
}


static void or_node_instance_init (OrNode * self) {
}


GType or_node_get_type (void) {
	static volatile gsize or_node_type_id__volatile = 0;
	if (g_once_init_enter (&or_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OrNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) or_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OrNode), 0, (GInstanceInitFunc) or_node_instance_init, NULL };
		GType or_node_type_id;
		or_node_type_id = g_type_register_static (TYPE_LR_NODE, "OrNode", &g_define_type_info, 0);
		g_once_init_leave (&or_node_type_id__volatile, or_node_type_id);
	}
	return or_node_type_id__volatile;
}


XorNode* xor_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	XorNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (XorNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


XorNode* xor_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return xor_node_construct (TYPE_XOR_NODE, parser, token, precedence, associativity);
}


static Number* xor_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	XorNode * self;
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_ = NULL;
	Number* _tmp2_ = NULL;
	self = (XorNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_xor (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void xor_node_class_init (XorNodeClass * klass) {
	xor_node_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = xor_node_real_solve_lr;
}


static void xor_node_instance_init (XorNode * self) {
}


GType xor_node_get_type (void) {
	static volatile gsize xor_node_type_id__volatile = 0;
	if (g_once_init_enter (&xor_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (XorNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xor_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (XorNode), 0, (GInstanceInitFunc) xor_node_instance_init, NULL };
		GType xor_node_type_id;
		xor_node_type_id = g_type_register_static (TYPE_LR_NODE, "XorNode", &g_define_type_info, 0);
		g_once_init_leave (&xor_node_type_id__volatile, xor_node_type_id);
	}
	return xor_node_type_id__volatile;
}


ConvertNode* convert_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	ConvertNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (ConvertNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


ConvertNode* convert_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return convert_node_construct (TYPE_CONVERT_NODE, parser, token, precedence, associativity);
}


static Number* convert_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	ConvertNode * self;
	Number* result = NULL;
	gchar* from = NULL;
	ParseNode* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* to = NULL;
	ParseNode* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	Number* tmp = NULL;
	Number* _tmp20_ = NULL;
	Number* ans = NULL;
	Parser* _tmp21_ = NULL;
	Number* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	Number* _tmp25_ = NULL;
	Number* _tmp26_ = NULL;
	self = (ConvertNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = ((ParseNode*) self)->left;
	_tmp1_ = _tmp0_->value;
	if (_tmp1_ != NULL) {
		ParseNode* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		ParseNode* _tmp5_ = NULL;
		_tmp2_ = ((ParseNode*) self)->left;
		_tmp3_ = _tmp2_->value;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (from);
		from = _tmp4_;
		_tmp5_ = ((ParseNode*) self)->left;
		_g_free0 (_tmp5_->value);
		_tmp5_->value = NULL;
	} else {
		ParseNode* _tmp6_ = NULL;
		LexerToken* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp6_ = ((ParseNode*) self)->left;
		_tmp7_ = _tmp6_->token;
		_tmp8_ = _tmp7_->text;
		_tmp9_ = g_strdup (_tmp8_);
		_g_free0 (from);
		from = _tmp9_;
	}
	_tmp10_ = ((ParseNode*) self)->right;
	_tmp11_ = _tmp10_->value;
	if (_tmp11_ != NULL) {
		ParseNode* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		ParseNode* _tmp15_ = NULL;
		_tmp12_ = ((ParseNode*) self)->right;
		_tmp13_ = _tmp12_->value;
		_tmp14_ = g_strdup (_tmp13_);
		_g_free0 (to);
		to = _tmp14_;
		_tmp15_ = ((ParseNode*) self)->right;
		_g_free0 (_tmp15_->value);
		_tmp15_->value = NULL;
	} else {
		ParseNode* _tmp16_ = NULL;
		LexerToken* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		_tmp16_ = ((ParseNode*) self)->right;
		_tmp17_ = _tmp16_->token;
		_tmp18_ = _tmp17_->text;
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (to);
		to = _tmp19_;
	}
	_tmp20_ = number_new_integer ((gint64) 1);
	tmp = _tmp20_;
	_tmp21_ = ((ParseNode*) self)->parser;
	_tmp22_ = tmp;
	_tmp23_ = from;
	_tmp24_ = to;
	_tmp25_ = parser_convert (_tmp21_, _tmp22_, _tmp23_, _tmp24_);
	ans = _tmp25_;
	_tmp26_ = ans;
	if (_tmp26_ == NULL) {
		Parser* _tmp27_ = NULL;
		_tmp27_ = ((ParseNode*) self)->parser;
		parser_set_error (_tmp27_, ERROR_CODE_UNKNOWN_CONVERSION, NULL, (guint) 0, (guint) 0);
	}
	result = ans;
	_g_object_unref0 (tmp);
	_g_free0 (to);
	_g_free0 (from);
	return result;
}


static void convert_node_class_init (ConvertNodeClass * klass) {
	convert_node_parent_class = g_type_class_peek_parent (klass);
	((LRNodeClass *) klass)->solve_lr = convert_node_real_solve_lr;
}


static void convert_node_instance_init (ConvertNode * self) {
}


GType convert_node_get_type (void) {
	static volatile gsize convert_node_type_id__volatile = 0;
	if (g_once_init_enter (&convert_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConvertNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) convert_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConvertNode), 0, (GInstanceInitFunc) convert_node_instance_init, NULL };
		GType convert_node_type_id;
		convert_node_type_id = g_type_register_static (TYPE_LR_NODE, "ConvertNode", &g_define_type_info, 0);
		g_once_init_leave (&convert_node_type_id__volatile, convert_node_type_id);
	}
	return convert_node_type_id__volatile;
}


ConvertBaseNode* convert_base_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value) {
	ConvertBaseNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = value;
	self = (ConvertBaseNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


ConvertBaseNode* convert_base_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value) {
	return convert_base_node_construct (TYPE_CONVERT_BASE_NODE, parser, token, precedence, associativity, value);
}


static Number* convert_base_node_real_solve (ParseNode* base) {
	ConvertBaseNode * self;
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_ = NULL;
	ParseNode* _tmp23_ = NULL;
	Number* _tmp24_ = NULL;
	self = (ConvertBaseNode*) base;
	_tmp1_ = ((ParseNode*) self)->value;
	if (g_strcmp0 (_tmp1_, "hex") == 0) {
		_tmp0_ = TRUE;
	} else {
		const gchar* _tmp2_ = NULL;
		_tmp2_ = ((ParseNode*) self)->value;
		_tmp0_ = g_strcmp0 (_tmp2_, "hexadecimal") == 0;
	}
	if (_tmp0_) {
		Parser* _tmp3_ = NULL;
		_tmp3_ = ((ParseNode*) self)->parser;
		parser_set_representation_base (_tmp3_, (guint) 16);
	} else {
		gboolean _tmp4_ = FALSE;
		const gchar* _tmp5_ = NULL;
		_tmp5_ = ((ParseNode*) self)->value;
		if (g_strcmp0 (_tmp5_, "dec") == 0) {
			_tmp4_ = TRUE;
		} else {
			const gchar* _tmp6_ = NULL;
			_tmp6_ = ((ParseNode*) self)->value;
			_tmp4_ = g_strcmp0 (_tmp6_, "decimal") == 0;
		}
		if (_tmp4_) {
			Parser* _tmp7_ = NULL;
			_tmp7_ = ((ParseNode*) self)->parser;
			parser_set_representation_base (_tmp7_, (guint) 10);
		} else {
			gboolean _tmp8_ = FALSE;
			const gchar* _tmp9_ = NULL;
			_tmp9_ = ((ParseNode*) self)->value;
			if (g_strcmp0 (_tmp9_, "oct") == 0) {
				_tmp8_ = TRUE;
			} else {
				const gchar* _tmp10_ = NULL;
				_tmp10_ = ((ParseNode*) self)->value;
				_tmp8_ = g_strcmp0 (_tmp10_, "octal") == 0;
			}
			if (_tmp8_) {
				Parser* _tmp11_ = NULL;
				_tmp11_ = ((ParseNode*) self)->parser;
				parser_set_representation_base (_tmp11_, (guint) 8);
			} else {
				gboolean _tmp12_ = FALSE;
				const gchar* _tmp13_ = NULL;
				_tmp13_ = ((ParseNode*) self)->value;
				if (g_strcmp0 (_tmp13_, "bin") == 0) {
					_tmp12_ = TRUE;
				} else {
					const gchar* _tmp14_ = NULL;
					_tmp14_ = ((ParseNode*) self)->value;
					_tmp12_ = g_strcmp0 (_tmp14_, "binary") == 0;
				}
				if (_tmp12_) {
					Parser* _tmp15_ = NULL;
					_tmp15_ = ((ParseNode*) self)->parser;
					parser_set_representation_base (_tmp15_, (guint) 2);
				} else {
					Parser* _tmp16_ = NULL;
					LexerToken* _tmp17_ = NULL;
					const gchar* _tmp18_ = NULL;
					LexerToken* _tmp19_ = NULL;
					guint _tmp20_ = 0U;
					LexerToken* _tmp21_ = NULL;
					guint _tmp22_ = 0U;
					_tmp16_ = ((ParseNode*) self)->parser;
					_tmp17_ = ((ParseNode*) self)->token;
					_tmp18_ = _tmp17_->text;
					_tmp19_ = ((ParseNode*) self)->token;
					_tmp20_ = _tmp19_->start_index;
					_tmp21_ = ((ParseNode*) self)->token;
					_tmp22_ = _tmp21_->end_index;
					parser_set_error (_tmp16_, ERROR_CODE_UNKNOWN_CONVERSION, _tmp18_, _tmp20_, _tmp22_);
					result = NULL;
					return result;
				}
			}
		}
	}
	_tmp23_ = ((ParseNode*) self)->left;
	_tmp24_ = parse_node_solve (_tmp23_);
	result = _tmp24_;
	return result;
}


static void convert_base_node_class_init (ConvertBaseNodeClass * klass) {
	convert_base_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = convert_base_node_real_solve;
}


static void convert_base_node_instance_init (ConvertBaseNode * self) {
}


GType convert_base_node_get_type (void) {
	static volatile gsize convert_base_node_type_id__volatile = 0;
	if (g_once_init_enter (&convert_base_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConvertBaseNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) convert_base_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConvertBaseNode), 0, (GInstanceInitFunc) convert_base_node_instance_init, NULL };
		GType convert_base_node_type_id;
		convert_base_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "ConvertBaseNode", &g_define_type_info, 0);
		g_once_init_leave (&convert_base_node_type_id__volatile, convert_base_node_type_id);
	}
	return convert_base_node_type_id__volatile;
}


ConvertNumberNode* convert_number_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	ConvertNumberNode * self = NULL;
	Parser* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (ConvertNumberNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


ConvertNumberNode* convert_number_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return convert_number_node_construct (TYPE_CONVERT_NUMBER_NODE, parser, token, precedence, associativity);
}


static Number* convert_number_node_real_solve (ParseNode* base) {
	ConvertNumberNode * self;
	Number* result = NULL;
	gchar* from = NULL;
	ParseNode* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* to = NULL;
	ParseNode* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	Number* tmp = NULL;
	ParseNode* _tmp20_ = NULL;
	ParseNode* _tmp21_ = NULL;
	LexerToken* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	Parser* _tmp24_ = NULL;
	gint _tmp25_ = 0;
	Number* _tmp26_ = NULL;
	Number* _tmp27_ = NULL;
	Number* ans = NULL;
	Parser* _tmp28_ = NULL;
	Number* _tmp29_ = NULL;
	const gchar* _tmp30_ = NULL;
	const gchar* _tmp31_ = NULL;
	Number* _tmp32_ = NULL;
	Number* _tmp33_ = NULL;
	self = (ConvertNumberNode*) base;
	_tmp0_ = ((ParseNode*) self)->left;
	_tmp1_ = _tmp0_->value;
	if (_tmp1_ != NULL) {
		ParseNode* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		ParseNode* _tmp5_ = NULL;
		_tmp2_ = ((ParseNode*) self)->left;
		_tmp3_ = _tmp2_->value;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (from);
		from = _tmp4_;
		_tmp5_ = ((ParseNode*) self)->left;
		_g_free0 (_tmp5_->value);
		_tmp5_->value = NULL;
	} else {
		ParseNode* _tmp6_ = NULL;
		LexerToken* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp6_ = ((ParseNode*) self)->left;
		_tmp7_ = _tmp6_->token;
		_tmp8_ = _tmp7_->text;
		_tmp9_ = g_strdup (_tmp8_);
		_g_free0 (from);
		from = _tmp9_;
	}
	_tmp10_ = ((ParseNode*) self)->right;
	_tmp11_ = _tmp10_->value;
	if (_tmp11_ != NULL) {
		ParseNode* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		ParseNode* _tmp15_ = NULL;
		_tmp12_ = ((ParseNode*) self)->right;
		_tmp13_ = _tmp12_->value;
		_tmp14_ = g_strdup (_tmp13_);
		_g_free0 (to);
		to = _tmp14_;
		_tmp15_ = ((ParseNode*) self)->right;
		_g_free0 (_tmp15_->value);
		_tmp15_->value = NULL;
	} else {
		ParseNode* _tmp16_ = NULL;
		LexerToken* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		_tmp16_ = ((ParseNode*) self)->right;
		_tmp17_ = _tmp16_->token;
		_tmp18_ = _tmp17_->text;
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (to);
		to = _tmp19_;
	}
	_tmp20_ = ((ParseNode*) self)->left;
	_tmp21_ = _tmp20_->left;
	_tmp22_ = _tmp21_->token;
	_tmp23_ = _tmp22_->text;
	_tmp24_ = ((ParseNode*) self)->parser;
	_tmp25_ = _tmp24_->number_base;
	_tmp26_ = mp_set_from_string (_tmp23_, _tmp25_);
	tmp = _tmp26_;
	_tmp27_ = tmp;
	if (_tmp27_ == NULL) {
		result = NULL;
		_g_object_unref0 (tmp);
		_g_free0 (to);
		_g_free0 (from);
		return result;
	}
	_tmp28_ = ((ParseNode*) self)->parser;
	_tmp29_ = tmp;
	_tmp30_ = from;
	_tmp31_ = to;
	_tmp32_ = parser_convert (_tmp28_, _tmp29_, _tmp30_, _tmp31_);
	ans = _tmp32_;
	_tmp33_ = ans;
	if (_tmp33_ == NULL) {
		Parser* _tmp34_ = NULL;
		_tmp34_ = ((ParseNode*) self)->parser;
		parser_set_error (_tmp34_, ERROR_CODE_UNKNOWN_CONVERSION, NULL, (guint) 0, (guint) 0);
	}
	result = ans;
	_g_object_unref0 (tmp);
	_g_free0 (to);
	_g_free0 (from);
	return result;
}


static void convert_number_node_class_init (ConvertNumberNodeClass * klass) {
	convert_number_node_parent_class = g_type_class_peek_parent (klass);
	((ParseNodeClass *) klass)->solve = convert_number_node_real_solve;
}


static void convert_number_node_instance_init (ConvertNumberNode * self) {
}


GType convert_number_node_get_type (void) {
	static volatile gsize convert_number_node_type_id__volatile = 0;
	if (g_once_init_enter (&convert_number_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConvertNumberNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) convert_number_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConvertNumberNode), 0, (GInstanceInitFunc) convert_number_node_instance_init, NULL };
		GType convert_number_node_type_id;
		convert_number_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "ConvertNumberNode", &g_define_type_info, 0);
		g_once_init_leave (&convert_number_node_type_id__volatile, convert_number_node_type_id);
	}
	return convert_number_node_type_id__volatile;
}


Parser* parser_construct (GType object_type, const gchar* input, gint number_base, gint wordlen, AngleUnit angle_units) {
	Parser* self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	Lexer* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	AngleUnit _tmp8_ = 0;
	g_return_val_if_fail (input != NULL, NULL);
	self = (Parser*) g_type_create_instance (object_type);
	_tmp0_ = input;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->input);
	self->priv->input = _tmp1_;
	_tmp2_ = input;
	_tmp3_ = number_base;
	_tmp4_ = lexer_new (_tmp2_, self, _tmp3_);
	_g_object_unref0 (self->priv->lexer);
	self->priv->lexer = _tmp4_;
	_g_object_unref0 (self->priv->root);
	self->priv->root = NULL;
	self->priv->depth_level = (guint) 0;
	_g_object_unref0 (self->priv->right_most);
	self->priv->right_most = NULL;
	_tmp5_ = number_base;
	self->number_base = _tmp5_;
	_tmp6_ = number_base;
	self->priv->representation_base = (guint) _tmp6_;
	_tmp7_ = wordlen;
	self->wordlen = _tmp7_;
	_tmp8_ = angle_units;
	self->angle_units = _tmp8_;
	self->priv->error = ERROR_CODE_NONE;
	_g_free0 (self->priv->error_token);
	self->priv->error_token = NULL;
	self->priv->error_token_start = 0;
	self->priv->error_token_end = 0;
	return self;
}


Parser* parser_new (const gchar* input, gint number_base, gint wordlen, AngleUnit angle_units) {
	return parser_construct (TYPE_PARSER, input, number_base, wordlen, angle_units);
}


gboolean parser_create_parse_tree (Parser* self, guint* representation_base, ErrorCode* error_code, gchar** error_token, guint* error_start, guint* error_end) {
	guint _vala_representation_base = 0U;
	ErrorCode _vala_error_code = 0;
	gchar* _vala_error_token = NULL;
	guint _vala_error_start = 0U;
	guint _vala_error_end = 0U;
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	Lexer* _tmp1_ = NULL;
	gboolean ret = FALSE;
	gboolean _tmp2_ = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp3_ = NULL;
	LexerToken* _tmp4_ = NULL;
	LexerToken* _tmp5_ = NULL;
	LexerTokenType _tmp6_ = 0;
	LexerToken* _tmp23_ = NULL;
	LexerTokenType _tmp24_ = 0;
	gboolean _tmp37_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->number_base;
	_vala_representation_base = (guint) _tmp0_;
	_tmp1_ = self->priv->lexer;
	lexer_scan (_tmp1_);
	_tmp2_ = parser_statement (self);
	ret = _tmp2_;
	_tmp3_ = self->priv->lexer;
	_tmp4_ = lexer_get_next_token (_tmp3_);
	token = _tmp4_;
	_tmp5_ = token;
	_tmp6_ = _tmp5_->type;
	if (_tmp6_ == LEXER_TOKEN_TYPE_ASSIGN) {
		Lexer* _tmp7_ = NULL;
		LexerToken* _tmp8_ = NULL;
		LexerToken* _tmp9_ = NULL;
		LexerTokenType _tmp10_ = 0;
		_tmp7_ = self->priv->lexer;
		_tmp8_ = lexer_get_next_token (_tmp7_);
		_g_object_unref0 (token);
		token = _tmp8_;
		_tmp9_ = token;
		_tmp10_ = _tmp9_->type;
		if (_tmp10_ != LEXER_TOKEN_TYPE_PL_EOS) {
			ErrorCode _tmp11_ = 0;
			ErrorCode _tmp18_ = 0;
			const gchar* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			gint _tmp21_ = 0;
			gint _tmp22_ = 0;
			_tmp11_ = self->priv->error;
			if (_tmp11_ == ERROR_CODE_NONE) {
				LexerToken* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				LexerToken* _tmp14_ = NULL;
				guint _tmp15_ = 0U;
				LexerToken* _tmp16_ = NULL;
				guint _tmp17_ = 0U;
				_tmp12_ = token;
				_tmp13_ = _tmp12_->text;
				_tmp14_ = token;
				_tmp15_ = _tmp14_->start_index;
				_tmp16_ = token;
				_tmp17_ = _tmp16_->end_index;
				parser_set_error (self, ERROR_CODE_INVALID, _tmp13_, _tmp15_, _tmp17_);
			}
			_tmp18_ = self->priv->error;
			_vala_error_code = _tmp18_;
			_tmp19_ = self->priv->error_token;
			_tmp20_ = g_strdup (_tmp19_);
			_g_free0 (_vala_error_token);
			_vala_error_token = _tmp20_;
			_tmp21_ = self->priv->error_token_start;
			_vala_error_start = (guint) _tmp21_;
			_tmp22_ = self->priv->error_token_end;
			_vala_error_end = (guint) _tmp22_;
			result = FALSE;
			_g_object_unref0 (token);
			if (representation_base) {
				*representation_base = _vala_representation_base;
			}
			if (error_code) {
				*error_code = _vala_error_code;
			}
			if (error_token) {
				*error_token = _vala_error_token;
			} else {
				_g_free0 (_vala_error_token);
			}
			if (error_start) {
				*error_start = _vala_error_start;
			}
			if (error_end) {
				*error_end = _vala_error_end;
			}
			return result;
		}
	}
	_tmp23_ = token;
	_tmp24_ = _tmp23_->type;
	if (_tmp24_ != LEXER_TOKEN_TYPE_PL_EOS) {
		ErrorCode _tmp25_ = 0;
		ErrorCode _tmp32_ = 0;
		const gchar* _tmp33_ = NULL;
		gchar* _tmp34_ = NULL;
		gint _tmp35_ = 0;
		gint _tmp36_ = 0;
		_tmp25_ = self->priv->error;
		if (_tmp25_ == ERROR_CODE_NONE) {
			LexerToken* _tmp26_ = NULL;
			const gchar* _tmp27_ = NULL;
			LexerToken* _tmp28_ = NULL;
			guint _tmp29_ = 0U;
			LexerToken* _tmp30_ = NULL;
			guint _tmp31_ = 0U;
			_tmp26_ = token;
			_tmp27_ = _tmp26_->text;
			_tmp28_ = token;
			_tmp29_ = _tmp28_->start_index;
			_tmp30_ = token;
			_tmp31_ = _tmp30_->end_index;
			parser_set_error (self, ERROR_CODE_INVALID, _tmp27_, _tmp29_, _tmp31_);
		}
		_tmp32_ = self->priv->error;
		_vala_error_code = _tmp32_;
		_tmp33_ = self->priv->error_token;
		_tmp34_ = g_strdup (_tmp33_);
		_g_free0 (_vala_error_token);
		_vala_error_token = _tmp34_;
		_tmp35_ = self->priv->error_token_start;
		_vala_error_start = (guint) _tmp35_;
		_tmp36_ = self->priv->error_token_end;
		_vala_error_end = (guint) _tmp36_;
		result = FALSE;
		_g_object_unref0 (token);
		if (representation_base) {
			*representation_base = _vala_representation_base;
		}
		if (error_code) {
			*error_code = _vala_error_code;
		}
		if (error_token) {
			*error_token = _vala_error_token;
		} else {
			_g_free0 (_vala_error_token);
		}
		if (error_start) {
			*error_start = _vala_error_start;
		}
		if (error_end) {
			*error_end = _vala_error_end;
		}
		return result;
	}
	_tmp37_ = ret;
	if (!_tmp37_) {
		ErrorCode _tmp38_ = 0;
		ErrorCode _tmp39_ = 0;
		const gchar* _tmp40_ = NULL;
		gchar* _tmp41_ = NULL;
		gint _tmp42_ = 0;
		gint _tmp43_ = 0;
		_tmp38_ = self->priv->error;
		if (_tmp38_ == ERROR_CODE_NONE) {
			parser_set_error (self, ERROR_CODE_INVALID, NULL, (guint) 0, (guint) 0);
		}
		_tmp39_ = self->priv->error;
		_vala_error_code = _tmp39_;
		_tmp40_ = self->priv->error_token;
		_tmp41_ = g_strdup (_tmp40_);
		_g_free0 (_vala_error_token);
		_vala_error_token = _tmp41_;
		_tmp42_ = self->priv->error_token_start;
		_vala_error_start = (guint) _tmp42_;
		_tmp43_ = self->priv->error_token_end;
		_vala_error_end = (guint) _tmp43_;
		result = FALSE;
		_g_object_unref0 (token);
		if (representation_base) {
			*representation_base = _vala_representation_base;
		}
		if (error_code) {
			*error_code = _vala_error_code;
		}
		if (error_token) {
			*error_token = _vala_error_token;
		} else {
			_g_free0 (_vala_error_token);
		}
		if (error_start) {
			*error_start = _vala_error_start;
		}
		if (error_end) {
			*error_end = _vala_error_end;
		}
		return result;
	}
	_vala_error_code = ERROR_CODE_NONE;
	_g_free0 (_vala_error_token);
	_vala_error_token = NULL;
	_vala_error_start = (guint) 0;
	_vala_error_end = (guint) 0;
	result = TRUE;
	_g_object_unref0 (token);
	if (representation_base) {
		*representation_base = _vala_representation_base;
	}
	if (error_code) {
		*error_code = _vala_error_code;
	}
	if (error_token) {
		*error_token = _vala_error_token;
	} else {
		_g_free0 (_vala_error_token);
	}
	if (error_start) {
		*error_start = _vala_error_start;
	}
	if (error_end) {
		*error_end = _vala_error_end;
	}
	return result;
}


void parser_set_error (Parser* self, ErrorCode errorno, const gchar* token, guint token_start, guint token_end) {
	ErrorCode _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	gint _tmp5_ = 0;
	const gchar* _tmp6_ = NULL;
	guint _tmp7_ = 0U;
	gint _tmp8_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = errorno;
	self->priv->error = _tmp0_;
	_tmp1_ = token;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->priv->error_token);
	self->priv->error_token = _tmp2_;
	_tmp3_ = self->priv->input;
	_tmp4_ = token_start;
	_tmp5_ = g_utf8_strlen (_tmp3_, (gssize) _tmp4_);
	self->priv->error_token_start = _tmp5_;
	_tmp6_ = self->priv->input;
	_tmp7_ = token_end;
	_tmp8_ = g_utf8_strlen (_tmp6_, (gssize) _tmp7_);
	self->priv->error_token_end = _tmp8_;
}


void parser_set_representation_base (Parser* self, guint new_base) {
	guint _tmp0_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = new_base;
	self->priv->representation_base = _tmp0_;
}


static gboolean parser_real_variable_is_defined (Parser* self, const gchar* name) {
	gboolean result = FALSE;
	g_return_val_if_fail (name != NULL, FALSE);
	result = FALSE;
	return result;
}


gboolean parser_variable_is_defined (Parser* self, const gchar* name) {
	g_return_val_if_fail (self != NULL, FALSE);
	return PARSER_GET_CLASS (self)->variable_is_defined (self, name);
}


static Number* parser_real_get_variable (Parser* self, const gchar* name) {
	Number* result = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	result = NULL;
	return result;
}


Number* parser_get_variable (Parser* self, const gchar* name) {
	g_return_val_if_fail (self != NULL, NULL);
	return PARSER_GET_CLASS (self)->get_variable (self, name);
}


static void parser_real_set_variable (Parser* self, const gchar* name, Number* x) {
	g_return_if_fail (name != NULL);
	g_return_if_fail (x != NULL);
}


void parser_set_variable (Parser* self, const gchar* name, Number* x) {
	g_return_if_fail (self != NULL);
	PARSER_GET_CLASS (self)->set_variable (self, name, x);
}


static gboolean parser_real_function_is_defined (Parser* self, const gchar* name) {
	gboolean result = FALSE;
	g_return_val_if_fail (name != NULL, FALSE);
	result = FALSE;
	return result;
}


gboolean parser_function_is_defined (Parser* self, const gchar* name) {
	g_return_val_if_fail (self != NULL, FALSE);
	return PARSER_GET_CLASS (self)->function_is_defined (self, name);
}


static Number* parser_real_convert (Parser* self, Number* x, const gchar* x_units, const gchar* z_units) {
	Number* result = NULL;
	g_return_val_if_fail (x != NULL, NULL);
	g_return_val_if_fail (x_units != NULL, NULL);
	g_return_val_if_fail (z_units != NULL, NULL);
	result = NULL;
	return result;
}


Number* parser_convert (Parser* self, Number* x, const gchar* x_units, const gchar* z_units) {
	g_return_val_if_fail (self != NULL, NULL);
	return PARSER_GET_CLASS (self)->convert (self, x, x_units, z_units);
}


Number* parser_parse (Parser* self, guint* representation_base, ErrorCode* error_code, gchar** error_token, guint* error_start, guint* error_end) {
	guint _vala_representation_base = 0U;
	ErrorCode _vala_error_code = 0;
	gchar* _vala_error_token = NULL;
	guint _vala_error_start = 0U;
	guint _vala_error_end = 0U;
	Number* result = NULL;
	gboolean is_successfully_parsed = FALSE;
	guint _tmp0_ = 0U;
	ErrorCode _tmp1_ = 0;
	gchar* _tmp2_ = NULL;
	guint _tmp3_ = 0U;
	guint _tmp4_ = 0U;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	Number* ans = NULL;
	ParseNode* _tmp7_ = NULL;
	Number* _tmp8_ = NULL;
	Number* _tmp9_ = NULL;
	guint _tmp12_ = 0U;
	ErrorCode _tmp13_ = 0;
	const gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp5_ = parser_create_parse_tree (self, &_tmp0_, &_tmp1_, &_tmp2_, &_tmp3_, &_tmp4_);
	_vala_representation_base = _tmp0_;
	_vala_error_code = _tmp1_;
	_g_free0 (_vala_error_token);
	_vala_error_token = _tmp2_;
	_vala_error_start = _tmp3_;
	_vala_error_end = _tmp4_;
	is_successfully_parsed = _tmp5_;
	_tmp6_ = is_successfully_parsed;
	if (!_tmp6_) {
		result = NULL;
		if (representation_base) {
			*representation_base = _vala_representation_base;
		}
		if (error_code) {
			*error_code = _vala_error_code;
		}
		if (error_token) {
			*error_token = _vala_error_token;
		} else {
			_g_free0 (_vala_error_token);
		}
		if (error_start) {
			*error_start = _vala_error_start;
		}
		if (error_end) {
			*error_end = _vala_error_end;
		}
		return result;
	}
	_tmp7_ = self->priv->root;
	_tmp8_ = parse_node_solve (_tmp7_);
	ans = _tmp8_;
	_tmp9_ = ans;
	if (_tmp9_ == NULL) {
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		_vala_error_code = ERROR_CODE_INVALID;
		_g_free0 (_vala_error_token);
		_vala_error_token = NULL;
		_tmp10_ = self->priv->error_token_start;
		_vala_error_start = (guint) _tmp10_;
		_tmp11_ = self->priv->error_token_end;
		_vala_error_end = (guint) _tmp11_;
		result = NULL;
		_g_object_unref0 (ans);
		if (representation_base) {
			*representation_base = _vala_representation_base;
		}
		if (error_code) {
			*error_code = _vala_error_code;
		}
		if (error_token) {
			*error_token = _vala_error_token;
		} else {
			_g_free0 (_vala_error_token);
		}
		if (error_start) {
			*error_start = _vala_error_start;
		}
		if (error_end) {
			*error_end = _vala_error_end;
		}
		return result;
	}
	_tmp12_ = self->priv->representation_base;
	_vala_representation_base = _tmp12_;
	_tmp13_ = self->priv->error;
	_vala_error_code = _tmp13_;
	_tmp14_ = self->priv->error_token;
	_tmp15_ = g_strdup (_tmp14_);
	_g_free0 (_vala_error_token);
	_vala_error_token = _tmp15_;
	_tmp16_ = self->priv->error_token_start;
	_vala_error_start = (guint) _tmp16_;
	_tmp17_ = self->priv->error_token_end;
	_vala_error_end = (guint) _tmp17_;
	result = ans;
	if (representation_base) {
		*representation_base = _vala_representation_base;
	}
	if (error_code) {
		*error_code = _vala_error_code;
	}
	if (error_token) {
		*error_token = _vala_error_token;
	} else {
		_g_free0 (_vala_error_token);
	}
	if (error_start) {
		*error_start = _vala_error_start;
	}
	if (error_end) {
		*error_end = _vala_error_end;
	}
	return result;
}


static Precedence parser_get_precedence (Parser* self, LexerTokenType type) {
	Precedence result = 0;
	gboolean _tmp0_ = FALSE;
	LexerTokenType _tmp1_ = 0;
	LexerTokenType _tmp3_ = 0;
	LexerTokenType _tmp4_ = 0;
	LexerTokenType _tmp5_ = 0;
	LexerTokenType _tmp6_ = 0;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp8_ = FALSE;
	LexerTokenType _tmp9_ = 0;
	LexerTokenType _tmp12_ = 0;
	gboolean _tmp13_ = FALSE;
	gboolean _tmp14_ = FALSE;
	LexerTokenType _tmp15_ = 0;
	LexerTokenType _tmp18_ = 0;
	LexerTokenType _tmp19_ = 0;
	LexerTokenType _tmp20_ = 0;
	gboolean _tmp21_ = FALSE;
	LexerTokenType _tmp22_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp1_ = type;
	if (_tmp1_ == LEXER_TOKEN_TYPE_ADD) {
		_tmp0_ = TRUE;
	} else {
		LexerTokenType _tmp2_ = 0;
		_tmp2_ = type;
		_tmp0_ = _tmp2_ == LEXER_TOKEN_TYPE_SUBTRACT;
	}
	if (_tmp0_) {
		result = PRECEDENCE_ADD_SUBTRACT;
		return result;
	}
	_tmp3_ = type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_MULTIPLY) {
		result = PRECEDENCE_MULTIPLY;
		return result;
	}
	_tmp4_ = type;
	if (_tmp4_ == LEXER_TOKEN_TYPE_MOD) {
		result = PRECEDENCE_MOD;
		return result;
	}
	_tmp5_ = type;
	if (_tmp5_ == LEXER_TOKEN_TYPE_DIVIDE) {
		result = PRECEDENCE_DIVIDE;
		return result;
	}
	_tmp6_ = type;
	if (_tmp6_ == LEXER_TOKEN_TYPE_NOT) {
		result = PRECEDENCE_NOT;
		return result;
	}
	_tmp9_ = type;
	if (_tmp9_ == LEXER_TOKEN_TYPE_ROOT) {
		_tmp8_ = TRUE;
	} else {
		LexerTokenType _tmp10_ = 0;
		_tmp10_ = type;
		_tmp8_ = _tmp10_ == LEXER_TOKEN_TYPE_ROOT_3;
	}
	if (_tmp8_) {
		_tmp7_ = TRUE;
	} else {
		LexerTokenType _tmp11_ = 0;
		_tmp11_ = type;
		_tmp7_ = _tmp11_ == LEXER_TOKEN_TYPE_ROOT_4;
	}
	if (_tmp7_) {
		result = PRECEDENCE_ROOT;
		return result;
	}
	_tmp12_ = type;
	if (_tmp12_ == LEXER_TOKEN_TYPE_FUNCTION) {
		result = PRECEDENCE_FUNCTION;
		return result;
	}
	_tmp15_ = type;
	if (_tmp15_ == LEXER_TOKEN_TYPE_AND) {
		_tmp14_ = TRUE;
	} else {
		LexerTokenType _tmp16_ = 0;
		_tmp16_ = type;
		_tmp14_ = _tmp16_ == LEXER_TOKEN_TYPE_OR;
	}
	if (_tmp14_) {
		_tmp13_ = TRUE;
	} else {
		LexerTokenType _tmp17_ = 0;
		_tmp17_ = type;
		_tmp13_ = _tmp17_ == LEXER_TOKEN_TYPE_XOR;
	}
	if (_tmp13_) {
		result = PRECEDENCE_BOOLEAN;
		return result;
	}
	_tmp18_ = type;
	if (_tmp18_ == LEXER_TOKEN_TYPE_PERCENTAGE) {
		result = PRECEDENCE_PERCENTAGE;
		return result;
	}
	_tmp19_ = type;
	if (_tmp19_ == LEXER_TOKEN_TYPE_POWER) {
		result = PRECEDENCE_POWER;
		return result;
	}
	_tmp20_ = type;
	if (_tmp20_ == LEXER_TOKEN_TYPE_FACTORIAL) {
		result = PRECEDENCE_FACTORIAL;
		return result;
	}
	_tmp22_ = type;
	if (_tmp22_ == LEXER_TOKEN_TYPE_NUMBER) {
		_tmp21_ = TRUE;
	} else {
		LexerTokenType _tmp23_ = 0;
		_tmp23_ = type;
		_tmp21_ = _tmp23_ == LEXER_TOKEN_TYPE_VARIABLE;
	}
	if (_tmp21_) {
		result = PRECEDENCE_NUMBER_VARIABLE;
		return result;
	}
	result = PRECEDENCE_UNKNOWN;
	return result;
}


static Associativity parser_get_associativity_p (Parser* self, Precedence type) {
	Associativity result = 0;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	Precedence _tmp4_ = 0;
	Precedence _tmp9_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp4_ = type;
	if (_tmp4_ == PRECEDENCE_BOOLEAN) {
		_tmp3_ = TRUE;
	} else {
		Precedence _tmp5_ = 0;
		_tmp5_ = type;
		_tmp3_ = _tmp5_ == PRECEDENCE_DIVIDE;
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		Precedence _tmp6_ = 0;
		_tmp6_ = type;
		_tmp2_ = _tmp6_ == PRECEDENCE_MOD;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		Precedence _tmp7_ = 0;
		_tmp7_ = type;
		_tmp1_ = _tmp7_ == PRECEDENCE_MULTIPLY;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		Precedence _tmp8_ = 0;
		_tmp8_ = type;
		_tmp0_ = _tmp8_ == PRECEDENCE_ADD_SUBTRACT;
	}
	if (_tmp0_) {
		result = ASSOCIATIVITY_LEFT;
		return result;
	}
	_tmp9_ = type;
	if (_tmp9_ == PRECEDENCE_POWER) {
		result = ASSOCIATIVITY_RIGHT;
		return result;
	}
	result = ASSOCIATIVITY_LEFT;
	return result;
}


static Associativity parser_get_associativity (Parser* self, LexerToken* token) {
	Associativity result = 0;
	LexerToken* _tmp0_ = NULL;
	LexerTokenType _tmp1_ = 0;
	Precedence _tmp2_ = 0;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (token != NULL, 0);
	_tmp0_ = token;
	_tmp1_ = _tmp0_->type;
	_tmp2_ = parser_get_precedence (self, _tmp1_);
	_tmp3_ = parser_get_associativity_p (self, _tmp2_);
	result = _tmp3_;
	return result;
}


static guint parser_make_precedence_p (Parser* self, Precedence p) {
	guint result = 0U;
	Precedence _tmp0_ = 0;
	guint _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = p;
	_tmp1_ = self->priv->depth_level;
	result = _tmp0_ + (_tmp1_ * PRECEDENCE_DEPTH);
	return result;
}


static guint parser_make_precedence_t (Parser* self, LexerTokenType type) {
	guint result = 0U;
	LexerTokenType _tmp0_ = 0;
	Precedence _tmp1_ = 0;
	guint _tmp2_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = type;
	_tmp1_ = parser_get_precedence (self, _tmp0_);
	_tmp2_ = self->priv->depth_level;
	result = _tmp1_ + (_tmp2_ * PRECEDENCE_DEPTH);
	return result;
}


static gboolean parser_cmp_nodes (Parser* self, ParseNode* left, ParseNode* right) {
	gboolean result = FALSE;
	ParseNode* _tmp0_ = NULL;
	ParseNode* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	ParseNode* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = left;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = left;
	_tmp2_ = _tmp1_->precedence;
	_tmp3_ = right;
	_tmp4_ = _tmp3_->precedence;
	if (_tmp2_ > _tmp4_) {
		result = TRUE;
		return result;
	} else {
		ParseNode* _tmp5_ = NULL;
		guint _tmp6_ = 0U;
		ParseNode* _tmp7_ = NULL;
		guint _tmp8_ = 0U;
		_tmp5_ = left;
		_tmp6_ = _tmp5_->precedence;
		_tmp7_ = right;
		_tmp8_ = _tmp7_->precedence;
		if (_tmp6_ < _tmp8_) {
			result = FALSE;
			return result;
		} else {
			ParseNode* _tmp9_ = NULL;
			Associativity _tmp10_ = 0;
			_tmp9_ = right;
			_tmp10_ = _tmp9_->associativity;
			result = _tmp10_ != ASSOCIATIVITY_RIGHT;
			return result;
		}
	}
}


static void parser_insert_into_tree_all (Parser* self, ParseNode* node, gboolean unary_function) {
	ParseNode* _tmp0_ = NULL;
	ParseNode* tmp = NULL;
	ParseNode* _tmp5_ = NULL;
	ParseNode* _tmp6_ = NULL;
	gboolean _tmp13_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = self->priv->root;
	if (_tmp0_ == NULL) {
		ParseNode* _tmp1_ = NULL;
		ParseNode* _tmp2_ = NULL;
		ParseNode* _tmp3_ = NULL;
		ParseNode* _tmp4_ = NULL;
		_tmp1_ = node;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_g_object_unref0 (self->priv->root);
		self->priv->root = _tmp2_;
		_tmp3_ = self->priv->root;
		_tmp4_ = _g_object_ref0 (_tmp3_);
		_g_object_unref0 (self->priv->right_most);
		self->priv->right_most = _tmp4_;
		return;
	}
	_tmp5_ = self->priv->right_most;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	tmp = _tmp6_;
	while (TRUE) {
		ParseNode* _tmp7_ = NULL;
		ParseNode* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		ParseNode* _tmp10_ = NULL;
		ParseNode* _tmp11_ = NULL;
		ParseNode* _tmp12_ = NULL;
		_tmp7_ = tmp;
		_tmp8_ = node;
		_tmp9_ = parser_cmp_nodes (self, _tmp7_, _tmp8_);
		if (!_tmp9_) {
			break;
		}
		_tmp10_ = tmp;
		_tmp11_ = _tmp10_->parent;
		_tmp12_ = _g_object_ref0 (_tmp11_);
		_g_object_unref0 (tmp);
		tmp = _tmp12_;
	}
	_tmp13_ = unary_function;
	if (_tmp13_) {
		ParseNode* _tmp14_ = NULL;
		ParseNode* _tmp43_ = NULL;
		ParseNode* _tmp44_ = NULL;
		_tmp14_ = tmp;
		if (_tmp14_ == NULL) {
			ParseNode* _tmp15_ = NULL;
			ParseNode* _tmp16_ = NULL;
			ParseNode* _tmp17_ = NULL;
			ParseNode* _tmp18_ = NULL;
			ParseNode* _tmp19_ = NULL;
			ParseNode* _tmp20_ = NULL;
			ParseNode* _tmp21_ = NULL;
			ParseNode* _tmp22_ = NULL;
			ParseNode* _tmp23_ = NULL;
			_tmp15_ = node;
			_tmp16_ = self->priv->root;
			_tmp17_ = _g_object_ref0 (_tmp16_);
			_g_object_unref0 (_tmp15_->right);
			_tmp15_->right = _tmp17_;
			_tmp18_ = node;
			_tmp19_ = _tmp18_->right;
			_tmp20_ = node;
			_tmp21_ = _g_object_ref0 (_tmp20_);
			_g_object_unref0 (_tmp19_->parent);
			_tmp19_->parent = _tmp21_;
			_tmp22_ = node;
			_tmp23_ = _g_object_ref0 (_tmp22_);
			_g_object_unref0 (self->priv->root);
			self->priv->root = _tmp23_;
		} else {
			ParseNode* _tmp24_ = NULL;
			ParseNode* _tmp25_ = NULL;
			ParseNode* _tmp26_ = NULL;
			ParseNode* _tmp27_ = NULL;
			ParseNode* _tmp28_ = NULL;
			ParseNode* _tmp29_ = NULL;
			ParseNode* _tmp34_ = NULL;
			ParseNode* _tmp35_ = NULL;
			ParseNode* _tmp36_ = NULL;
			ParseNode* _tmp37_ = NULL;
			ParseNode* _tmp38_ = NULL;
			_tmp24_ = node;
			_tmp25_ = tmp;
			_tmp26_ = _tmp25_->right;
			_tmp27_ = _g_object_ref0 (_tmp26_);
			_g_object_unref0 (_tmp24_->right);
			_tmp24_->right = _tmp27_;
			_tmp28_ = node;
			_tmp29_ = _tmp28_->right;
			if (_tmp29_ != NULL) {
				ParseNode* _tmp30_ = NULL;
				ParseNode* _tmp31_ = NULL;
				ParseNode* _tmp32_ = NULL;
				ParseNode* _tmp33_ = NULL;
				_tmp30_ = node;
				_tmp31_ = _tmp30_->right;
				_tmp32_ = node;
				_tmp33_ = _g_object_ref0 (_tmp32_);
				_g_object_unref0 (_tmp31_->parent);
				_tmp31_->parent = _tmp33_;
			}
			_tmp34_ = tmp;
			_tmp35_ = node;
			_tmp36_ = _g_object_ref0 (_tmp35_);
			_g_object_unref0 (_tmp34_->right);
			_tmp34_->right = _tmp36_;
			_tmp37_ = tmp;
			_tmp38_ = _tmp37_->right;
			if (_tmp38_ != NULL) {
				ParseNode* _tmp39_ = NULL;
				ParseNode* _tmp40_ = NULL;
				ParseNode* _tmp41_ = NULL;
				ParseNode* _tmp42_ = NULL;
				_tmp39_ = tmp;
				_tmp40_ = _tmp39_->right;
				_tmp41_ = tmp;
				_tmp42_ = _g_object_ref0 (_tmp41_);
				_g_object_unref0 (_tmp40_->parent);
				_tmp40_->parent = _tmp42_;
			}
		}
		_tmp43_ = node;
		_tmp44_ = _g_object_ref0 (_tmp43_);
		_g_object_unref0 (self->priv->right_most);
		self->priv->right_most = _tmp44_;
		while (TRUE) {
			ParseNode* _tmp45_ = NULL;
			ParseNode* _tmp46_ = NULL;
			ParseNode* _tmp47_ = NULL;
			ParseNode* _tmp48_ = NULL;
			ParseNode* _tmp49_ = NULL;
			_tmp45_ = self->priv->right_most;
			_tmp46_ = _tmp45_->right;
			if (!(_tmp46_ != NULL)) {
				break;
			}
			_tmp47_ = self->priv->right_most;
			_tmp48_ = _tmp47_->right;
			_tmp49_ = _g_object_ref0 (_tmp48_);
			_g_object_unref0 (self->priv->right_most);
			self->priv->right_most = _tmp49_;
		}
	} else {
		ParseNode* _tmp50_ = NULL;
		ParseNode* _tmp79_ = NULL;
		ParseNode* _tmp80_ = NULL;
		_tmp50_ = tmp;
		if (_tmp50_ == NULL) {
			ParseNode* _tmp51_ = NULL;
			ParseNode* _tmp52_ = NULL;
			ParseNode* _tmp53_ = NULL;
			ParseNode* _tmp54_ = NULL;
			ParseNode* _tmp55_ = NULL;
			ParseNode* _tmp56_ = NULL;
			ParseNode* _tmp57_ = NULL;
			ParseNode* _tmp58_ = NULL;
			ParseNode* _tmp59_ = NULL;
			_tmp51_ = node;
			_tmp52_ = self->priv->root;
			_tmp53_ = _g_object_ref0 (_tmp52_);
			_g_object_unref0 (_tmp51_->left);
			_tmp51_->left = _tmp53_;
			_tmp54_ = node;
			_tmp55_ = _tmp54_->left;
			_tmp56_ = node;
			_tmp57_ = _g_object_ref0 (_tmp56_);
			_g_object_unref0 (_tmp55_->parent);
			_tmp55_->parent = _tmp57_;
			_tmp58_ = node;
			_tmp59_ = _g_object_ref0 (_tmp58_);
			_g_object_unref0 (self->priv->root);
			self->priv->root = _tmp59_;
		} else {
			ParseNode* _tmp60_ = NULL;
			ParseNode* _tmp61_ = NULL;
			ParseNode* _tmp62_ = NULL;
			ParseNode* _tmp63_ = NULL;
			ParseNode* _tmp64_ = NULL;
			ParseNode* _tmp65_ = NULL;
			ParseNode* _tmp70_ = NULL;
			ParseNode* _tmp71_ = NULL;
			ParseNode* _tmp72_ = NULL;
			ParseNode* _tmp73_ = NULL;
			ParseNode* _tmp74_ = NULL;
			_tmp60_ = node;
			_tmp61_ = tmp;
			_tmp62_ = _tmp61_->right;
			_tmp63_ = _g_object_ref0 (_tmp62_);
			_g_object_unref0 (_tmp60_->left);
			_tmp60_->left = _tmp63_;
			_tmp64_ = node;
			_tmp65_ = _tmp64_->left;
			if (_tmp65_ != NULL) {
				ParseNode* _tmp66_ = NULL;
				ParseNode* _tmp67_ = NULL;
				ParseNode* _tmp68_ = NULL;
				ParseNode* _tmp69_ = NULL;
				_tmp66_ = node;
				_tmp67_ = _tmp66_->left;
				_tmp68_ = node;
				_tmp69_ = _g_object_ref0 (_tmp68_);
				_g_object_unref0 (_tmp67_->parent);
				_tmp67_->parent = _tmp69_;
			}
			_tmp70_ = tmp;
			_tmp71_ = node;
			_tmp72_ = _g_object_ref0 (_tmp71_);
			_g_object_unref0 (_tmp70_->right);
			_tmp70_->right = _tmp72_;
			_tmp73_ = tmp;
			_tmp74_ = _tmp73_->right;
			if (_tmp74_ != NULL) {
				ParseNode* _tmp75_ = NULL;
				ParseNode* _tmp76_ = NULL;
				ParseNode* _tmp77_ = NULL;
				ParseNode* _tmp78_ = NULL;
				_tmp75_ = tmp;
				_tmp76_ = _tmp75_->right;
				_tmp77_ = tmp;
				_tmp78_ = _g_object_ref0 (_tmp77_);
				_g_object_unref0 (_tmp76_->parent);
				_tmp76_->parent = _tmp78_;
			}
		}
		_tmp79_ = node;
		_tmp80_ = _g_object_ref0 (_tmp79_);
		_g_object_unref0 (self->priv->right_most);
		self->priv->right_most = _tmp80_;
	}
	_g_object_unref0 (tmp);
}


static void parser_insert_into_tree (Parser* self, ParseNode* node) {
	ParseNode* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = node;
	parser_insert_into_tree_all (self, _tmp0_, FALSE);
}


static void parser_insert_into_tree_unary (Parser* self, ParseNode* node) {
	ParseNode* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = node;
	parser_insert_into_tree_all (self, _tmp0_, TRUE);
}


static void parser_destroy_all_nodes (Parser* self, ParseNode* node) {
	ParseNode* _tmp0_ = NULL;
	ParseNode* _tmp1_ = NULL;
	ParseNode* _tmp2_ = NULL;
	ParseNode* _tmp3_ = NULL;
	ParseNode* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = node;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = node;
	_tmp2_ = _tmp1_->left;
	parser_destroy_all_nodes (self, _tmp2_);
	_tmp3_ = node;
	_tmp4_ = _tmp3_->right;
	parser_destroy_all_nodes (self, _tmp4_);
}


static gboolean parser_check_variable (Parser* self, const gchar* name) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gint index = 0;
	gunichar c = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (name != NULL, FALSE);
	_tmp0_ = name;
	_tmp1_ = parser_variable_is_defined (self, _tmp0_);
	if (_tmp1_) {
		result = TRUE;
		return result;
	}
	index = 0;
	while (TRUE) {
		const gchar* _tmp2_ = NULL;
		gunichar _tmp3_ = 0U;
		gboolean _tmp4_ = FALSE;
		gunichar _tmp5_ = 0U;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		gboolean _tmp9_ = FALSE;
		_tmp2_ = name;
		_tmp4_ = string_get_next_char (_tmp2_, &index, &_tmp3_);
		c = _tmp3_;
		if (!_tmp4_) {
			break;
		}
		_tmp5_ = c;
		_tmp6_ = g_unichar_to_string (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = parser_variable_is_defined (self, _tmp7_);
		_tmp9_ = !_tmp8_;
		_g_free0 (_tmp7_);
		if (_tmp9_) {
			result = FALSE;
			return result;
		}
	}
	result = TRUE;
	return result;
}


static gboolean parser_statement (Parser* self) {
	gboolean result = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	LexerToken* _tmp3_ = NULL;
	LexerTokenType _tmp4_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp3_ = token;
	_tmp4_ = _tmp3_->type;
	if (_tmp4_ == LEXER_TOKEN_TYPE_VARIABLE) {
		_tmp2_ = TRUE;
	} else {
		LexerToken* _tmp5_ = NULL;
		LexerTokenType _tmp6_ = 0;
		_tmp5_ = token;
		_tmp6_ = _tmp5_->type;
		_tmp2_ = _tmp6_ == LEXER_TOKEN_TYPE_FUNCTION;
	}
	if (_tmp2_) {
		LexerToken* token_old = NULL;
		LexerToken* _tmp7_ = NULL;
		LexerToken* _tmp8_ = NULL;
		Lexer* _tmp9_ = NULL;
		LexerToken* _tmp10_ = NULL;
		LexerToken* _tmp11_ = NULL;
		LexerTokenType _tmp12_ = 0;
		_tmp7_ = token;
		_tmp8_ = _g_object_ref0 (_tmp7_);
		token_old = _tmp8_;
		_tmp9_ = self->priv->lexer;
		_tmp10_ = lexer_get_next_token (_tmp9_);
		_g_object_unref0 (token);
		token = _tmp10_;
		_tmp11_ = token;
		_tmp12_ = _tmp11_->type;
		if (_tmp12_ == LEXER_TOKEN_TYPE_ASSIGN) {
			LexerToken* _tmp13_ = NULL;
			guint _tmp14_ = 0U;
			LexerToken* _tmp15_ = NULL;
			Associativity _tmp16_ = 0;
			NameNode* _tmp17_ = NULL;
			NameNode* _tmp18_ = NULL;
			LexerToken* _tmp19_ = NULL;
			LexerToken* _tmp20_ = NULL;
			Associativity _tmp21_ = 0;
			AssignNode* _tmp22_ = NULL;
			AssignNode* _tmp23_ = NULL;
			gboolean _tmp24_ = FALSE;
			_tmp13_ = token_old;
			_tmp14_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
			_tmp15_ = token_old;
			_tmp16_ = parser_get_associativity (self, _tmp15_);
			_tmp17_ = name_node_new (self, _tmp13_, _tmp14_, _tmp16_, NULL);
			_tmp18_ = _tmp17_;
			parser_insert_into_tree (self, (ParseNode*) _tmp18_);
			_g_object_unref0 (_tmp18_);
			_tmp19_ = token;
			_tmp20_ = token;
			_tmp21_ = parser_get_associativity (self, _tmp20_);
			_tmp22_ = assign_node_new (self, _tmp19_, (guint) 0, _tmp21_);
			_tmp23_ = _tmp22_;
			parser_insert_into_tree (self, (ParseNode*) _tmp23_);
			_g_object_unref0 (_tmp23_);
			_tmp24_ = parser_expression (self);
			if (!_tmp24_) {
				result = FALSE;
				_g_object_unref0 (token_old);
				_g_object_unref0 (token);
				return result;
			}
			result = TRUE;
			_g_object_unref0 (token_old);
			_g_object_unref0 (token);
			return result;
		} else {
			LexerToken* _tmp25_ = NULL;
			LexerTokenType _tmp26_ = 0;
			_tmp25_ = token;
			_tmp26_ = _tmp25_->type;
			if (_tmp26_ == LEXER_TOKEN_TYPE_IN) {
				gboolean _tmp27_ = FALSE;
				_tmp27_ = parser_check_base (self);
				if (!_tmp27_) {
					Lexer* _tmp28_ = NULL;
					Lexer* _tmp29_ = NULL;
					gboolean _tmp30_ = FALSE;
					Lexer* _tmp31_ = NULL;
					LexerToken* _tmp32_ = NULL;
					LexerToken* _tmp33_ = NULL;
					LexerToken* _tmp34_ = NULL;
					LexerToken* _tmp35_ = NULL;
					Associativity _tmp36_ = 0;
					ConvertNode* _tmp37_ = NULL;
					ConvertNode* _tmp38_ = NULL;
					gboolean _tmp39_ = FALSE;
					_tmp28_ = self->priv->lexer;
					lexer_roll_back (_tmp28_);
					_tmp29_ = self->priv->lexer;
					lexer_roll_back (_tmp29_);
					_tmp30_ = parser_unit (self);
					if (!_tmp30_) {
						result = FALSE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
					_tmp31_ = self->priv->lexer;
					_tmp32_ = lexer_get_next_token (_tmp31_);
					_tmp33_ = _tmp32_;
					_g_object_unref0 (_tmp33_);
					_tmp34_ = token;
					_tmp35_ = token;
					_tmp36_ = parser_get_associativity (self, _tmp35_);
					_tmp37_ = convert_node_new (self, _tmp34_, (guint) 0, _tmp36_);
					_tmp38_ = _tmp37_;
					parser_insert_into_tree (self, (ParseNode*) _tmp38_);
					_g_object_unref0 (_tmp38_);
					_tmp39_ = parser_unit (self);
					if (!_tmp39_) {
						result = FALSE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
					result = TRUE;
					_g_object_unref0 (token_old);
					_g_object_unref0 (token);
					return result;
				} else {
					Lexer* _tmp40_ = NULL;
					LexerToken* _tmp41_ = NULL;
					LexerToken* _tmp42_ = NULL;
					LexerTokenType _tmp43_ = 0;
					_tmp40_ = self->priv->lexer;
					_tmp41_ = lexer_get_next_token (_tmp40_);
					_g_object_unref0 (token);
					token = _tmp41_;
					_tmp42_ = token;
					_tmp43_ = _tmp42_->type;
					if (_tmp43_ == LEXER_TOKEN_TYPE_VARIABLE) {
						LexerToken* _tmp44_ = NULL;
						LexerToken* _tmp45_ = NULL;
						LexerTokenType _tmp46_ = 0;
						guint _tmp47_ = 0U;
						LexerToken* _tmp48_ = NULL;
						Associativity _tmp49_ = 0;
						VariableNode* _tmp50_ = NULL;
						VariableNode* _tmp51_ = NULL;
						LexerToken* _tmp52_ = NULL;
						LexerToken* _tmp53_ = NULL;
						Associativity _tmp54_ = 0;
						LexerToken* _tmp55_ = NULL;
						const gchar* _tmp56_ = NULL;
						ConvertBaseNode* _tmp57_ = NULL;
						ConvertBaseNode* _tmp58_ = NULL;
						_tmp44_ = token_old;
						_tmp45_ = token_old;
						_tmp46_ = _tmp45_->type;
						_tmp47_ = parser_make_precedence_t (self, _tmp46_);
						_tmp48_ = token_old;
						_tmp49_ = parser_get_associativity (self, _tmp48_);
						_tmp50_ = variable_node_new (self, _tmp44_, _tmp47_, _tmp49_);
						_tmp51_ = _tmp50_;
						parser_insert_into_tree (self, (ParseNode*) _tmp51_);
						_g_object_unref0 (_tmp51_);
						_tmp52_ = token;
						_tmp53_ = token;
						_tmp54_ = parser_get_associativity (self, _tmp53_);
						_tmp55_ = token;
						_tmp56_ = _tmp55_->text;
						_tmp57_ = convert_base_node_new (self, _tmp52_, (guint) 0, _tmp54_, _tmp56_);
						_tmp58_ = _tmp57_;
						parser_insert_into_tree (self, (ParseNode*) _tmp58_);
						_g_object_unref0 (_tmp58_);
						result = TRUE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					} else {
						Lexer* _tmp59_ = NULL;
						Lexer* _tmp60_ = NULL;
						Lexer* _tmp61_ = NULL;
						LexerToken* _tmp62_ = NULL;
						const gchar* _tmp63_ = NULL;
						LexerToken* _tmp64_ = NULL;
						guint _tmp65_ = 0U;
						LexerToken* _tmp66_ = NULL;
						guint _tmp67_ = 0U;
						_tmp59_ = self->priv->lexer;
						lexer_roll_back (_tmp59_);
						_tmp60_ = self->priv->lexer;
						lexer_roll_back (_tmp60_);
						_tmp61_ = self->priv->lexer;
						lexer_roll_back (_tmp61_);
						_tmp62_ = token;
						_tmp63_ = _tmp62_->text;
						_tmp64_ = token;
						_tmp65_ = _tmp64_->start_index;
						_tmp66_ = token;
						_tmp67_ = _tmp66_->end_index;
						parser_set_error (self, ERROR_CODE_UNKNOWN_CONVERSION, _tmp63_, _tmp65_, _tmp67_);
						result = FALSE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
				}
			} else {
				LexerToken* _tmp68_ = NULL;
				LexerTokenType _tmp69_ = 0;
				_tmp68_ = token;
				_tmp69_ = _tmp68_->type;
				if (_tmp69_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
					Lexer* _tmp70_ = NULL;
					LexerToken* _tmp71_ = NULL;
					LexerToken* _tmp72_ = NULL;
					LexerTokenType _tmp73_ = 0;
					_tmp70_ = self->priv->lexer;
					_tmp71_ = lexer_get_next_token (_tmp70_);
					_g_object_unref0 (token);
					token = _tmp71_;
					_tmp72_ = token;
					_tmp73_ = _tmp72_->type;
					if (_tmp73_ == LEXER_TOKEN_TYPE_IN) {
						Lexer* _tmp74_ = NULL;
						Lexer* _tmp75_ = NULL;
						Lexer* _tmp76_ = NULL;
						gboolean _tmp77_ = FALSE;
						Lexer* _tmp78_ = NULL;
						LexerToken* _tmp79_ = NULL;
						LexerToken* _tmp80_ = NULL;
						LexerToken* _tmp81_ = NULL;
						LexerToken* _tmp82_ = NULL;
						Associativity _tmp83_ = 0;
						ConvertNode* _tmp84_ = NULL;
						ConvertNode* _tmp85_ = NULL;
						gboolean _tmp86_ = FALSE;
						_tmp74_ = self->priv->lexer;
						lexer_roll_back (_tmp74_);
						_tmp75_ = self->priv->lexer;
						lexer_roll_back (_tmp75_);
						_tmp76_ = self->priv->lexer;
						lexer_roll_back (_tmp76_);
						_tmp77_ = parser_unit (self);
						if (!_tmp77_) {
							result = FALSE;
							_g_object_unref0 (token_old);
							_g_object_unref0 (token);
							return result;
						}
						_tmp78_ = self->priv->lexer;
						_tmp79_ = lexer_get_next_token (_tmp78_);
						_tmp80_ = _tmp79_;
						_g_object_unref0 (_tmp80_);
						_tmp81_ = token;
						_tmp82_ = token;
						_tmp83_ = parser_get_associativity (self, _tmp82_);
						_tmp84_ = convert_node_new (self, _tmp81_, (guint) 0, _tmp83_);
						_tmp85_ = _tmp84_;
						parser_insert_into_tree (self, (ParseNode*) _tmp85_);
						_g_object_unref0 (_tmp85_);
						_tmp86_ = parser_unit (self);
						if (!_tmp86_) {
							result = FALSE;
							_g_object_unref0 (token_old);
							_g_object_unref0 (token);
							return result;
						}
						result = TRUE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					} else {
						Lexer* _tmp87_ = NULL;
						Lexer* _tmp88_ = NULL;
						Lexer* _tmp89_ = NULL;
						gboolean _tmp90_ = FALSE;
						_tmp87_ = self->priv->lexer;
						lexer_roll_back (_tmp87_);
						_tmp88_ = self->priv->lexer;
						lexer_roll_back (_tmp88_);
						_tmp89_ = self->priv->lexer;
						lexer_roll_back (_tmp89_);
						_tmp90_ = parser_expression (self);
						if (!_tmp90_) {
							result = FALSE;
							_g_object_unref0 (token_old);
							_g_object_unref0 (token);
							return result;
						}
						result = TRUE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
				} else {
					Lexer* _tmp91_ = NULL;
					Lexer* _tmp92_ = NULL;
					LexerToken* _tmp93_ = NULL;
					LexerTokenType _tmp94_ = 0;
					gboolean _tmp96_ = FALSE;
					_tmp91_ = self->priv->lexer;
					lexer_roll_back (_tmp91_);
					_tmp92_ = self->priv->lexer;
					lexer_roll_back (_tmp92_);
					_tmp93_ = token;
					_tmp94_ = _tmp93_->type;
					if (_tmp94_ == LEXER_TOKEN_TYPE_L_R_BRACKET) {
						gboolean _tmp95_ = FALSE;
						_tmp95_ = parser_function_definition (self);
						if (_tmp95_) {
							result = TRUE;
							_g_object_unref0 (token_old);
							_g_object_unref0 (token);
							return result;
						}
					}
					_tmp96_ = parser_expression (self);
					if (!_tmp96_) {
						result = FALSE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
					result = TRUE;
					_g_object_unref0 (token_old);
					_g_object_unref0 (token);
					return result;
				}
			}
		}
		_g_object_unref0 (token_old);
	} else {
		LexerToken* _tmp97_ = NULL;
		LexerTokenType _tmp98_ = 0;
		_tmp97_ = token;
		_tmp98_ = _tmp97_->type;
		if (_tmp98_ == LEXER_TOKEN_TYPE_NUMBER) {
			LexerToken* token_old = NULL;
			LexerToken* _tmp99_ = NULL;
			LexerToken* _tmp100_ = NULL;
			Lexer* _tmp101_ = NULL;
			LexerToken* _tmp102_ = NULL;
			LexerToken* _tmp103_ = NULL;
			LexerTokenType _tmp104_ = 0;
			_tmp99_ = token;
			_tmp100_ = _g_object_ref0 (_tmp99_);
			token_old = _tmp100_;
			_tmp101_ = self->priv->lexer;
			_tmp102_ = lexer_get_next_token (_tmp101_);
			_g_object_unref0 (token);
			token = _tmp102_;
			_tmp103_ = token;
			_tmp104_ = _tmp103_->type;
			if (_tmp104_ == LEXER_TOKEN_TYPE_VARIABLE) {
				Lexer* _tmp105_ = NULL;
				LexerToken* _tmp106_ = NULL;
				LexerToken* _tmp107_ = NULL;
				LexerTokenType _tmp108_ = 0;
				_tmp105_ = self->priv->lexer;
				_tmp106_ = lexer_get_next_token (_tmp105_);
				_g_object_unref0 (token);
				token = _tmp106_;
				_tmp107_ = token;
				_tmp108_ = _tmp107_->type;
				if (_tmp108_ == LEXER_TOKEN_TYPE_IN) {
					Lexer* _tmp109_ = NULL;
					Lexer* _tmp110_ = NULL;
					LexerToken* _tmp111_ = NULL;
					LexerToken* _tmp112_ = NULL;
					LexerTokenType _tmp113_ = 0;
					guint _tmp114_ = 0U;
					LexerToken* _tmp115_ = NULL;
					Associativity _tmp116_ = 0;
					ConstantNode* _tmp117_ = NULL;
					ConstantNode* _tmp118_ = NULL;
					gboolean _tmp119_ = FALSE;
					Lexer* _tmp120_ = NULL;
					LexerToken* _tmp121_ = NULL;
					LexerToken* _tmp122_ = NULL;
					LexerToken* _tmp123_ = NULL;
					Associativity _tmp124_ = 0;
					ConvertNumberNode* _tmp125_ = NULL;
					ConvertNumberNode* _tmp126_ = NULL;
					gboolean _tmp127_ = FALSE;
					_tmp109_ = self->priv->lexer;
					lexer_roll_back (_tmp109_);
					_tmp110_ = self->priv->lexer;
					lexer_roll_back (_tmp110_);
					_tmp111_ = token_old;
					_tmp112_ = token_old;
					_tmp113_ = _tmp112_->type;
					_tmp114_ = parser_make_precedence_t (self, _tmp113_);
					_tmp115_ = token;
					_tmp116_ = parser_get_associativity (self, _tmp115_);
					_tmp117_ = constant_node_new (self, _tmp111_, _tmp114_, _tmp116_);
					_tmp118_ = _tmp117_;
					parser_insert_into_tree (self, (ParseNode*) _tmp118_);
					_g_object_unref0 (_tmp118_);
					_tmp119_ = parser_unit (self);
					if (!_tmp119_) {
						result = FALSE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
					_tmp120_ = self->priv->lexer;
					_tmp121_ = lexer_get_next_token (_tmp120_);
					_g_object_unref0 (token);
					token = _tmp121_;
					_tmp122_ = token;
					_tmp123_ = token;
					_tmp124_ = parser_get_associativity (self, _tmp123_);
					_tmp125_ = convert_number_node_new (self, _tmp122_, (guint) 0, _tmp124_);
					_tmp126_ = _tmp125_;
					parser_insert_into_tree (self, (ParseNode*) _tmp126_);
					_g_object_unref0 (_tmp126_);
					_tmp127_ = parser_unit (self);
					if (!_tmp127_) {
						result = FALSE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
					result = TRUE;
					_g_object_unref0 (token_old);
					_g_object_unref0 (token);
					return result;
				} else {
					LexerToken* _tmp128_ = NULL;
					LexerTokenType _tmp129_ = 0;
					_tmp128_ = token;
					_tmp129_ = _tmp128_->type;
					if (_tmp129_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
						Lexer* _tmp130_ = NULL;
						LexerToken* _tmp131_ = NULL;
						LexerToken* _tmp132_ = NULL;
						LexerTokenType _tmp133_ = 0;
						_tmp130_ = self->priv->lexer;
						_tmp131_ = lexer_get_next_token (_tmp130_);
						_g_object_unref0 (token);
						token = _tmp131_;
						_tmp132_ = token;
						_tmp133_ = _tmp132_->type;
						if (_tmp133_ == LEXER_TOKEN_TYPE_IN) {
							Lexer* _tmp134_ = NULL;
							Lexer* _tmp135_ = NULL;
							Lexer* _tmp136_ = NULL;
							LexerToken* _tmp137_ = NULL;
							LexerToken* _tmp138_ = NULL;
							LexerTokenType _tmp139_ = 0;
							guint _tmp140_ = 0U;
							LexerToken* _tmp141_ = NULL;
							Associativity _tmp142_ = 0;
							ConstantNode* _tmp143_ = NULL;
							ConstantNode* _tmp144_ = NULL;
							gboolean _tmp145_ = FALSE;
							Lexer* _tmp146_ = NULL;
							LexerToken* _tmp147_ = NULL;
							LexerToken* _tmp148_ = NULL;
							LexerToken* _tmp149_ = NULL;
							Associativity _tmp150_ = 0;
							ConvertNumberNode* _tmp151_ = NULL;
							ConvertNumberNode* _tmp152_ = NULL;
							gboolean _tmp153_ = FALSE;
							_tmp134_ = self->priv->lexer;
							lexer_roll_back (_tmp134_);
							_tmp135_ = self->priv->lexer;
							lexer_roll_back (_tmp135_);
							_tmp136_ = self->priv->lexer;
							lexer_roll_back (_tmp136_);
							_tmp137_ = token_old;
							_tmp138_ = token_old;
							_tmp139_ = _tmp138_->type;
							_tmp140_ = parser_make_precedence_t (self, _tmp139_);
							_tmp141_ = token;
							_tmp142_ = parser_get_associativity (self, _tmp141_);
							_tmp143_ = constant_node_new (self, _tmp137_, _tmp140_, _tmp142_);
							_tmp144_ = _tmp143_;
							parser_insert_into_tree (self, (ParseNode*) _tmp144_);
							_g_object_unref0 (_tmp144_);
							_tmp145_ = parser_unit (self);
							if (!_tmp145_) {
								result = FALSE;
								_g_object_unref0 (token_old);
								_g_object_unref0 (token);
								return result;
							}
							_tmp146_ = self->priv->lexer;
							_tmp147_ = lexer_get_next_token (_tmp146_);
							_g_object_unref0 (token);
							token = _tmp147_;
							_tmp148_ = token;
							_tmp149_ = token;
							_tmp150_ = parser_get_associativity (self, _tmp149_);
							_tmp151_ = convert_number_node_new (self, _tmp148_, (guint) 0, _tmp150_);
							_tmp152_ = _tmp151_;
							parser_insert_into_tree (self, (ParseNode*) _tmp152_);
							_g_object_unref0 (_tmp152_);
							_tmp153_ = parser_unit (self);
							if (!_tmp153_) {
								result = FALSE;
								_g_object_unref0 (token_old);
								_g_object_unref0 (token);
								return result;
							}
							result = TRUE;
							_g_object_unref0 (token_old);
							_g_object_unref0 (token);
							return result;
						} else {
							Lexer* _tmp154_ = NULL;
							Lexer* _tmp155_ = NULL;
							Lexer* _tmp156_ = NULL;
							Lexer* _tmp157_ = NULL;
							gboolean _tmp158_ = FALSE;
							_tmp154_ = self->priv->lexer;
							lexer_roll_back (_tmp154_);
							_tmp155_ = self->priv->lexer;
							lexer_roll_back (_tmp155_);
							_tmp156_ = self->priv->lexer;
							lexer_roll_back (_tmp156_);
							_tmp157_ = self->priv->lexer;
							lexer_roll_back (_tmp157_);
							_tmp158_ = parser_expression (self);
							if (!_tmp158_) {
								result = FALSE;
								_g_object_unref0 (token_old);
								_g_object_unref0 (token);
								return result;
							}
							result = TRUE;
							_g_object_unref0 (token_old);
							_g_object_unref0 (token);
							return result;
						}
					} else {
						Lexer* _tmp159_ = NULL;
						Lexer* _tmp160_ = NULL;
						Lexer* _tmp161_ = NULL;
						gboolean _tmp162_ = FALSE;
						_tmp159_ = self->priv->lexer;
						lexer_roll_back (_tmp159_);
						_tmp160_ = self->priv->lexer;
						lexer_roll_back (_tmp160_);
						_tmp161_ = self->priv->lexer;
						lexer_roll_back (_tmp161_);
						_tmp162_ = parser_expression (self);
						if (!_tmp162_) {
							result = FALSE;
							_g_object_unref0 (token_old);
							_g_object_unref0 (token);
							return result;
						}
						result = TRUE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
				}
			} else {
				LexerToken* _tmp163_ = NULL;
				LexerTokenType _tmp164_ = 0;
				_tmp163_ = token;
				_tmp164_ = _tmp163_->type;
				if (_tmp164_ == LEXER_TOKEN_TYPE_IN) {
					Lexer* _tmp165_ = NULL;
					LexerToken* _tmp166_ = NULL;
					LexerToken* _tmp167_ = NULL;
					LexerTokenType _tmp168_ = 0;
					_tmp165_ = self->priv->lexer;
					_tmp166_ = lexer_get_next_token (_tmp165_);
					_g_object_unref0 (token);
					token = _tmp166_;
					_tmp167_ = token;
					_tmp168_ = _tmp167_->type;
					if (_tmp168_ == LEXER_TOKEN_TYPE_VARIABLE) {
						LexerToken* _tmp169_ = NULL;
						LexerToken* _tmp170_ = NULL;
						LexerTokenType _tmp171_ = 0;
						guint _tmp172_ = 0U;
						LexerToken* _tmp173_ = NULL;
						Associativity _tmp174_ = 0;
						ConstantNode* _tmp175_ = NULL;
						ConstantNode* _tmp176_ = NULL;
						LexerToken* _tmp177_ = NULL;
						LexerToken* _tmp178_ = NULL;
						Associativity _tmp179_ = 0;
						LexerToken* _tmp180_ = NULL;
						const gchar* _tmp181_ = NULL;
						ConvertBaseNode* _tmp182_ = NULL;
						ConvertBaseNode* _tmp183_ = NULL;
						_tmp169_ = token_old;
						_tmp170_ = token_old;
						_tmp171_ = _tmp170_->type;
						_tmp172_ = parser_make_precedence_t (self, _tmp171_);
						_tmp173_ = token;
						_tmp174_ = parser_get_associativity (self, _tmp173_);
						_tmp175_ = constant_node_new (self, _tmp169_, _tmp172_, _tmp174_);
						_tmp176_ = _tmp175_;
						parser_insert_into_tree (self, (ParseNode*) _tmp176_);
						_g_object_unref0 (_tmp176_);
						_tmp177_ = token;
						_tmp178_ = token;
						_tmp179_ = parser_get_associativity (self, _tmp178_);
						_tmp180_ = token;
						_tmp181_ = _tmp180_->text;
						_tmp182_ = convert_base_node_new (self, _tmp177_, (guint) 0, _tmp179_, _tmp181_);
						_tmp183_ = _tmp182_;
						parser_insert_into_tree (self, (ParseNode*) _tmp183_);
						_g_object_unref0 (_tmp183_);
						result = TRUE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					} else {
						Lexer* _tmp184_ = NULL;
						Lexer* _tmp185_ = NULL;
						Lexer* _tmp186_ = NULL;
						LexerToken* _tmp187_ = NULL;
						const gchar* _tmp188_ = NULL;
						LexerToken* _tmp189_ = NULL;
						guint _tmp190_ = 0U;
						LexerToken* _tmp191_ = NULL;
						guint _tmp192_ = 0U;
						_tmp184_ = self->priv->lexer;
						lexer_roll_back (_tmp184_);
						_tmp185_ = self->priv->lexer;
						lexer_roll_back (_tmp185_);
						_tmp186_ = self->priv->lexer;
						lexer_roll_back (_tmp186_);
						_tmp187_ = token;
						_tmp188_ = _tmp187_->text;
						_tmp189_ = token;
						_tmp190_ = _tmp189_->start_index;
						_tmp191_ = token;
						_tmp192_ = _tmp191_->end_index;
						parser_set_error (self, ERROR_CODE_UNKNOWN_CONVERSION, _tmp188_, _tmp190_, _tmp192_);
						result = FALSE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
				} else {
					Lexer* _tmp193_ = NULL;
					Lexer* _tmp194_ = NULL;
					gboolean _tmp195_ = FALSE;
					_tmp193_ = self->priv->lexer;
					lexer_roll_back (_tmp193_);
					_tmp194_ = self->priv->lexer;
					lexer_roll_back (_tmp194_);
					_tmp195_ = parser_expression (self);
					if (!_tmp195_) {
						result = FALSE;
						_g_object_unref0 (token_old);
						_g_object_unref0 (token);
						return result;
					}
					result = TRUE;
					_g_object_unref0 (token_old);
					_g_object_unref0 (token);
					return result;
				}
			}
			_g_object_unref0 (token_old);
		} else {
			Lexer* _tmp196_ = NULL;
			gboolean _tmp197_ = FALSE;
			_tmp196_ = self->priv->lexer;
			lexer_roll_back (_tmp196_);
			_tmp197_ = parser_expression (self);
			if (!_tmp197_) {
				result = FALSE;
				_g_object_unref0 (token);
				return result;
			}
			result = TRUE;
			_g_object_unref0 (token);
			return result;
		}
	}
	_g_object_unref0 (token);
}


static gboolean parser_function_definition (Parser* self) {
	gboolean result = FALSE;
	gint num_token_parsed = 0;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gchar* function_name = NULL;
	LexerToken* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	Lexer* _tmp6_ = NULL;
	LexerToken* _tmp7_ = NULL;
	LexerToken* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	Lexer* _tmp10_ = NULL;
	LexerToken* _tmp11_ = NULL;
	gint _tmp12_ = 0;
	gchar* argument_list = NULL;
	gchar* _tmp13_ = NULL;
	LexerToken* _tmp26_ = NULL;
	LexerTokenType _tmp27_ = 0;
	LexerToken* assign_token = NULL;
	Lexer* _tmp30_ = NULL;
	LexerToken* _tmp31_ = NULL;
	gint _tmp32_ = 0;
	LexerToken* _tmp33_ = NULL;
	LexerTokenType _tmp34_ = 0;
	gchar* expression = NULL;
	gchar* _tmp37_ = NULL;
	Lexer* _tmp38_ = NULL;
	LexerToken* _tmp39_ = NULL;
	guint _tmp48_ = 0U;
	Associativity _tmp49_ = 0;
	const gchar* _tmp50_ = NULL;
	FunctionNameNode* _tmp51_ = NULL;
	FunctionNameNode* _tmp52_ = NULL;
	guint _tmp53_ = 0U;
	Associativity _tmp54_ = 0;
	FunctionNode* _tmp55_ = NULL;
	FunctionNode* _tmp56_ = NULL;
	guint _tmp57_ = 0U;
	Associativity _tmp58_ = 0;
	const gchar* _tmp59_ = NULL;
	FunctionArgumentsNode* _tmp60_ = NULL;
	FunctionArgumentsNode* _tmp61_ = NULL;
	LexerToken* _tmp62_ = NULL;
	LexerToken* _tmp63_ = NULL;
	Associativity _tmp64_ = 0;
	AssignFunctionNode* _tmp65_ = NULL;
	AssignFunctionNode* _tmp66_ = NULL;
	guint _tmp67_ = 0U;
	Associativity _tmp68_ = 0;
	const gchar* _tmp69_ = NULL;
	FunctionDescriptionNode* _tmp70_ = NULL;
	FunctionDescriptionNode* _tmp71_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	num_token_parsed = 0;
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = num_token_parsed;
	num_token_parsed = _tmp2_ + 1;
	_tmp3_ = token;
	_tmp4_ = _tmp3_->text;
	_tmp5_ = g_strdup (_tmp4_);
	function_name = _tmp5_;
	_tmp6_ = self->priv->lexer;
	_tmp7_ = lexer_get_next_token (_tmp6_);
	_tmp8_ = _tmp7_;
	_g_object_unref0 (_tmp8_);
	_tmp9_ = num_token_parsed;
	num_token_parsed = _tmp9_ + 1;
	_tmp10_ = self->priv->lexer;
	_tmp11_ = lexer_get_next_token (_tmp10_);
	_g_object_unref0 (token);
	token = _tmp11_;
	_tmp12_ = num_token_parsed;
	num_token_parsed = _tmp12_ + 1;
	_tmp13_ = g_strdup ("");
	argument_list = _tmp13_;
	while (TRUE) {
		gboolean _tmp14_ = FALSE;
		LexerToken* _tmp15_ = NULL;
		LexerTokenType _tmp16_ = 0;
		const gchar* _tmp19_ = NULL;
		LexerToken* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		Lexer* _tmp23_ = NULL;
		LexerToken* _tmp24_ = NULL;
		gint _tmp25_ = 0;
		_tmp15_ = token;
		_tmp16_ = _tmp15_->type;
		if (_tmp16_ != LEXER_TOKEN_TYPE_R_R_BRACKET) {
			LexerToken* _tmp17_ = NULL;
			LexerTokenType _tmp18_ = 0;
			_tmp17_ = token;
			_tmp18_ = _tmp17_->type;
			_tmp14_ = _tmp18_ != LEXER_TOKEN_TYPE_PL_EOS;
		} else {
			_tmp14_ = FALSE;
		}
		if (!_tmp14_) {
			break;
		}
		_tmp19_ = argument_list;
		_tmp20_ = token;
		_tmp21_ = _tmp20_->text;
		_tmp22_ = g_strconcat (_tmp19_, _tmp21_, NULL);
		_g_free0 (argument_list);
		argument_list = _tmp22_;
		_tmp23_ = self->priv->lexer;
		_tmp24_ = lexer_get_next_token (_tmp23_);
		_g_object_unref0 (token);
		token = _tmp24_;
		_tmp25_ = num_token_parsed;
		num_token_parsed = _tmp25_ + 1;
	}
	_tmp26_ = token;
	_tmp27_ = _tmp26_->type;
	if (_tmp27_ == LEXER_TOKEN_TYPE_PL_EOS) {
		while (TRUE) {
			gint _tmp28_ = 0;
			Lexer* _tmp29_ = NULL;
			_tmp28_ = num_token_parsed;
			num_token_parsed = _tmp28_ - 1;
			if (!(_tmp28_ > 0)) {
				break;
			}
			_tmp29_ = self->priv->lexer;
			lexer_roll_back (_tmp29_);
		}
		result = FALSE;
		_g_free0 (argument_list);
		_g_free0 (function_name);
		_g_object_unref0 (token);
		return result;
	}
	_tmp30_ = self->priv->lexer;
	_tmp31_ = lexer_get_next_token (_tmp30_);
	assign_token = _tmp31_;
	_tmp32_ = num_token_parsed;
	num_token_parsed = _tmp32_ + 1;
	_tmp33_ = assign_token;
	_tmp34_ = _tmp33_->type;
	if (_tmp34_ != LEXER_TOKEN_TYPE_ASSIGN) {
		while (TRUE) {
			gint _tmp35_ = 0;
			Lexer* _tmp36_ = NULL;
			_tmp35_ = num_token_parsed;
			num_token_parsed = _tmp35_ - 1;
			if (!(_tmp35_ > 0)) {
				break;
			}
			_tmp36_ = self->priv->lexer;
			lexer_roll_back (_tmp36_);
		}
		result = FALSE;
		_g_object_unref0 (assign_token);
		_g_free0 (argument_list);
		_g_free0 (function_name);
		_g_object_unref0 (token);
		return result;
	}
	_tmp37_ = g_strdup ("");
	expression = _tmp37_;
	_tmp38_ = self->priv->lexer;
	_tmp39_ = lexer_get_next_token (_tmp38_);
	_g_object_unref0 (token);
	token = _tmp39_;
	while (TRUE) {
		LexerToken* _tmp40_ = NULL;
		LexerTokenType _tmp41_ = 0;
		const gchar* _tmp42_ = NULL;
		LexerToken* _tmp43_ = NULL;
		const gchar* _tmp44_ = NULL;
		gchar* _tmp45_ = NULL;
		Lexer* _tmp46_ = NULL;
		LexerToken* _tmp47_ = NULL;
		_tmp40_ = token;
		_tmp41_ = _tmp40_->type;
		if (!(_tmp41_ != LEXER_TOKEN_TYPE_PL_EOS)) {
			break;
		}
		_tmp42_ = expression;
		_tmp43_ = token;
		_tmp44_ = _tmp43_->text;
		_tmp45_ = g_strconcat (_tmp42_, _tmp44_, NULL);
		_g_free0 (expression);
		expression = _tmp45_;
		_tmp46_ = self->priv->lexer;
		_tmp47_ = lexer_get_next_token (_tmp46_);
		_g_object_unref0 (token);
		token = _tmp47_;
	}
	_tmp48_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
	_tmp49_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
	_tmp50_ = function_name;
	_tmp51_ = function_name_node_new (self, NULL, _tmp48_, _tmp49_, _tmp50_);
	_tmp52_ = _tmp51_;
	parser_insert_into_tree (self, (ParseNode*) _tmp52_);
	_g_object_unref0 (_tmp52_);
	_tmp53_ = parser_make_precedence_p (self, PRECEDENCE_FUNCTION);
	_tmp54_ = parser_get_associativity_p (self, PRECEDENCE_FUNCTION);
	_tmp55_ = function_node_new (self, NULL, _tmp53_, _tmp54_, NULL);
	_tmp56_ = _tmp55_;
	parser_insert_into_tree (self, (ParseNode*) _tmp56_);
	_g_object_unref0 (_tmp56_);
	_tmp57_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
	_tmp58_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
	_tmp59_ = argument_list;
	_tmp60_ = function_arguments_node_new (self, NULL, _tmp57_, _tmp58_, _tmp59_);
	_tmp61_ = _tmp60_;
	parser_insert_into_tree (self, (ParseNode*) _tmp61_);
	_g_object_unref0 (_tmp61_);
	_tmp62_ = assign_token;
	_tmp63_ = assign_token;
	_tmp64_ = parser_get_associativity (self, _tmp63_);
	_tmp65_ = assign_function_node_new (self, _tmp62_, (guint) 0, _tmp64_);
	_tmp66_ = _tmp65_;
	parser_insert_into_tree (self, (ParseNode*) _tmp66_);
	_g_object_unref0 (_tmp66_);
	_tmp67_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
	_tmp68_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
	_tmp69_ = expression;
	_tmp70_ = function_description_node_new (self, NULL, _tmp67_, _tmp68_, _tmp69_);
	_tmp71_ = _tmp70_;
	parser_insert_into_tree (self, (ParseNode*) _tmp71_);
	_g_object_unref0 (_tmp71_);
	result = TRUE;
	_g_free0 (expression);
	_g_object_unref0 (assign_token);
	_g_free0 (argument_list);
	_g_free0 (function_name);
	_g_object_unref0 (token);
	return result;
}


static gboolean parser_check_base (Parser* self) {
	gboolean result = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	Lexer* _tmp9_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp3_ = _tmp2_ = g_strsplit ("hex,hexadecimal,dec,decimal,oct,octal,bin,binary", ",", 0);
	{
		gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = _tmp3_;
		s_collection_length1 = _vala_array_length (_tmp2_);
		for (s_it = 0; s_it < _vala_array_length (_tmp2_); s_it = s_it + 1) {
			gchar* _tmp4_ = NULL;
			gchar* s = NULL;
			_tmp4_ = g_strdup (s_collection[s_it]);
			s = _tmp4_;
			{
				LexerToken* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				_tmp5_ = token;
				_tmp6_ = _tmp5_->text;
				_tmp7_ = s;
				if (g_strcmp0 (_tmp6_, _tmp7_) == 0) {
					Lexer* _tmp8_ = NULL;
					_tmp8_ = self->priv->lexer;
					lexer_roll_back (_tmp8_);
					result = TRUE;
					_g_free0 (s);
					s_collection = (_vala_array_free (s_collection, s_collection_length1, (GDestroyNotify) g_free), NULL);
					_g_object_unref0 (token);
					return result;
				}
				_g_free0 (s);
			}
		}
		s_collection = (_vala_array_free (s_collection, s_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp9_ = self->priv->lexer;
	lexer_roll_back (_tmp9_);
	result = FALSE;
	_g_object_unref0 (token);
	return result;
}


static gboolean parser_unit (Parser* self) {
	gboolean result = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	LexerToken* _tmp2_ = NULL;
	LexerTokenType _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_VARIABLE) {
		LexerToken* token_old = NULL;
		LexerToken* _tmp4_ = NULL;
		LexerToken* _tmp5_ = NULL;
		Lexer* _tmp6_ = NULL;
		LexerToken* _tmp7_ = NULL;
		LexerToken* _tmp8_ = NULL;
		LexerTokenType _tmp9_ = 0;
		_tmp4_ = token;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		token_old = _tmp5_;
		_tmp6_ = self->priv->lexer;
		_tmp7_ = lexer_get_next_token (_tmp6_);
		_g_object_unref0 (token);
		token = _tmp7_;
		_tmp8_ = token;
		_tmp9_ = _tmp8_->type;
		if (_tmp9_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
			LexerToken* _tmp10_ = NULL;
			LexerToken* _tmp11_ = NULL;
			LexerTokenType _tmp12_ = 0;
			guint _tmp13_ = 0U;
			LexerToken* _tmp14_ = NULL;
			Associativity _tmp15_ = 0;
			LexerToken* _tmp16_ = NULL;
			const gchar* _tmp17_ = NULL;
			LexerToken* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_ = NULL;
			NameNode* _tmp22_ = NULL;
			NameNode* _tmp23_ = NULL;
			_tmp10_ = token_old;
			_tmp11_ = token_old;
			_tmp12_ = _tmp11_->type;
			_tmp13_ = parser_make_precedence_t (self, _tmp12_);
			_tmp14_ = token_old;
			_tmp15_ = parser_get_associativity (self, _tmp14_);
			_tmp16_ = token_old;
			_tmp17_ = _tmp16_->text;
			_tmp18_ = token;
			_tmp19_ = _tmp18_->text;
			_tmp20_ = g_strconcat (_tmp17_, _tmp19_, NULL);
			_tmp21_ = _tmp20_;
			_tmp22_ = name_node_new (self, _tmp10_, _tmp13_, _tmp15_, _tmp21_);
			_tmp23_ = _tmp22_;
			parser_insert_into_tree (self, (ParseNode*) _tmp23_);
			_g_object_unref0 (_tmp23_);
			_g_free0 (_tmp21_);
			result = TRUE;
			_g_object_unref0 (token_old);
			_g_object_unref0 (token);
			return result;
		} else {
			Lexer* _tmp24_ = NULL;
			LexerToken* _tmp25_ = NULL;
			LexerToken* _tmp26_ = NULL;
			LexerTokenType _tmp27_ = 0;
			guint _tmp28_ = 0U;
			LexerToken* _tmp29_ = NULL;
			Associativity _tmp30_ = 0;
			NameNode* _tmp31_ = NULL;
			NameNode* _tmp32_ = NULL;
			_tmp24_ = self->priv->lexer;
			lexer_roll_back (_tmp24_);
			_tmp25_ = token_old;
			_tmp26_ = token_old;
			_tmp27_ = _tmp26_->type;
			_tmp28_ = parser_make_precedence_t (self, _tmp27_);
			_tmp29_ = token_old;
			_tmp30_ = parser_get_associativity (self, _tmp29_);
			_tmp31_ = name_node_new (self, _tmp25_, _tmp28_, _tmp30_, NULL);
			_tmp32_ = _tmp31_;
			parser_insert_into_tree (self, (ParseNode*) _tmp32_);
			_g_object_unref0 (_tmp32_);
			result = TRUE;
			_g_object_unref0 (token_old);
			_g_object_unref0 (token);
			return result;
		}
		_g_object_unref0 (token_old);
	} else {
		Lexer* _tmp33_ = NULL;
		_tmp33_ = self->priv->lexer;
		lexer_roll_back (_tmp33_);
		result = FALSE;
		_g_object_unref0 (token);
		return result;
	}
	_g_object_unref0 (token);
}


static gboolean parser_expression (Parser* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = parser_expression_1 (self);
	if (!_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp1_ = parser_expression_2 (self);
	if (!_tmp1_) {
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean parser_expression_1 (Parser* self) {
	gboolean result = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	LexerToken* _tmp3_ = NULL;
	LexerTokenType _tmp4_ = 0;
	LexerToken* _tmp8_ = NULL;
	LexerTokenType _tmp9_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp3_ = token;
	_tmp4_ = _tmp3_->type;
	if (_tmp4_ == LEXER_TOKEN_TYPE_PL_EOS) {
		_tmp2_ = TRUE;
	} else {
		LexerToken* _tmp5_ = NULL;
		LexerTokenType _tmp6_ = 0;
		_tmp5_ = token;
		_tmp6_ = _tmp5_->type;
		_tmp2_ = _tmp6_ == LEXER_TOKEN_TYPE_ASSIGN;
	}
	if (_tmp2_) {
		Lexer* _tmp7_ = NULL;
		_tmp7_ = self->priv->lexer;
		lexer_roll_back (_tmp7_);
		result = FALSE;
		_g_object_unref0 (token);
		return result;
	}
	_tmp8_ = token;
	_tmp9_ = _tmp8_->type;
	if (_tmp9_ == LEXER_TOKEN_TYPE_L_R_BRACKET) {
		guint _tmp10_ = 0U;
		gboolean _tmp11_ = FALSE;
		Lexer* _tmp12_ = NULL;
		LexerToken* _tmp13_ = NULL;
		LexerToken* _tmp14_ = NULL;
		LexerTokenType _tmp15_ = 0;
		_tmp10_ = self->priv->depth_level;
		self->priv->depth_level = _tmp10_ + 1;
		_tmp11_ = parser_expression (self);
		if (!_tmp11_) {
			result = FALSE;
			_g_object_unref0 (token);
			return result;
		}
		_tmp12_ = self->priv->lexer;
		_tmp13_ = lexer_get_next_token (_tmp12_);
		_g_object_unref0 (token);
		token = _tmp13_;
		_tmp14_ = token;
		_tmp15_ = _tmp14_->type;
		if (_tmp15_ == LEXER_TOKEN_TYPE_R_R_BRACKET) {
			guint _tmp16_ = 0U;
			_tmp16_ = self->priv->depth_level;
			self->priv->depth_level = _tmp16_ - 1;
			result = TRUE;
			_g_object_unref0 (token);
			return result;
		} else {
			result = FALSE;
			_g_object_unref0 (token);
			return result;
		}
	} else {
		LexerToken* _tmp17_ = NULL;
		LexerTokenType _tmp18_ = 0;
		_tmp17_ = token;
		_tmp18_ = _tmp17_->type;
		if (_tmp18_ == LEXER_TOKEN_TYPE_L_S_BRACKET) {
			guint _tmp19_ = 0U;
			LexerToken* _tmp20_ = NULL;
			guint _tmp21_ = 0U;
			LexerToken* _tmp22_ = NULL;
			Associativity _tmp23_ = 0;
			RoundNode* _tmp24_ = NULL;
			RoundNode* _tmp25_ = NULL;
			gboolean _tmp26_ = FALSE;
			Lexer* _tmp27_ = NULL;
			LexerToken* _tmp28_ = NULL;
			LexerToken* _tmp29_ = NULL;
			LexerTokenType _tmp30_ = 0;
			_tmp19_ = self->priv->depth_level;
			self->priv->depth_level = _tmp19_ + 1;
			_tmp20_ = token;
			_tmp21_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
			_tmp22_ = token;
			_tmp23_ = parser_get_associativity (self, _tmp22_);
			_tmp24_ = round_node_new (self, _tmp20_, _tmp21_, _tmp23_);
			_tmp25_ = _tmp24_;
			parser_insert_into_tree_unary (self, (ParseNode*) _tmp25_);
			_g_object_unref0 (_tmp25_);
			_tmp26_ = parser_expression (self);
			if (!_tmp26_) {
				result = FALSE;
				_g_object_unref0 (token);
				return result;
			}
			_tmp27_ = self->priv->lexer;
			_tmp28_ = lexer_get_next_token (_tmp27_);
			_g_object_unref0 (token);
			token = _tmp28_;
			_tmp29_ = token;
			_tmp30_ = _tmp29_->type;
			if (_tmp30_ == LEXER_TOKEN_TYPE_R_S_BRACKET) {
				guint _tmp31_ = 0U;
				_tmp31_ = self->priv->depth_level;
				self->priv->depth_level = _tmp31_ - 1;
				result = TRUE;
				_g_object_unref0 (token);
				return result;
			} else {
				result = FALSE;
				_g_object_unref0 (token);
				return result;
			}
		} else {
			LexerToken* _tmp32_ = NULL;
			LexerTokenType _tmp33_ = 0;
			_tmp32_ = token;
			_tmp33_ = _tmp32_->type;
			if (_tmp33_ == LEXER_TOKEN_TYPE_L_C_BRACKET) {
				guint _tmp34_ = 0U;
				LexerToken* _tmp35_ = NULL;
				guint _tmp36_ = 0U;
				LexerToken* _tmp37_ = NULL;
				Associativity _tmp38_ = 0;
				FractionalComponentNode* _tmp39_ = NULL;
				FractionalComponentNode* _tmp40_ = NULL;
				gboolean _tmp41_ = FALSE;
				Lexer* _tmp42_ = NULL;
				LexerToken* _tmp43_ = NULL;
				LexerToken* _tmp44_ = NULL;
				LexerTokenType _tmp45_ = 0;
				_tmp34_ = self->priv->depth_level;
				self->priv->depth_level = _tmp34_ + 1;
				_tmp35_ = token;
				_tmp36_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
				_tmp37_ = token;
				_tmp38_ = parser_get_associativity (self, _tmp37_);
				_tmp39_ = fractional_component_node_new (self, _tmp35_, _tmp36_, _tmp38_);
				_tmp40_ = _tmp39_;
				parser_insert_into_tree_unary (self, (ParseNode*) _tmp40_);
				_g_object_unref0 (_tmp40_);
				_tmp41_ = parser_expression (self);
				if (!_tmp41_) {
					result = FALSE;
					_g_object_unref0 (token);
					return result;
				}
				_tmp42_ = self->priv->lexer;
				_tmp43_ = lexer_get_next_token (_tmp42_);
				_g_object_unref0 (token);
				token = _tmp43_;
				_tmp44_ = token;
				_tmp45_ = _tmp44_->type;
				if (_tmp45_ == LEXER_TOKEN_TYPE_R_C_BRACKET) {
					guint _tmp46_ = 0U;
					_tmp46_ = self->priv->depth_level;
					self->priv->depth_level = _tmp46_ - 1;
					result = TRUE;
					_g_object_unref0 (token);
					return result;
				} else {
					result = FALSE;
					_g_object_unref0 (token);
					return result;
				}
			} else {
				LexerToken* _tmp47_ = NULL;
				LexerTokenType _tmp48_ = 0;
				_tmp47_ = token;
				_tmp48_ = _tmp47_->type;
				if (_tmp48_ == LEXER_TOKEN_TYPE_ABS) {
					guint _tmp49_ = 0U;
					LexerToken* _tmp50_ = NULL;
					guint _tmp51_ = 0U;
					LexerToken* _tmp52_ = NULL;
					Associativity _tmp53_ = 0;
					AbsoluteValueNode* _tmp54_ = NULL;
					AbsoluteValueNode* _tmp55_ = NULL;
					gboolean _tmp56_ = FALSE;
					Lexer* _tmp57_ = NULL;
					LexerToken* _tmp58_ = NULL;
					LexerToken* _tmp59_ = NULL;
					LexerTokenType _tmp60_ = 0;
					_tmp49_ = self->priv->depth_level;
					self->priv->depth_level = _tmp49_ + 1;
					_tmp50_ = token;
					_tmp51_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
					_tmp52_ = token;
					_tmp53_ = parser_get_associativity (self, _tmp52_);
					_tmp54_ = absolute_value_node_new (self, _tmp50_, _tmp51_, _tmp53_);
					_tmp55_ = _tmp54_;
					parser_insert_into_tree_unary (self, (ParseNode*) _tmp55_);
					_g_object_unref0 (_tmp55_);
					_tmp56_ = parser_expression (self);
					if (!_tmp56_) {
						result = FALSE;
						_g_object_unref0 (token);
						return result;
					}
					_tmp57_ = self->priv->lexer;
					_tmp58_ = lexer_get_next_token (_tmp57_);
					_g_object_unref0 (token);
					token = _tmp58_;
					_tmp59_ = token;
					_tmp60_ = _tmp59_->type;
					if (_tmp60_ == LEXER_TOKEN_TYPE_ABS) {
						guint _tmp61_ = 0U;
						_tmp61_ = self->priv->depth_level;
						self->priv->depth_level = _tmp61_ - 1;
						result = TRUE;
						_g_object_unref0 (token);
						return result;
					} else {
						result = FALSE;
						_g_object_unref0 (token);
						return result;
					}
				} else {
					LexerToken* _tmp62_ = NULL;
					LexerTokenType _tmp63_ = 0;
					_tmp62_ = token;
					_tmp63_ = _tmp62_->type;
					if (_tmp63_ == LEXER_TOKEN_TYPE_NOT) {
						LexerToken* _tmp64_ = NULL;
						guint _tmp65_ = 0U;
						LexerToken* _tmp66_ = NULL;
						Associativity _tmp67_ = 0;
						NotNode* _tmp68_ = NULL;
						NotNode* _tmp69_ = NULL;
						gboolean _tmp70_ = FALSE;
						_tmp64_ = token;
						_tmp65_ = parser_make_precedence_p (self, PRECEDENCE_NOT);
						_tmp66_ = token;
						_tmp67_ = parser_get_associativity (self, _tmp66_);
						_tmp68_ = not_node_new (self, _tmp64_, _tmp65_, _tmp67_);
						_tmp69_ = _tmp68_;
						parser_insert_into_tree_unary (self, (ParseNode*) _tmp69_);
						_g_object_unref0 (_tmp69_);
						_tmp70_ = parser_expression (self);
						if (!_tmp70_) {
							result = FALSE;
							_g_object_unref0 (token);
							return result;
						}
						result = TRUE;
						_g_object_unref0 (token);
						return result;
					} else {
						LexerToken* _tmp71_ = NULL;
						LexerTokenType _tmp72_ = 0;
						_tmp71_ = token;
						_tmp72_ = _tmp71_->type;
						if (_tmp72_ == LEXER_TOKEN_TYPE_NUMBER) {
							LexerToken* _tmp73_ = NULL;
							LexerToken* _tmp74_ = NULL;
							LexerTokenType _tmp75_ = 0;
							guint _tmp76_ = 0U;
							LexerToken* _tmp77_ = NULL;
							Associativity _tmp78_ = 0;
							ConstantNode* _tmp79_ = NULL;
							ConstantNode* _tmp80_ = NULL;
							Lexer* _tmp81_ = NULL;
							LexerToken* _tmp82_ = NULL;
							Lexer* _tmp83_ = NULL;
							gboolean _tmp84_ = FALSE;
							gboolean _tmp85_ = FALSE;
							gboolean _tmp86_ = FALSE;
							gboolean _tmp87_ = FALSE;
							gboolean _tmp88_ = FALSE;
							LexerToken* _tmp89_ = NULL;
							LexerTokenType _tmp90_ = 0;
							_tmp73_ = token;
							_tmp74_ = token;
							_tmp75_ = _tmp74_->type;
							_tmp76_ = parser_make_precedence_t (self, _tmp75_);
							_tmp77_ = token;
							_tmp78_ = parser_get_associativity (self, _tmp77_);
							_tmp79_ = constant_node_new (self, _tmp73_, _tmp76_, _tmp78_);
							_tmp80_ = _tmp79_;
							parser_insert_into_tree (self, (ParseNode*) _tmp80_);
							_g_object_unref0 (_tmp80_);
							_tmp81_ = self->priv->lexer;
							_tmp82_ = lexer_get_next_token (_tmp81_);
							_g_object_unref0 (token);
							token = _tmp82_;
							_tmp83_ = self->priv->lexer;
							lexer_roll_back (_tmp83_);
							_tmp89_ = token;
							_tmp90_ = _tmp89_->type;
							if (_tmp90_ == LEXER_TOKEN_TYPE_FUNCTION) {
								_tmp88_ = TRUE;
							} else {
								LexerToken* _tmp91_ = NULL;
								LexerTokenType _tmp92_ = 0;
								_tmp91_ = token;
								_tmp92_ = _tmp91_->type;
								_tmp88_ = _tmp92_ == LEXER_TOKEN_TYPE_VARIABLE;
							}
							if (_tmp88_) {
								_tmp87_ = TRUE;
							} else {
								LexerToken* _tmp93_ = NULL;
								LexerTokenType _tmp94_ = 0;
								_tmp93_ = token;
								_tmp94_ = _tmp93_->type;
								_tmp87_ = _tmp94_ == LEXER_TOKEN_TYPE_SUB_NUMBER;
							}
							if (_tmp87_) {
								_tmp86_ = TRUE;
							} else {
								LexerToken* _tmp95_ = NULL;
								LexerTokenType _tmp96_ = 0;
								_tmp95_ = token;
								_tmp96_ = _tmp95_->type;
								_tmp86_ = _tmp96_ == LEXER_TOKEN_TYPE_ROOT;
							}
							if (_tmp86_) {
								_tmp85_ = TRUE;
							} else {
								LexerToken* _tmp97_ = NULL;
								LexerTokenType _tmp98_ = 0;
								_tmp97_ = token;
								_tmp98_ = _tmp97_->type;
								_tmp85_ = _tmp98_ == LEXER_TOKEN_TYPE_ROOT_3;
							}
							if (_tmp85_) {
								_tmp84_ = TRUE;
							} else {
								LexerToken* _tmp99_ = NULL;
								LexerTokenType _tmp100_ = 0;
								_tmp99_ = token;
								_tmp100_ = _tmp99_->type;
								_tmp84_ = _tmp100_ == LEXER_TOKEN_TYPE_ROOT_4;
							}
							if (_tmp84_) {
								guint _tmp101_ = 0U;
								Associativity _tmp102_ = 0;
								MultiplyNode* _tmp103_ = NULL;
								MultiplyNode* _tmp104_ = NULL;
								gboolean _tmp105_ = FALSE;
								_tmp101_ = parser_make_precedence_p (self, PRECEDENCE_MULTIPLY);
								_tmp102_ = parser_get_associativity_p (self, PRECEDENCE_MULTIPLY);
								_tmp103_ = multiply_node_new (self, NULL, _tmp101_, _tmp102_);
								_tmp104_ = _tmp103_;
								parser_insert_into_tree (self, (ParseNode*) _tmp104_);
								_g_object_unref0 (_tmp104_);
								_tmp105_ = parser_variable (self);
								if (!_tmp105_) {
									result = FALSE;
									_g_object_unref0 (token);
									return result;
								} else {
									result = TRUE;
									_g_object_unref0 (token);
									return result;
								}
							} else {
								result = TRUE;
								_g_object_unref0 (token);
								return result;
							}
						} else {
							LexerToken* _tmp106_ = NULL;
							LexerTokenType _tmp107_ = 0;
							_tmp106_ = token;
							_tmp107_ = _tmp106_->type;
							if (_tmp107_ == LEXER_TOKEN_TYPE_L_FLOOR) {
								guint _tmp108_ = 0U;
								guint _tmp109_ = 0U;
								Associativity _tmp110_ = 0;
								FloorNode* _tmp111_ = NULL;
								FloorNode* _tmp112_ = NULL;
								gboolean _tmp113_ = FALSE;
								Lexer* _tmp114_ = NULL;
								LexerToken* _tmp115_ = NULL;
								LexerToken* _tmp116_ = NULL;
								LexerTokenType _tmp117_ = 0;
								_tmp108_ = self->priv->depth_level;
								self->priv->depth_level = _tmp108_ + 1;
								_tmp109_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
								_tmp110_ = parser_get_associativity_p (self, PRECEDENCE_UNKNOWN);
								_tmp111_ = floor_node_new (self, NULL, _tmp109_, _tmp110_);
								_tmp112_ = _tmp111_;
								parser_insert_into_tree_unary (self, (ParseNode*) _tmp112_);
								_g_object_unref0 (_tmp112_);
								_tmp113_ = parser_expression (self);
								if (!_tmp113_) {
									result = FALSE;
									_g_object_unref0 (token);
									return result;
								}
								_tmp114_ = self->priv->lexer;
								_tmp115_ = lexer_get_next_token (_tmp114_);
								_g_object_unref0 (token);
								token = _tmp115_;
								_tmp116_ = token;
								_tmp117_ = _tmp116_->type;
								if (_tmp117_ == LEXER_TOKEN_TYPE_R_FLOOR) {
									guint _tmp118_ = 0U;
									_tmp118_ = self->priv->depth_level;
									self->priv->depth_level = _tmp118_ - 1;
									result = TRUE;
									_g_object_unref0 (token);
									return result;
								} else {
									result = FALSE;
									_g_object_unref0 (token);
									return result;
								}
							} else {
								LexerToken* _tmp119_ = NULL;
								LexerTokenType _tmp120_ = 0;
								_tmp119_ = token;
								_tmp120_ = _tmp119_->type;
								if (_tmp120_ == LEXER_TOKEN_TYPE_L_CEILING) {
									guint _tmp121_ = 0U;
									guint _tmp122_ = 0U;
									Associativity _tmp123_ = 0;
									CeilingNode* _tmp124_ = NULL;
									CeilingNode* _tmp125_ = NULL;
									gboolean _tmp126_ = FALSE;
									Lexer* _tmp127_ = NULL;
									LexerToken* _tmp128_ = NULL;
									LexerToken* _tmp129_ = NULL;
									LexerTokenType _tmp130_ = 0;
									_tmp121_ = self->priv->depth_level;
									self->priv->depth_level = _tmp121_ + 1;
									_tmp122_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
									_tmp123_ = parser_get_associativity_p (self, PRECEDENCE_UNKNOWN);
									_tmp124_ = ceiling_node_new (self, NULL, _tmp122_, _tmp123_);
									_tmp125_ = _tmp124_;
									parser_insert_into_tree_unary (self, (ParseNode*) _tmp125_);
									_g_object_unref0 (_tmp125_);
									_tmp126_ = parser_expression (self);
									if (!_tmp126_) {
										result = FALSE;
										_g_object_unref0 (token);
										return result;
									}
									_tmp127_ = self->priv->lexer;
									_tmp128_ = lexer_get_next_token (_tmp127_);
									_g_object_unref0 (token);
									token = _tmp128_;
									_tmp129_ = token;
									_tmp130_ = _tmp129_->type;
									if (_tmp130_ == LEXER_TOKEN_TYPE_R_CEILING) {
										guint _tmp131_ = 0U;
										_tmp131_ = self->priv->depth_level;
										self->priv->depth_level = _tmp131_ - 1;
										result = TRUE;
										_g_object_unref0 (token);
										return result;
									} else {
										result = FALSE;
										_g_object_unref0 (token);
										return result;
									}
								} else {
									LexerToken* _tmp132_ = NULL;
									LexerTokenType _tmp133_ = 0;
									_tmp132_ = token;
									_tmp133_ = _tmp132_->type;
									if (_tmp133_ == LEXER_TOKEN_TYPE_SUBTRACT) {
										LexerToken* _tmp134_ = NULL;
										guint _tmp135_ = 0U;
										Associativity _tmp136_ = 0;
										UnaryMinusNode* _tmp137_ = NULL;
										UnaryMinusNode* _tmp138_ = NULL;
										gboolean _tmp139_ = FALSE;
										_tmp134_ = token;
										_tmp135_ = parser_make_precedence_p (self, PRECEDENCE_UNARY_MINUS);
										_tmp136_ = parser_get_associativity_p (self, PRECEDENCE_UNARY_MINUS);
										_tmp137_ = unary_minus_node_new (self, _tmp134_, _tmp135_, _tmp136_);
										_tmp138_ = _tmp137_;
										parser_insert_into_tree_unary (self, (ParseNode*) _tmp138_);
										_g_object_unref0 (_tmp138_);
										_tmp139_ = parser_expression_1 (self);
										if (!_tmp139_) {
											result = FALSE;
											_g_object_unref0 (token);
											return result;
										}
										result = TRUE;
										_g_object_unref0 (token);
										return result;
									} else {
										LexerToken* _tmp140_ = NULL;
										LexerTokenType _tmp141_ = 0;
										_tmp140_ = token;
										_tmp141_ = _tmp140_->type;
										if (_tmp141_ == LEXER_TOKEN_TYPE_ADD) {
											Lexer* _tmp142_ = NULL;
											LexerToken* _tmp143_ = NULL;
											LexerToken* _tmp144_ = NULL;
											LexerTokenType _tmp145_ = 0;
											_tmp142_ = self->priv->lexer;
											_tmp143_ = lexer_get_next_token (_tmp142_);
											_g_object_unref0 (token);
											token = _tmp143_;
											_tmp144_ = token;
											_tmp145_ = _tmp144_->type;
											if (_tmp145_ == LEXER_TOKEN_TYPE_NUMBER) {
												LexerToken* _tmp146_ = NULL;
												LexerToken* _tmp147_ = NULL;
												LexerTokenType _tmp148_ = 0;
												guint _tmp149_ = 0U;
												LexerToken* _tmp150_ = NULL;
												Associativity _tmp151_ = 0;
												ConstantNode* _tmp152_ = NULL;
												ConstantNode* _tmp153_ = NULL;
												_tmp146_ = token;
												_tmp147_ = token;
												_tmp148_ = _tmp147_->type;
												_tmp149_ = parser_make_precedence_t (self, _tmp148_);
												_tmp150_ = token;
												_tmp151_ = parser_get_associativity (self, _tmp150_);
												_tmp152_ = constant_node_new (self, _tmp146_, _tmp149_, _tmp151_);
												_tmp153_ = _tmp152_;
												parser_insert_into_tree (self, (ParseNode*) _tmp153_);
												_g_object_unref0 (_tmp153_);
												result = TRUE;
												_g_object_unref0 (token);
												return result;
											} else {
												result = FALSE;
												_g_object_unref0 (token);
												return result;
											}
										} else {
											Lexer* _tmp154_ = NULL;
											gboolean _tmp155_ = FALSE;
											_tmp154_ = self->priv->lexer;
											lexer_roll_back (_tmp154_);
											_tmp155_ = parser_variable (self);
											if (!_tmp155_) {
												result = FALSE;
												_g_object_unref0 (token);
												return result;
											} else {
												result = TRUE;
												_g_object_unref0 (token);
												return result;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_g_object_unref0 (token);
}


static gboolean parser_expression_2 (Parser* self) {
	gboolean result = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	LexerToken* _tmp2_ = NULL;
	LexerTokenType _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_L_R_BRACKET) {
		guint _tmp4_ = 0U;
		Associativity _tmp5_ = 0;
		MultiplyNode* _tmp6_ = NULL;
		MultiplyNode* _tmp7_ = NULL;
		guint _tmp8_ = 0U;
		gboolean _tmp9_ = FALSE;
		Lexer* _tmp10_ = NULL;
		LexerToken* _tmp11_ = NULL;
		LexerToken* _tmp12_ = NULL;
		LexerTokenType _tmp13_ = 0;
		_tmp4_ = parser_make_precedence_p (self, PRECEDENCE_MULTIPLY);
		_tmp5_ = parser_get_associativity_p (self, PRECEDENCE_MULTIPLY);
		_tmp6_ = multiply_node_new (self, NULL, _tmp4_, _tmp5_);
		_tmp7_ = _tmp6_;
		parser_insert_into_tree (self, (ParseNode*) _tmp7_);
		_g_object_unref0 (_tmp7_);
		_tmp8_ = self->priv->depth_level;
		self->priv->depth_level = _tmp8_ + 1;
		_tmp9_ = parser_expression (self);
		if (!_tmp9_) {
			result = FALSE;
			_g_object_unref0 (token);
			return result;
		}
		_tmp10_ = self->priv->lexer;
		_tmp11_ = lexer_get_next_token (_tmp10_);
		_g_object_unref0 (token);
		token = _tmp11_;
		_tmp12_ = token;
		_tmp13_ = _tmp12_->type;
		if (_tmp13_ == LEXER_TOKEN_TYPE_R_R_BRACKET) {
			guint _tmp14_ = 0U;
			gboolean _tmp15_ = FALSE;
			_tmp14_ = self->priv->depth_level;
			self->priv->depth_level = _tmp14_ - 1;
			_tmp15_ = parser_expression_2 (self);
			if (!_tmp15_) {
				result = FALSE;
				_g_object_unref0 (token);
				return result;
			}
			result = TRUE;
			_g_object_unref0 (token);
			return result;
		} else {
			result = FALSE;
			_g_object_unref0 (token);
			return result;
		}
	} else {
		LexerToken* _tmp16_ = NULL;
		LexerTokenType _tmp17_ = 0;
		_tmp16_ = token;
		_tmp17_ = _tmp16_->type;
		if (_tmp17_ == LEXER_TOKEN_TYPE_POWER) {
			LexerToken* _tmp18_ = NULL;
			LexerToken* _tmp19_ = NULL;
			LexerTokenType _tmp20_ = 0;
			guint _tmp21_ = 0U;
			LexerToken* _tmp22_ = NULL;
			Associativity _tmp23_ = 0;
			XPowYNode* _tmp24_ = NULL;
			XPowYNode* _tmp25_ = NULL;
			gboolean _tmp26_ = FALSE;
			gboolean _tmp27_ = FALSE;
			_tmp18_ = token;
			_tmp19_ = token;
			_tmp20_ = _tmp19_->type;
			_tmp21_ = parser_make_precedence_t (self, _tmp20_);
			_tmp22_ = token;
			_tmp23_ = parser_get_associativity (self, _tmp22_);
			_tmp24_ = xpow_ynode_new (self, _tmp18_, _tmp21_, _tmp23_);
			_tmp25_ = _tmp24_;
			parser_insert_into_tree (self, (ParseNode*) _tmp25_);
			_g_object_unref0 (_tmp25_);
			_tmp26_ = parser_expression_1 (self);
			if (!_tmp26_) {
				result = FALSE;
				_g_object_unref0 (token);
				return result;
			}
			_tmp27_ = parser_expression_2 (self);
			if (!_tmp27_) {
				result = FALSE;
				_g_object_unref0 (token);
				return result;
			}
			result = TRUE;
			_g_object_unref0 (token);
			return result;
		} else {
			LexerToken* _tmp28_ = NULL;
			LexerTokenType _tmp29_ = 0;
			_tmp28_ = token;
			_tmp29_ = _tmp28_->type;
			if (_tmp29_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
				guint _tmp30_ = 0U;
				Associativity _tmp31_ = 0;
				XPowYIntegerNode* _tmp32_ = NULL;
				XPowYIntegerNode* _tmp33_ = NULL;
				LexerToken* _tmp34_ = NULL;
				guint _tmp35_ = 0U;
				Associativity _tmp36_ = 0;
				NameNode* _tmp37_ = NULL;
				NameNode* _tmp38_ = NULL;
				gboolean _tmp39_ = FALSE;
				_tmp30_ = parser_make_precedence_p (self, PRECEDENCE_POWER);
				_tmp31_ = parser_get_associativity_p (self, PRECEDENCE_POWER);
				_tmp32_ = xpow_yinteger_node_new (self, NULL, _tmp30_, _tmp31_);
				_tmp33_ = _tmp32_;
				parser_insert_into_tree (self, (ParseNode*) _tmp33_);
				_g_object_unref0 (_tmp33_);
				_tmp34_ = token;
				_tmp35_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
				_tmp36_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
				_tmp37_ = name_node_new (self, _tmp34_, _tmp35_, _tmp36_, NULL);
				_tmp38_ = _tmp37_;
				parser_insert_into_tree (self, (ParseNode*) _tmp38_);
				_g_object_unref0 (_tmp38_);
				_tmp39_ = parser_expression_2 (self);
				if (!_tmp39_) {
					result = FALSE;
					_g_object_unref0 (token);
					return result;
				}
				result = TRUE;
				_g_object_unref0 (token);
				return result;
			} else {
				LexerToken* _tmp40_ = NULL;
				LexerTokenType _tmp41_ = 0;
				_tmp40_ = token;
				_tmp41_ = _tmp40_->type;
				if (_tmp41_ == LEXER_TOKEN_TYPE_NSUP_NUMBER) {
					guint _tmp42_ = 0U;
					Associativity _tmp43_ = 0;
					XPowYIntegerNode* _tmp44_ = NULL;
					XPowYIntegerNode* _tmp45_ = NULL;
					LexerToken* _tmp46_ = NULL;
					guint _tmp47_ = 0U;
					Associativity _tmp48_ = 0;
					NameNode* _tmp49_ = NULL;
					NameNode* _tmp50_ = NULL;
					gboolean _tmp51_ = FALSE;
					_tmp42_ = parser_make_precedence_p (self, PRECEDENCE_POWER);
					_tmp43_ = parser_get_associativity_p (self, PRECEDENCE_POWER);
					_tmp44_ = xpow_yinteger_node_new (self, NULL, _tmp42_, _tmp43_);
					_tmp45_ = _tmp44_;
					parser_insert_into_tree (self, (ParseNode*) _tmp45_);
					_g_object_unref0 (_tmp45_);
					_tmp46_ = token;
					_tmp47_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
					_tmp48_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
					_tmp49_ = name_node_new (self, _tmp46_, _tmp47_, _tmp48_, NULL);
					_tmp50_ = _tmp49_;
					parser_insert_into_tree (self, (ParseNode*) _tmp50_);
					_g_object_unref0 (_tmp50_);
					_tmp51_ = parser_expression_2 (self);
					if (!_tmp51_) {
						result = FALSE;
						_g_object_unref0 (token);
						return result;
					}
					result = TRUE;
					_g_object_unref0 (token);
					return result;
				} else {
					LexerToken* _tmp52_ = NULL;
					LexerTokenType _tmp53_ = 0;
					_tmp52_ = token;
					_tmp53_ = _tmp52_->type;
					if (_tmp53_ == LEXER_TOKEN_TYPE_FACTORIAL) {
						LexerToken* _tmp54_ = NULL;
						LexerToken* _tmp55_ = NULL;
						LexerTokenType _tmp56_ = 0;
						guint _tmp57_ = 0U;
						LexerToken* _tmp58_ = NULL;
						Associativity _tmp59_ = 0;
						FactorialNode* _tmp60_ = NULL;
						FactorialNode* _tmp61_ = NULL;
						gboolean _tmp62_ = FALSE;
						_tmp54_ = token;
						_tmp55_ = token;
						_tmp56_ = _tmp55_->type;
						_tmp57_ = parser_make_precedence_t (self, _tmp56_);
						_tmp58_ = token;
						_tmp59_ = parser_get_associativity (self, _tmp58_);
						_tmp60_ = factorial_node_new (self, _tmp54_, _tmp57_, _tmp59_);
						_tmp61_ = _tmp60_;
						parser_insert_into_tree_unary (self, (ParseNode*) _tmp61_);
						_g_object_unref0 (_tmp61_);
						_tmp62_ = parser_expression_2 (self);
						if (!_tmp62_) {
							result = FALSE;
							_g_object_unref0 (token);
							return result;
						}
						result = TRUE;
						_g_object_unref0 (token);
						return result;
					} else {
						LexerToken* _tmp63_ = NULL;
						LexerTokenType _tmp64_ = 0;
						_tmp63_ = token;
						_tmp64_ = _tmp63_->type;
						if (_tmp64_ == LEXER_TOKEN_TYPE_MULTIPLY) {
							LexerToken* _tmp65_ = NULL;
							LexerToken* _tmp66_ = NULL;
							LexerTokenType _tmp67_ = 0;
							guint _tmp68_ = 0U;
							LexerToken* _tmp69_ = NULL;
							Associativity _tmp70_ = 0;
							MultiplyNode* _tmp71_ = NULL;
							MultiplyNode* _tmp72_ = NULL;
							gboolean _tmp73_ = FALSE;
							gboolean _tmp74_ = FALSE;
							_tmp65_ = token;
							_tmp66_ = token;
							_tmp67_ = _tmp66_->type;
							_tmp68_ = parser_make_precedence_t (self, _tmp67_);
							_tmp69_ = token;
							_tmp70_ = parser_get_associativity (self, _tmp69_);
							_tmp71_ = multiply_node_new (self, _tmp65_, _tmp68_, _tmp70_);
							_tmp72_ = _tmp71_;
							parser_insert_into_tree (self, (ParseNode*) _tmp72_);
							_g_object_unref0 (_tmp72_);
							_tmp73_ = parser_expression_1 (self);
							if (!_tmp73_) {
								result = FALSE;
								_g_object_unref0 (token);
								return result;
							}
							_tmp74_ = parser_expression_2 (self);
							if (!_tmp74_) {
								result = FALSE;
								_g_object_unref0 (token);
								return result;
							}
							result = TRUE;
							_g_object_unref0 (token);
							return result;
						} else {
							LexerToken* _tmp75_ = NULL;
							LexerTokenType _tmp76_ = 0;
							_tmp75_ = token;
							_tmp76_ = _tmp75_->type;
							if (_tmp76_ == LEXER_TOKEN_TYPE_PERCENTAGE) {
								LexerToken* _tmp77_ = NULL;
								LexerToken* _tmp78_ = NULL;
								LexerTokenType _tmp79_ = 0;
								guint _tmp80_ = 0U;
								LexerToken* _tmp81_ = NULL;
								Associativity _tmp82_ = 0;
								PercentNode* _tmp83_ = NULL;
								PercentNode* _tmp84_ = NULL;
								gboolean _tmp85_ = FALSE;
								_tmp77_ = token;
								_tmp78_ = token;
								_tmp79_ = _tmp78_->type;
								_tmp80_ = parser_make_precedence_t (self, _tmp79_);
								_tmp81_ = token;
								_tmp82_ = parser_get_associativity (self, _tmp81_);
								_tmp83_ = percent_node_new (self, _tmp77_, _tmp80_, _tmp82_);
								_tmp84_ = _tmp83_;
								parser_insert_into_tree_unary (self, (ParseNode*) _tmp84_);
								_g_object_unref0 (_tmp84_);
								_tmp85_ = parser_expression_2 (self);
								if (!_tmp85_) {
									result = FALSE;
									_g_object_unref0 (token);
									return result;
								}
								result = TRUE;
								_g_object_unref0 (token);
								return result;
							} else {
								LexerToken* _tmp86_ = NULL;
								LexerTokenType _tmp87_ = 0;
								_tmp86_ = token;
								_tmp87_ = _tmp86_->type;
								if (_tmp87_ == LEXER_TOKEN_TYPE_AND) {
									LexerToken* _tmp88_ = NULL;
									LexerToken* _tmp89_ = NULL;
									LexerTokenType _tmp90_ = 0;
									guint _tmp91_ = 0U;
									LexerToken* _tmp92_ = NULL;
									Associativity _tmp93_ = 0;
									AndNode* _tmp94_ = NULL;
									AndNode* _tmp95_ = NULL;
									gboolean _tmp96_ = FALSE;
									gboolean _tmp97_ = FALSE;
									_tmp88_ = token;
									_tmp89_ = token;
									_tmp90_ = _tmp89_->type;
									_tmp91_ = parser_make_precedence_t (self, _tmp90_);
									_tmp92_ = token;
									_tmp93_ = parser_get_associativity (self, _tmp92_);
									_tmp94_ = and_node_new (self, _tmp88_, _tmp91_, _tmp93_);
									_tmp95_ = _tmp94_;
									parser_insert_into_tree (self, (ParseNode*) _tmp95_);
									_g_object_unref0 (_tmp95_);
									_tmp96_ = parser_expression_1 (self);
									if (!_tmp96_) {
										result = FALSE;
										_g_object_unref0 (token);
										return result;
									}
									_tmp97_ = parser_expression_2 (self);
									if (!_tmp97_) {
										result = FALSE;
										_g_object_unref0 (token);
										return result;
									}
									result = TRUE;
									_g_object_unref0 (token);
									return result;
								} else {
									LexerToken* _tmp98_ = NULL;
									LexerTokenType _tmp99_ = 0;
									_tmp98_ = token;
									_tmp99_ = _tmp98_->type;
									if (_tmp99_ == LEXER_TOKEN_TYPE_OR) {
										LexerToken* _tmp100_ = NULL;
										LexerToken* _tmp101_ = NULL;
										LexerTokenType _tmp102_ = 0;
										guint _tmp103_ = 0U;
										LexerToken* _tmp104_ = NULL;
										Associativity _tmp105_ = 0;
										OrNode* _tmp106_ = NULL;
										OrNode* _tmp107_ = NULL;
										gboolean _tmp108_ = FALSE;
										gboolean _tmp109_ = FALSE;
										_tmp100_ = token;
										_tmp101_ = token;
										_tmp102_ = _tmp101_->type;
										_tmp103_ = parser_make_precedence_t (self, _tmp102_);
										_tmp104_ = token;
										_tmp105_ = parser_get_associativity (self, _tmp104_);
										_tmp106_ = or_node_new (self, _tmp100_, _tmp103_, _tmp105_);
										_tmp107_ = _tmp106_;
										parser_insert_into_tree (self, (ParseNode*) _tmp107_);
										_g_object_unref0 (_tmp107_);
										_tmp108_ = parser_expression_1 (self);
										if (!_tmp108_) {
											result = FALSE;
											_g_object_unref0 (token);
											return result;
										}
										_tmp109_ = parser_expression_2 (self);
										if (!_tmp109_) {
											result = FALSE;
											_g_object_unref0 (token);
											return result;
										}
										result = TRUE;
										_g_object_unref0 (token);
										return result;
									} else {
										LexerToken* _tmp110_ = NULL;
										LexerTokenType _tmp111_ = 0;
										_tmp110_ = token;
										_tmp111_ = _tmp110_->type;
										if (_tmp111_ == LEXER_TOKEN_TYPE_XOR) {
											LexerToken* _tmp112_ = NULL;
											LexerToken* _tmp113_ = NULL;
											LexerTokenType _tmp114_ = 0;
											guint _tmp115_ = 0U;
											LexerToken* _tmp116_ = NULL;
											Associativity _tmp117_ = 0;
											XorNode* _tmp118_ = NULL;
											XorNode* _tmp119_ = NULL;
											gboolean _tmp120_ = FALSE;
											gboolean _tmp121_ = FALSE;
											_tmp112_ = token;
											_tmp113_ = token;
											_tmp114_ = _tmp113_->type;
											_tmp115_ = parser_make_precedence_t (self, _tmp114_);
											_tmp116_ = token;
											_tmp117_ = parser_get_associativity (self, _tmp116_);
											_tmp118_ = xor_node_new (self, _tmp112_, _tmp115_, _tmp117_);
											_tmp119_ = _tmp118_;
											parser_insert_into_tree (self, (ParseNode*) _tmp119_);
											_g_object_unref0 (_tmp119_);
											_tmp120_ = parser_expression_1 (self);
											if (!_tmp120_) {
												result = FALSE;
												_g_object_unref0 (token);
												return result;
											}
											_tmp121_ = parser_expression_2 (self);
											if (!_tmp121_) {
												result = FALSE;
												_g_object_unref0 (token);
												return result;
											}
											result = TRUE;
											_g_object_unref0 (token);
											return result;
										} else {
											LexerToken* _tmp122_ = NULL;
											LexerTokenType _tmp123_ = 0;
											_tmp122_ = token;
											_tmp123_ = _tmp122_->type;
											if (_tmp123_ == LEXER_TOKEN_TYPE_DIVIDE) {
												LexerToken* _tmp124_ = NULL;
												LexerToken* _tmp125_ = NULL;
												LexerTokenType _tmp126_ = 0;
												guint _tmp127_ = 0U;
												LexerToken* _tmp128_ = NULL;
												Associativity _tmp129_ = 0;
												DivideNode* _tmp130_ = NULL;
												DivideNode* _tmp131_ = NULL;
												gboolean _tmp132_ = FALSE;
												gboolean _tmp133_ = FALSE;
												_tmp124_ = token;
												_tmp125_ = token;
												_tmp126_ = _tmp125_->type;
												_tmp127_ = parser_make_precedence_t (self, _tmp126_);
												_tmp128_ = token;
												_tmp129_ = parser_get_associativity (self, _tmp128_);
												_tmp130_ = divide_node_new (self, _tmp124_, _tmp127_, _tmp129_);
												_tmp131_ = _tmp130_;
												parser_insert_into_tree (self, (ParseNode*) _tmp131_);
												_g_object_unref0 (_tmp131_);
												_tmp132_ = parser_expression_1 (self);
												if (!_tmp132_) {
													result = FALSE;
													_g_object_unref0 (token);
													return result;
												}
												_tmp133_ = parser_expression_2 (self);
												if (!_tmp133_) {
													result = FALSE;
													_g_object_unref0 (token);
													return result;
												}
												result = TRUE;
												_g_object_unref0 (token);
												return result;
											} else {
												LexerToken* _tmp134_ = NULL;
												LexerTokenType _tmp135_ = 0;
												_tmp134_ = token;
												_tmp135_ = _tmp134_->type;
												if (_tmp135_ == LEXER_TOKEN_TYPE_MOD) {
													LexerToken* _tmp136_ = NULL;
													LexerToken* _tmp137_ = NULL;
													LexerTokenType _tmp138_ = 0;
													guint _tmp139_ = 0U;
													LexerToken* _tmp140_ = NULL;
													Associativity _tmp141_ = 0;
													ModulusDivideNode* _tmp142_ = NULL;
													ModulusDivideNode* _tmp143_ = NULL;
													gboolean _tmp144_ = FALSE;
													gboolean _tmp145_ = FALSE;
													_tmp136_ = token;
													_tmp137_ = token;
													_tmp138_ = _tmp137_->type;
													_tmp139_ = parser_make_precedence_t (self, _tmp138_);
													_tmp140_ = token;
													_tmp141_ = parser_get_associativity (self, _tmp140_);
													_tmp142_ = modulus_divide_node_new (self, _tmp136_, _tmp139_, _tmp141_);
													_tmp143_ = _tmp142_;
													parser_insert_into_tree (self, (ParseNode*) _tmp143_);
													_g_object_unref0 (_tmp143_);
													_tmp144_ = parser_expression_1 (self);
													if (!_tmp144_) {
														result = FALSE;
														_g_object_unref0 (token);
														return result;
													}
													_tmp145_ = parser_expression_2 (self);
													if (!_tmp145_) {
														result = FALSE;
														_g_object_unref0 (token);
														return result;
													}
													result = TRUE;
													_g_object_unref0 (token);
													return result;
												} else {
													LexerToken* _tmp146_ = NULL;
													LexerTokenType _tmp147_ = 0;
													_tmp146_ = token;
													_tmp147_ = _tmp146_->type;
													if (_tmp147_ == LEXER_TOKEN_TYPE_ADD) {
														AddNode* node = NULL;
														LexerToken* _tmp148_ = NULL;
														LexerToken* _tmp149_ = NULL;
														LexerTokenType _tmp150_ = 0;
														guint _tmp151_ = 0U;
														LexerToken* _tmp152_ = NULL;
														Associativity _tmp153_ = 0;
														AddNode* _tmp154_ = NULL;
														AddNode* _tmp155_ = NULL;
														gboolean _tmp156_ = FALSE;
														Lexer* _tmp157_ = NULL;
														LexerToken* _tmp158_ = NULL;
														LexerToken* _tmp159_ = NULL;
														LexerTokenType _tmp160_ = 0;
														gboolean _tmp169_ = FALSE;
														_tmp148_ = token;
														_tmp149_ = token;
														_tmp150_ = _tmp149_->type;
														_tmp151_ = parser_make_precedence_t (self, _tmp150_);
														_tmp152_ = token;
														_tmp153_ = parser_get_associativity (self, _tmp152_);
														_tmp154_ = add_node_new (self, _tmp148_, _tmp151_, _tmp153_);
														node = _tmp154_;
														_tmp155_ = node;
														parser_insert_into_tree (self, (ParseNode*) _tmp155_);
														_tmp156_ = parser_expression_1 (self);
														if (!_tmp156_) {
															result = FALSE;
															_g_object_unref0 (node);
															_g_object_unref0 (token);
															return result;
														}
														_tmp157_ = self->priv->lexer;
														_tmp158_ = lexer_get_next_token (_tmp157_);
														_g_object_unref0 (token);
														token = _tmp158_;
														_tmp159_ = token;
														_tmp160_ = _tmp159_->type;
														if (_tmp160_ == LEXER_TOKEN_TYPE_PERCENTAGE) {
															AddNode* _tmp161_ = NULL;
															ParseNode* _tmp162_ = NULL;
															guint _tmp163_ = 0U;
															_tmp161_ = node;
															_tmp162_ = ((ParseNode*) _tmp161_)->right;
															_tmp163_ = _tmp162_->precedence;
															if (_tmp163_ > ((guint) PRECEDENCE_PERCENTAGE)) {
																AddNode* _tmp164_ = NULL;
																AddNode* _tmp165_ = NULL;
																_tmp164_ = node;
																((ParseNode*) _tmp164_)->precedence = (guint) PRECEDENCE_PERCENTAGE;
																_tmp165_ = node;
																_tmp165_->do_percentage = TRUE;
																result = TRUE;
																_g_object_unref0 (node);
																_g_object_unref0 (token);
																return result;
															} else {
																Lexer* _tmp166_ = NULL;
																gboolean _tmp167_ = FALSE;
																_tmp166_ = self->priv->lexer;
																lexer_roll_back (_tmp166_);
																_tmp167_ = parser_expression_2 (self);
																if (!_tmp167_) {
																	result = TRUE;
																	_g_object_unref0 (node);
																	_g_object_unref0 (token);
																	return result;
																}
															}
														} else {
															Lexer* _tmp168_ = NULL;
															_tmp168_ = self->priv->lexer;
															lexer_roll_back (_tmp168_);
														}
														_tmp169_ = parser_expression_2 (self);
														if (!_tmp169_) {
															result = FALSE;
															_g_object_unref0 (node);
															_g_object_unref0 (token);
															return result;
														}
														result = TRUE;
														_g_object_unref0 (node);
														_g_object_unref0 (token);
														return result;
													} else {
														LexerToken* _tmp170_ = NULL;
														LexerTokenType _tmp171_ = 0;
														_tmp170_ = token;
														_tmp171_ = _tmp170_->type;
														if (_tmp171_ == LEXER_TOKEN_TYPE_SUBTRACT) {
															SubtractNode* node = NULL;
															LexerToken* _tmp172_ = NULL;
															LexerToken* _tmp173_ = NULL;
															LexerTokenType _tmp174_ = 0;
															guint _tmp175_ = 0U;
															LexerToken* _tmp176_ = NULL;
															Associativity _tmp177_ = 0;
															SubtractNode* _tmp178_ = NULL;
															SubtractNode* _tmp179_ = NULL;
															gboolean _tmp180_ = FALSE;
															Lexer* _tmp181_ = NULL;
															LexerToken* _tmp182_ = NULL;
															LexerToken* _tmp183_ = NULL;
															LexerTokenType _tmp184_ = 0;
															gboolean _tmp193_ = FALSE;
															_tmp172_ = token;
															_tmp173_ = token;
															_tmp174_ = _tmp173_->type;
															_tmp175_ = parser_make_precedence_t (self, _tmp174_);
															_tmp176_ = token;
															_tmp177_ = parser_get_associativity (self, _tmp176_);
															_tmp178_ = subtract_node_new (self, _tmp172_, _tmp175_, _tmp177_);
															node = _tmp178_;
															_tmp179_ = node;
															parser_insert_into_tree (self, (ParseNode*) _tmp179_);
															_tmp180_ = parser_expression_1 (self);
															if (!_tmp180_) {
																result = FALSE;
																_g_object_unref0 (node);
																_g_object_unref0 (token);
																return result;
															}
															_tmp181_ = self->priv->lexer;
															_tmp182_ = lexer_get_next_token (_tmp181_);
															_g_object_unref0 (token);
															token = _tmp182_;
															_tmp183_ = token;
															_tmp184_ = _tmp183_->type;
															if (_tmp184_ == LEXER_TOKEN_TYPE_PERCENTAGE) {
																SubtractNode* _tmp185_ = NULL;
																ParseNode* _tmp186_ = NULL;
																guint _tmp187_ = 0U;
																_tmp185_ = node;
																_tmp186_ = ((ParseNode*) _tmp185_)->right;
																_tmp187_ = _tmp186_->precedence;
																if (_tmp187_ > ((guint) PRECEDENCE_PERCENTAGE)) {
																	SubtractNode* _tmp188_ = NULL;
																	SubtractNode* _tmp189_ = NULL;
																	_tmp188_ = node;
																	((ParseNode*) _tmp188_)->precedence = (guint) PRECEDENCE_PERCENTAGE;
																	_tmp189_ = node;
																	_tmp189_->do_percentage = TRUE;
																	result = TRUE;
																	_g_object_unref0 (node);
																	_g_object_unref0 (token);
																	return result;
																} else {
																	Lexer* _tmp190_ = NULL;
																	gboolean _tmp191_ = FALSE;
																	_tmp190_ = self->priv->lexer;
																	lexer_roll_back (_tmp190_);
																	_tmp191_ = parser_expression_2 (self);
																	if (!_tmp191_) {
																		result = TRUE;
																		_g_object_unref0 (node);
																		_g_object_unref0 (token);
																		return result;
																	}
																}
															} else {
																Lexer* _tmp192_ = NULL;
																_tmp192_ = self->priv->lexer;
																lexer_roll_back (_tmp192_);
															}
															_tmp193_ = parser_expression_2 (self);
															if (!_tmp193_) {
																result = FALSE;
																_g_object_unref0 (node);
																_g_object_unref0 (token);
																return result;
															}
															result = TRUE;
															_g_object_unref0 (node);
															_g_object_unref0 (token);
															return result;
														} else {
															Lexer* _tmp194_ = NULL;
															_tmp194_ = self->priv->lexer;
															lexer_roll_back (_tmp194_);
															result = TRUE;
															_g_object_unref0 (token);
															return result;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_g_object_unref0 (token);
}


static gboolean parser_variable (Parser* self) {
	gboolean result = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	LexerToken* _tmp2_ = NULL;
	LexerTokenType _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_FUNCTION) {
		Lexer* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		_tmp4_ = self->priv->lexer;
		lexer_roll_back (_tmp4_);
		_tmp5_ = parser_function_invocation (self);
		if (!_tmp5_) {
			result = FALSE;
			_g_object_unref0 (token);
			return result;
		}
		result = TRUE;
		_g_object_unref0 (token);
		return result;
	} else {
		LexerToken* _tmp6_ = NULL;
		LexerTokenType _tmp7_ = 0;
		_tmp6_ = token;
		_tmp7_ = _tmp6_->type;
		if (_tmp7_ == LEXER_TOKEN_TYPE_SUB_NUMBER) {
			LexerToken* token_old = NULL;
			LexerToken* _tmp8_ = NULL;
			LexerToken* _tmp9_ = NULL;
			Lexer* _tmp10_ = NULL;
			LexerToken* _tmp11_ = NULL;
			LexerToken* _tmp12_ = NULL;
			LexerTokenType _tmp13_ = 0;
			_tmp8_ = token;
			_tmp9_ = _g_object_ref0 (_tmp8_);
			token_old = _tmp9_;
			_tmp10_ = self->priv->lexer;
			_tmp11_ = lexer_get_next_token (_tmp10_);
			_g_object_unref0 (token);
			token = _tmp11_;
			_tmp12_ = token;
			_tmp13_ = _tmp12_->type;
			if (_tmp13_ == LEXER_TOKEN_TYPE_ROOT) {
				LexerToken* _tmp14_ = NULL;
				LexerToken* _tmp15_ = NULL;
				LexerTokenType _tmp16_ = 0;
				guint _tmp17_ = 0U;
				LexerToken* _tmp18_ = NULL;
				Associativity _tmp19_ = 0;
				LexerToken* _tmp20_ = NULL;
				const gchar* _tmp21_ = NULL;
				gint _tmp22_ = 0;
				RootNode* _tmp23_ = NULL;
				RootNode* _tmp24_ = NULL;
				gboolean _tmp25_ = FALSE;
				_tmp14_ = token;
				_tmp15_ = token;
				_tmp16_ = _tmp15_->type;
				_tmp17_ = parser_make_precedence_t (self, _tmp16_);
				_tmp18_ = token;
				_tmp19_ = parser_get_associativity (self, _tmp18_);
				_tmp20_ = token_old;
				_tmp21_ = _tmp20_->text;
				_tmp22_ = sub_atoi (_tmp21_);
				_tmp23_ = root_node_new (self, _tmp14_, _tmp17_, _tmp19_, _tmp22_);
				_tmp24_ = _tmp23_;
				parser_insert_into_tree_unary (self, (ParseNode*) _tmp24_);
				_g_object_unref0 (_tmp24_);
				_tmp25_ = parser_expression (self);
				if (!_tmp25_) {
					result = FALSE;
					_g_object_unref0 (token_old);
					_g_object_unref0 (token);
					return result;
				}
				result = TRUE;
				_g_object_unref0 (token_old);
				_g_object_unref0 (token);
				return result;
			} else {
				result = FALSE;
				_g_object_unref0 (token_old);
				_g_object_unref0 (token);
				return result;
			}
			_g_object_unref0 (token_old);
		} else {
			LexerToken* _tmp26_ = NULL;
			LexerTokenType _tmp27_ = 0;
			_tmp26_ = token;
			_tmp27_ = _tmp26_->type;
			if (_tmp27_ == LEXER_TOKEN_TYPE_ROOT) {
				LexerToken* _tmp28_ = NULL;
				LexerToken* _tmp29_ = NULL;
				LexerTokenType _tmp30_ = 0;
				guint _tmp31_ = 0U;
				LexerToken* _tmp32_ = NULL;
				Associativity _tmp33_ = 0;
				RootNode* _tmp34_ = NULL;
				RootNode* _tmp35_ = NULL;
				gboolean _tmp36_ = FALSE;
				_tmp28_ = token;
				_tmp29_ = token;
				_tmp30_ = _tmp29_->type;
				_tmp31_ = parser_make_precedence_t (self, _tmp30_);
				_tmp32_ = token;
				_tmp33_ = parser_get_associativity (self, _tmp32_);
				_tmp34_ = root_node_new (self, _tmp28_, _tmp31_, _tmp33_, 2);
				_tmp35_ = _tmp34_;
				parser_insert_into_tree_unary (self, (ParseNode*) _tmp35_);
				_g_object_unref0 (_tmp35_);
				_tmp36_ = parser_expression (self);
				if (!_tmp36_) {
					result = FALSE;
					_g_object_unref0 (token);
					return result;
				}
				result = TRUE;
				_g_object_unref0 (token);
				return result;
			} else {
				LexerToken* _tmp37_ = NULL;
				LexerTokenType _tmp38_ = 0;
				_tmp37_ = token;
				_tmp38_ = _tmp37_->type;
				if (_tmp38_ == LEXER_TOKEN_TYPE_ROOT_3) {
					LexerToken* _tmp39_ = NULL;
					LexerToken* _tmp40_ = NULL;
					LexerTokenType _tmp41_ = 0;
					guint _tmp42_ = 0U;
					LexerToken* _tmp43_ = NULL;
					Associativity _tmp44_ = 0;
					RootNode* _tmp45_ = NULL;
					RootNode* _tmp46_ = NULL;
					gboolean _tmp47_ = FALSE;
					_tmp39_ = token;
					_tmp40_ = token;
					_tmp41_ = _tmp40_->type;
					_tmp42_ = parser_make_precedence_t (self, _tmp41_);
					_tmp43_ = token;
					_tmp44_ = parser_get_associativity (self, _tmp43_);
					_tmp45_ = root_node_new (self, _tmp39_, _tmp42_, _tmp44_, 3);
					_tmp46_ = _tmp45_;
					parser_insert_into_tree_unary (self, (ParseNode*) _tmp46_);
					_g_object_unref0 (_tmp46_);
					_tmp47_ = parser_expression (self);
					if (!_tmp47_) {
						result = FALSE;
						_g_object_unref0 (token);
						return result;
					}
					result = TRUE;
					_g_object_unref0 (token);
					return result;
				} else {
					LexerToken* _tmp48_ = NULL;
					LexerTokenType _tmp49_ = 0;
					_tmp48_ = token;
					_tmp49_ = _tmp48_->type;
					if (_tmp49_ == LEXER_TOKEN_TYPE_ROOT_4) {
						LexerToken* _tmp50_ = NULL;
						LexerToken* _tmp51_ = NULL;
						LexerTokenType _tmp52_ = 0;
						guint _tmp53_ = 0U;
						LexerToken* _tmp54_ = NULL;
						Associativity _tmp55_ = 0;
						RootNode* _tmp56_ = NULL;
						RootNode* _tmp57_ = NULL;
						gboolean _tmp58_ = FALSE;
						_tmp50_ = token;
						_tmp51_ = token;
						_tmp52_ = _tmp51_->type;
						_tmp53_ = parser_make_precedence_t (self, _tmp52_);
						_tmp54_ = token;
						_tmp55_ = parser_get_associativity (self, _tmp54_);
						_tmp56_ = root_node_new (self, _tmp50_, _tmp53_, _tmp55_, 4);
						_tmp57_ = _tmp56_;
						parser_insert_into_tree_unary (self, (ParseNode*) _tmp57_);
						_g_object_unref0 (_tmp57_);
						_tmp58_ = parser_expression (self);
						if (!_tmp58_) {
							result = FALSE;
							_g_object_unref0 (token);
							return result;
						}
						result = TRUE;
						_g_object_unref0 (token);
						return result;
					} else {
						LexerToken* _tmp59_ = NULL;
						LexerTokenType _tmp60_ = 0;
						_tmp59_ = token;
						_tmp60_ = _tmp59_->type;
						if (_tmp60_ == LEXER_TOKEN_TYPE_VARIABLE) {
							Lexer* _tmp61_ = NULL;
							gboolean _tmp62_ = FALSE;
							_tmp61_ = self->priv->lexer;
							lexer_roll_back (_tmp61_);
							_tmp62_ = parser_term (self);
							if (!_tmp62_) {
								result = FALSE;
								_g_object_unref0 (token);
								return result;
							}
							result = TRUE;
							_g_object_unref0 (token);
							return result;
						} else {
							result = FALSE;
							_g_object_unref0 (token);
							return result;
						}
					}
				}
			}
		}
	}
	_g_object_unref0 (token);
}


static gboolean parser_function_invocation (Parser* self) {
	gboolean result = FALSE;
	guint _tmp0_ = 0U;
	gint num_token_parsed = 0;
	LexerToken* fun_token = NULL;
	Lexer* _tmp1_ = NULL;
	LexerToken* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gchar* function_name = NULL;
	LexerToken* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	guint _tmp7_ = 0U;
	Associativity _tmp8_ = 0;
	const gchar* _tmp9_ = NULL;
	FunctionNameNode* _tmp10_ = NULL;
	FunctionNameNode* _tmp11_ = NULL;
	LexerToken* token = NULL;
	Lexer* _tmp12_ = NULL;
	LexerToken* _tmp13_ = NULL;
	gint _tmp14_ = 0;
	gchar* power = NULL;
	gboolean _tmp15_ = FALSE;
	LexerToken* _tmp16_ = NULL;
	LexerTokenType _tmp17_ = 0;
	LexerToken* _tmp26_ = NULL;
	LexerToken* _tmp27_ = NULL;
	LexerTokenType _tmp28_ = 0;
	guint _tmp29_ = 0U;
	LexerToken* _tmp30_ = NULL;
	Associativity _tmp31_ = 0;
	const gchar* _tmp32_ = NULL;
	FunctionNode* _tmp33_ = NULL;
	FunctionNode* _tmp34_ = NULL;
	LexerToken* _tmp35_ = NULL;
	LexerTokenType _tmp36_ = 0;
	guint _tmp90_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->depth_level;
	self->priv->depth_level = _tmp0_ + 1;
	num_token_parsed = 0;
	_tmp1_ = self->priv->lexer;
	_tmp2_ = lexer_get_next_token (_tmp1_);
	fun_token = _tmp2_;
	_tmp3_ = num_token_parsed;
	num_token_parsed = _tmp3_ + 1;
	_tmp4_ = fun_token;
	_tmp5_ = _tmp4_->text;
	_tmp6_ = g_strdup (_tmp5_);
	function_name = _tmp6_;
	_tmp7_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
	_tmp8_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
	_tmp9_ = function_name;
	_tmp10_ = function_name_node_new (self, NULL, _tmp7_, _tmp8_, _tmp9_);
	_tmp11_ = _tmp10_;
	parser_insert_into_tree (self, (ParseNode*) _tmp11_);
	_g_object_unref0 (_tmp11_);
	_tmp12_ = self->priv->lexer;
	_tmp13_ = lexer_get_next_token (_tmp12_);
	token = _tmp13_;
	_tmp14_ = num_token_parsed;
	num_token_parsed = _tmp14_ + 1;
	power = NULL;
	_tmp16_ = token;
	_tmp17_ = _tmp16_->type;
	if (_tmp17_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
		_tmp15_ = TRUE;
	} else {
		LexerToken* _tmp18_ = NULL;
		LexerTokenType _tmp19_ = 0;
		_tmp18_ = token;
		_tmp19_ = _tmp18_->type;
		_tmp15_ = _tmp19_ == LEXER_TOKEN_TYPE_NSUP_NUMBER;
	}
	if (_tmp15_) {
		LexerToken* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		Lexer* _tmp23_ = NULL;
		LexerToken* _tmp24_ = NULL;
		gint _tmp25_ = 0;
		_tmp20_ = token;
		_tmp21_ = _tmp20_->text;
		_tmp22_ = g_strdup (_tmp21_);
		_g_free0 (power);
		power = _tmp22_;
		_tmp23_ = self->priv->lexer;
		_tmp24_ = lexer_get_next_token (_tmp23_);
		_g_object_unref0 (token);
		token = _tmp24_;
		_tmp25_ = num_token_parsed;
		num_token_parsed = _tmp25_ + 1;
	}
	_tmp26_ = fun_token;
	_tmp27_ = fun_token;
	_tmp28_ = _tmp27_->type;
	_tmp29_ = parser_make_precedence_t (self, _tmp28_);
	_tmp30_ = fun_token;
	_tmp31_ = parser_get_associativity (self, _tmp30_);
	_tmp32_ = power;
	_tmp33_ = function_node_new (self, _tmp26_, _tmp29_, _tmp31_, _tmp32_);
	_tmp34_ = _tmp33_;
	parser_insert_into_tree (self, (ParseNode*) _tmp34_);
	_g_object_unref0 (_tmp34_);
	_tmp35_ = token;
	_tmp36_ = _tmp35_->type;
	if (_tmp36_ == LEXER_TOKEN_TYPE_L_R_BRACKET) {
		Lexer* _tmp37_ = NULL;
		LexerToken* _tmp38_ = NULL;
		gint _tmp39_ = 0;
		gint m_depth = 0;
		gchar* argument_list = NULL;
		gchar* _tmp40_ = NULL;
		LexerToken* _tmp60_ = NULL;
		LexerTokenType _tmp61_ = 0;
		guint _tmp65_ = 0U;
		Associativity _tmp66_ = 0;
		const gchar* _tmp67_ = NULL;
		FunctionArgumentsNode* _tmp68_ = NULL;
		FunctionArgumentsNode* _tmp69_ = NULL;
		_tmp37_ = self->priv->lexer;
		_tmp38_ = lexer_get_next_token (_tmp37_);
		_g_object_unref0 (token);
		token = _tmp38_;
		_tmp39_ = num_token_parsed;
		num_token_parsed = _tmp39_ + 1;
		m_depth = 1;
		_tmp40_ = g_strdup ("");
		argument_list = _tmp40_;
		while (TRUE) {
			gboolean _tmp41_ = FALSE;
			LexerToken* _tmp42_ = NULL;
			LexerTokenType _tmp43_ = 0;
			LexerToken* _tmp46_ = NULL;
			LexerTokenType _tmp47_ = 0;
			const gchar* _tmp53_ = NULL;
			LexerToken* _tmp54_ = NULL;
			const gchar* _tmp55_ = NULL;
			gchar* _tmp56_ = NULL;
			Lexer* _tmp57_ = NULL;
			LexerToken* _tmp58_ = NULL;
			gint _tmp59_ = 0;
			_tmp42_ = token;
			_tmp43_ = _tmp42_->type;
			if (_tmp43_ != LEXER_TOKEN_TYPE_PL_EOS) {
				LexerToken* _tmp44_ = NULL;
				LexerTokenType _tmp45_ = 0;
				_tmp44_ = token;
				_tmp45_ = _tmp44_->type;
				_tmp41_ = _tmp45_ != LEXER_TOKEN_TYPE_ASSIGN;
			} else {
				_tmp41_ = FALSE;
			}
			if (!_tmp41_) {
				break;
			}
			_tmp46_ = token;
			_tmp47_ = _tmp46_->type;
			if (_tmp47_ == LEXER_TOKEN_TYPE_L_R_BRACKET) {
				gint _tmp48_ = 0;
				_tmp48_ = m_depth;
				m_depth = _tmp48_ + 1;
			} else {
				LexerToken* _tmp49_ = NULL;
				LexerTokenType _tmp50_ = 0;
				_tmp49_ = token;
				_tmp50_ = _tmp49_->type;
				if (_tmp50_ == LEXER_TOKEN_TYPE_R_R_BRACKET) {
					gint _tmp51_ = 0;
					gint _tmp52_ = 0;
					_tmp51_ = m_depth;
					m_depth = _tmp51_ - 1;
					_tmp52_ = m_depth;
					if (_tmp52_ == 0) {
						break;
					}
				}
			}
			_tmp53_ = argument_list;
			_tmp54_ = token;
			_tmp55_ = _tmp54_->text;
			_tmp56_ = g_strconcat (_tmp53_, _tmp55_, NULL);
			_g_free0 (argument_list);
			argument_list = _tmp56_;
			_tmp57_ = self->priv->lexer;
			_tmp58_ = lexer_get_next_token (_tmp57_);
			_g_object_unref0 (token);
			token = _tmp58_;
			_tmp59_ = num_token_parsed;
			num_token_parsed = _tmp59_ + 1;
		}
		_tmp60_ = token;
		_tmp61_ = _tmp60_->type;
		if (_tmp61_ != LEXER_TOKEN_TYPE_R_R_BRACKET) {
			guint _tmp64_ = 0U;
			while (TRUE) {
				gint _tmp62_ = 0;
				Lexer* _tmp63_ = NULL;
				_tmp62_ = num_token_parsed;
				num_token_parsed = _tmp62_ - 1;
				if (!(_tmp62_ > 0)) {
					break;
				}
				_tmp63_ = self->priv->lexer;
				lexer_roll_back (_tmp63_);
			}
			_tmp64_ = self->priv->depth_level;
			self->priv->depth_level = _tmp64_ - 1;
			result = FALSE;
			_g_free0 (argument_list);
			_g_free0 (power);
			_g_object_unref0 (token);
			_g_free0 (function_name);
			_g_object_unref0 (fun_token);
			return result;
		}
		_tmp65_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
		_tmp66_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
		_tmp67_ = argument_list;
		_tmp68_ = function_arguments_node_new (self, NULL, _tmp65_, _tmp66_, _tmp67_);
		_tmp69_ = _tmp68_;
		parser_insert_into_tree (self, (ParseNode*) _tmp69_);
		_g_object_unref0 (_tmp69_);
		_g_free0 (argument_list);
	} else {
		Lexer* _tmp70_ = NULL;
		gboolean _tmp71_ = FALSE;
		Lexer* _tmp74_ = NULL;
		LexerToken* _tmp75_ = NULL;
		LexerToken* _tmp76_ = NULL;
		LexerTokenType _tmp77_ = 0;
		guint _tmp87_ = 0U;
		gboolean _tmp88_ = FALSE;
		_tmp70_ = self->priv->lexer;
		lexer_roll_back (_tmp70_);
		_tmp71_ = parser_expression_1 (self);
		if (!_tmp71_) {
			Lexer* _tmp72_ = NULL;
			guint _tmp73_ = 0U;
			_tmp72_ = self->priv->lexer;
			lexer_roll_back (_tmp72_);
			_tmp73_ = self->priv->depth_level;
			self->priv->depth_level = _tmp73_ - 1;
			result = FALSE;
			_g_free0 (power);
			_g_object_unref0 (token);
			_g_free0 (function_name);
			_g_object_unref0 (fun_token);
			return result;
		}
		_tmp74_ = self->priv->lexer;
		_tmp75_ = lexer_get_next_token (_tmp74_);
		_g_object_unref0 (token);
		token = _tmp75_;
		_tmp76_ = token;
		_tmp77_ = _tmp76_->type;
		if (_tmp77_ == LEXER_TOKEN_TYPE_FACTORIAL) {
			LexerToken* _tmp78_ = NULL;
			LexerToken* _tmp79_ = NULL;
			LexerTokenType _tmp80_ = 0;
			guint _tmp81_ = 0U;
			LexerToken* _tmp82_ = NULL;
			Associativity _tmp83_ = 0;
			FactorialNode* _tmp84_ = NULL;
			FactorialNode* _tmp85_ = NULL;
			_tmp78_ = token;
			_tmp79_ = token;
			_tmp80_ = _tmp79_->type;
			_tmp81_ = parser_make_precedence_t (self, _tmp80_);
			_tmp82_ = token;
			_tmp83_ = parser_get_associativity (self, _tmp82_);
			_tmp84_ = factorial_node_new (self, _tmp78_, _tmp81_, _tmp83_);
			_tmp85_ = _tmp84_;
			parser_insert_into_tree_unary (self, (ParseNode*) _tmp85_);
			_g_object_unref0 (_tmp85_);
		} else {
			Lexer* _tmp86_ = NULL;
			_tmp86_ = self->priv->lexer;
			lexer_roll_back (_tmp86_);
		}
		_tmp87_ = self->priv->depth_level;
		self->priv->depth_level = _tmp87_ - 1;
		_tmp88_ = parser_expression_2 (self);
		if (!_tmp88_) {
			Lexer* _tmp89_ = NULL;
			_tmp89_ = self->priv->lexer;
			lexer_roll_back (_tmp89_);
			result = FALSE;
			_g_free0 (power);
			_g_object_unref0 (token);
			_g_free0 (function_name);
			_g_object_unref0 (fun_token);
			return result;
		}
		result = TRUE;
		_g_free0 (power);
		_g_object_unref0 (token);
		_g_free0 (function_name);
		_g_object_unref0 (fun_token);
		return result;
	}
	_tmp90_ = self->priv->depth_level;
	self->priv->depth_level = _tmp90_ - 1;
	result = TRUE;
	_g_free0 (power);
	_g_object_unref0 (token);
	_g_free0 (function_name);
	_g_object_unref0 (fun_token);
	return result;
}


static gboolean parser_term (Parser* self) {
	gboolean result = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	LexerToken* _tmp2_ = NULL;
	LexerTokenType _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_VARIABLE) {
		LexerToken* token_old = NULL;
		LexerToken* _tmp4_ = NULL;
		LexerToken* _tmp5_ = NULL;
		Lexer* _tmp6_ = NULL;
		LexerToken* _tmp7_ = NULL;
		LexerToken* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		gboolean _tmp10_ = FALSE;
		LexerToken* _tmp25_ = NULL;
		LexerTokenType _tmp26_ = 0;
		gboolean _tmp46_ = FALSE;
		_tmp4_ = token;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		token_old = _tmp5_;
		_tmp6_ = self->priv->lexer;
		_tmp7_ = lexer_get_next_token (_tmp6_);
		_g_object_unref0 (token);
		token = _tmp7_;
		_tmp8_ = token_old;
		_tmp9_ = _tmp8_->text;
		_tmp10_ = parser_check_variable (self, _tmp9_);
		if (!_tmp10_) {
			LexerToken* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			_tmp11_ = token;
			_tmp12_ = _tmp11_->text;
			if (g_strcmp0 (_tmp12_, "(") == 0) {
				LexerToken* _tmp13_ = NULL;
				const gchar* _tmp14_ = NULL;
				LexerToken* _tmp15_ = NULL;
				guint _tmp16_ = 0U;
				LexerToken* _tmp17_ = NULL;
				guint _tmp18_ = 0U;
				_tmp13_ = token_old;
				_tmp14_ = _tmp13_->text;
				_tmp15_ = token_old;
				_tmp16_ = _tmp15_->start_index;
				_tmp17_ = token_old;
				_tmp18_ = _tmp17_->end_index;
				parser_set_error (self, ERROR_CODE_UNKNOWN_FUNCTION, _tmp14_, _tmp16_, _tmp18_);
			} else {
				LexerToken* _tmp19_ = NULL;
				const gchar* _tmp20_ = NULL;
				LexerToken* _tmp21_ = NULL;
				guint _tmp22_ = 0U;
				LexerToken* _tmp23_ = NULL;
				guint _tmp24_ = 0U;
				_tmp19_ = token_old;
				_tmp20_ = _tmp19_->text;
				_tmp21_ = token_old;
				_tmp22_ = _tmp21_->start_index;
				_tmp23_ = token_old;
				_tmp24_ = _tmp23_->end_index;
				parser_set_error (self, ERROR_CODE_UNKNOWN_VARIABLE, _tmp20_, _tmp22_, _tmp24_);
			}
			result = FALSE;
			_g_object_unref0 (token_old);
			_g_object_unref0 (token);
			return result;
		}
		_tmp25_ = token;
		_tmp26_ = _tmp25_->type;
		if (_tmp26_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
			LexerToken* _tmp27_ = NULL;
			LexerToken* _tmp28_ = NULL;
			LexerTokenType _tmp29_ = 0;
			guint _tmp30_ = 0U;
			LexerToken* _tmp31_ = NULL;
			Associativity _tmp32_ = 0;
			LexerToken* _tmp33_ = NULL;
			const gchar* _tmp34_ = NULL;
			VariableWithPowerNode* _tmp35_ = NULL;
			VariableWithPowerNode* _tmp36_ = NULL;
			_tmp27_ = token_old;
			_tmp28_ = token_old;
			_tmp29_ = _tmp28_->type;
			_tmp30_ = parser_make_precedence_t (self, _tmp29_);
			_tmp31_ = token_old;
			_tmp32_ = parser_get_associativity (self, _tmp31_);
			_tmp33_ = token;
			_tmp34_ = _tmp33_->text;
			_tmp35_ = variable_with_power_node_new (self, _tmp27_, _tmp30_, _tmp32_, _tmp34_);
			_tmp36_ = _tmp35_;
			parser_insert_into_tree (self, (ParseNode*) _tmp36_);
			_g_object_unref0 (_tmp36_);
		} else {
			Lexer* _tmp37_ = NULL;
			LexerToken* _tmp38_ = NULL;
			LexerToken* _tmp39_ = NULL;
			LexerTokenType _tmp40_ = 0;
			guint _tmp41_ = 0U;
			LexerToken* _tmp42_ = NULL;
			Associativity _tmp43_ = 0;
			VariableNode* _tmp44_ = NULL;
			VariableNode* _tmp45_ = NULL;
			_tmp37_ = self->priv->lexer;
			lexer_roll_back (_tmp37_);
			_tmp38_ = token_old;
			_tmp39_ = token_old;
			_tmp40_ = _tmp39_->type;
			_tmp41_ = parser_make_precedence_t (self, _tmp40_);
			_tmp42_ = token_old;
			_tmp43_ = parser_get_associativity (self, _tmp42_);
			_tmp44_ = variable_node_new (self, _tmp38_, _tmp41_, _tmp43_);
			_tmp45_ = _tmp44_;
			parser_insert_into_tree (self, (ParseNode*) _tmp45_);
			_g_object_unref0 (_tmp45_);
		}
		_tmp46_ = parser_term_2 (self);
		if (!_tmp46_) {
			result = FALSE;
			_g_object_unref0 (token_old);
			_g_object_unref0 (token);
			return result;
		}
		result = TRUE;
		_g_object_unref0 (token_old);
		_g_object_unref0 (token);
		return result;
	} else {
		result = FALSE;
		_g_object_unref0 (token);
		return result;
	}
	_g_object_unref0 (token);
}


static gboolean parser_term_2 (Parser* self) {
	gboolean result = FALSE;
	LexerToken* token = NULL;
	Lexer* _tmp0_ = NULL;
	LexerToken* _tmp1_ = NULL;
	Lexer* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	LexerToken* _tmp4_ = NULL;
	LexerTokenType _tmp5_ = 0;
	LexerToken* _tmp8_ = NULL;
	LexerTokenType _tmp9_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = self->priv->lexer;
	lexer_roll_back (_tmp2_);
	_tmp4_ = token;
	_tmp5_ = _tmp4_->type;
	if (_tmp5_ == LEXER_TOKEN_TYPE_PL_EOS) {
		_tmp3_ = TRUE;
	} else {
		LexerToken* _tmp6_ = NULL;
		LexerTokenType _tmp7_ = 0;
		_tmp6_ = token;
		_tmp7_ = _tmp6_->type;
		_tmp3_ = _tmp7_ == LEXER_TOKEN_TYPE_ASSIGN;
	}
	if (_tmp3_) {
		result = TRUE;
		_g_object_unref0 (token);
		return result;
	}
	_tmp8_ = token;
	_tmp9_ = _tmp8_->type;
	if (_tmp9_ == LEXER_TOKEN_TYPE_VARIABLE) {
		guint _tmp10_ = 0U;
		Associativity _tmp11_ = 0;
		MultiplyNode* _tmp12_ = NULL;
		MultiplyNode* _tmp13_ = NULL;
		gboolean _tmp14_ = FALSE;
		_tmp10_ = parser_make_precedence_p (self, PRECEDENCE_MULTIPLY);
		_tmp11_ = parser_get_associativity_p (self, PRECEDENCE_MULTIPLY);
		_tmp12_ = multiply_node_new (self, NULL, _tmp10_, _tmp11_);
		_tmp13_ = _tmp12_;
		parser_insert_into_tree (self, (ParseNode*) _tmp13_);
		_g_object_unref0 (_tmp13_);
		_tmp14_ = parser_term (self);
		if (!_tmp14_) {
			result = FALSE;
			_g_object_unref0 (token);
			return result;
		}
		result = TRUE;
		_g_object_unref0 (token);
		return result;
	} else {
		result = TRUE;
		_g_object_unref0 (token);
		return result;
	}
	_g_object_unref0 (token);
}


static void value_parser_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_parser_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		parser_unref (value->data[0].v_pointer);
	}
}


static void value_parser_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = parser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_parser_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_parser_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Parser* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = parser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_parser_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Parser** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = parser_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecParser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PARSER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_parser (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER), NULL);
	return value->data[0].v_pointer;
}


void value_set_parser (GValue* value, gpointer v_object) {
	Parser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		parser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parser_unref (old);
	}
}


void value_take_parser (GValue* value, gpointer v_object) {
	Parser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parser_unref (old);
	}
}


static void parser_class_init (ParserClass * klass) {
	parser_parent_class = g_type_class_peek_parent (klass);
	((ParserClass *) klass)->finalize = parser_finalize;
	g_type_class_add_private (klass, sizeof (ParserPrivate));
	((ParserClass *) klass)->variable_is_defined = parser_real_variable_is_defined;
	((ParserClass *) klass)->get_variable = parser_real_get_variable;
	((ParserClass *) klass)->set_variable = parser_real_set_variable;
	((ParserClass *) klass)->function_is_defined = parser_real_function_is_defined;
	((ParserClass *) klass)->convert = parser_real_convert;
}


static void parser_instance_init (Parser * self) {
	self->priv = PARSER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void parser_finalize (Parser* obj) {
	Parser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PARSER, Parser);
	g_signal_handlers_destroy (self);
	_g_free0 (self->priv->input);
	_g_object_unref0 (self->priv->root);
	_g_object_unref0 (self->priv->right_most);
	_g_object_unref0 (self->priv->lexer);
	_g_free0 (self->priv->error_token);
}


GType parser_get_type (void) {
	static volatile gsize parser_type_id__volatile = 0;
	if (g_once_init_enter (&parser_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_parser_init, value_parser_free_value, value_parser_copy_value, value_parser_peek_pointer, "p", value_parser_collect_value, "p", value_parser_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Parser), 0, (GInstanceInitFunc) parser_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType parser_type_id;
		parser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Parser", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&parser_type_id__volatile, parser_type_id);
	}
	return parser_type_id__volatile;
}


gpointer parser_ref (gpointer instance) {
	Parser* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void parser_unref (gpointer instance) {
	Parser* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PARSER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



